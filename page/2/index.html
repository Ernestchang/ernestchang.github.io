<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>The Old Man and the Sea</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="All any predator can do is to keep on trying.">
<meta property="og:type" content="website">
<meta property="og:title" content="The Old Man and the Sea">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="The Old Man and the Sea">
<meta property="og:description" content="All any predator can do is to keep on trying.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Old Man and the Sea">
<meta name="twitter:description" content="All any predator can do is to keep on trying.">
    

    
        <link rel="alternate" href="/" title="The Old Man and the Sea" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">The Old Man and the Sea</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="https://ernestchang.github.io/2017/08/23/other/about/">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/uploads/images/avert.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="https://ernestchang.github.io/2017/08/23/other/about/">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/uploads/images/avert.png" />
            <h2 id="name">Ernest Chang</h2>
            <h3 id="title">Developer &amp; Designer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Hangzhou, China</span>
            <a id="follow" target="_blank" href="https://github.com/Ernestchang/">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                72
                <span>posts</span>
            </div>
            <div class="article-info-block">
                20
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Ernestchang/" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="twitter" class=tooltip>
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-java/面试之Java篇" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/java/面试之Java篇/">面试之Java篇</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/java/面试之Java篇/">
            <time datetime="2017-09-12T00:04:44.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/java/">java</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/java/面试/">面试</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="关键字transient-volatile"><a href="#关键字transient-volatile" class="headerlink" title="关键字transient volatile"></a>关键字transient volatile</h3><p><strong>transient</strong></p>
<blockquote>
<p>加了该关键字的属性，不会被序列化。</p>
</blockquote>
<p>换句话说，这个字段仅存于调用者内存，而不会写到磁盘里持久化。<br>序列化原理：将待续列化的对象中的信息写入到磁盘或网络流中。序列化中的引用会进行“深度复制”，并且如果两个对象有共同的引用对象，且两个对象都写入同一个流，那么该引用对象不会重复创建，只会创建一次，并还原到虚拟机后引用的还是同一个对象。但是，如果写入不同的流中，那么两次创建的是完全不同还原对象。</p>
<p><strong>volatile</strong></p>
<p>每个线程访问堆中对象时，将堆中对象<code>load</code>到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆变量值有任何关系，而是直接修改副本变量值。<br>修改完之后，自动把线程变量副本的值写到对象在堆变量中。这样堆中对象的值就产生了变化。这些操作不是原子性的。<br>使用volatile修饰变量，JVM只是保证从内存加载到线程工作内存中的值是最新的。因此，即使使用volatile还是会存在并发情况。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volatile static int a=0;</div><div class="line">//线程A和线程B同时执行</div><div class="line">a++;</div></pre></td></tr></table></figure>
<p>此时线程A拿到a的最新值0，线程B也拿到最新值0；但是，A执行a++后，值为1，B也同样计算得到a=1，它们再同时写回到堆内存，使得最后a的值为1，并不为2.</p>
<h3 id="Java1-7-1-8新特性"><a href="#Java1-7-1-8新特性" class="headerlink" title="Java1.7 1.8新特性"></a>Java1.7 1.8新特性</h3><p><strong>Java1.7</strong></p>
<p>（1）所有整数int， short，long，byte都可以用二进制表示，用0b开头。<br>（2）switch支持String类型。<br>（3）try-with-resource语句：在try()里面（括号里面）语句中声明一个或多个资源，try括号中的资源在最后会自动关闭.<br>（4）catch多个异常<br>（5）数字类型的下划线表示 更友好的表示方式，不过要注意下划线添加的一些标准，如:<br><code>long creditCardNumber = 1234_5678_9012_3456L;</code><br>(6)泛型实例的创建可以通过类型推断来简化 可以去掉后面new部分的泛型类型，只用&lt;&gt;就可以了</p>
<hr>
<p><strong>Java1.8</strong></p>
<p>(1)lambda表达式，最大的新增的特性<br>(2)允许给接口添加非抽象（即子类可以不用去实现）的方法，需要在方法前加default<br>(3)函数式接口。每个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所有也可以给函数式接口添加默认方法。我们可以将lambda表达式当成任意一个只包含一个抽象方法的接口类型。为确保你的接口满足这个要求，可以添加@FuntionalInterface注解。<br>(4)方法与构造函数引用。Java8允许使用<code>::</code>关键字来传递方法或者构造函数的引用。<br>(5) ……</p>
<h3 id="interface和abstract类区别"><a href="#interface和abstract类区别" class="headerlink" title="interface和abstract类区别"></a>interface和abstract类区别</h3><ol>
<li>继承方面: <code>abstract class</code>在Java中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个<code>interface</code>。</li>
<li>成员变量方面: 在<code>abstract class</code>中可以有自己的数据成员，也可以有<code>非abstarct</code>的方法，而在<code>interface</code>中，<strong>只能够有静态的不能被修改的数据成员</strong>（也就是必须是<code>static final</code>的，不过在<code>interface</code>中一般不定义数据成员），所有的方法都是<code>public abstract</code>的。</li>
<li>抽象方法方面: 实现抽象类和接口的类必须实现其中的所有抽象方法。抽象类中可以有非抽象方法，而接口中所有方法为抽象方法。</li>
<li>访问权限方面: 抽象类中的变量默认是<code>friendly</code>型，其值可以在子类中重新定义，也可以重新赋值。接口中定义的变量默认是<code>public static final</code>型，且必须给其赋初值，所以实现类中不能重新定义，也不能改变其值。</li>
<li>设计理念方面: <code>abstract class</code>和<code>interface</code>所反映出的设计理念不同。其实<code>abstract class</code>表示的是”<code>is-a</code>“关系，<code>interface</code>表示的是”<code>like-a</code>“关系。</li>
</ol>
<h3 id="XML解析方式DOM-SAX-PULL"><a href="#XML解析方式DOM-SAX-PULL" class="headerlink" title="XML解析方式DOM,SAX,PULL"></a>XML解析方式DOM,SAX,PULL</h3><p><strong>DOM</strong></p>
<p>通过DOM解析xml的好处就是:<br>我们可以随时访问到某个节点的相邻节点，并且对xml文档的插入也非常的方便</p>
<p>不好的地方就是:<br>其会将整个xml文档加载到内存中，这样会大大的占用我们的内存资源<br>对于手机来说，内存资源是非常非常宝贵的，所以在手机当中，通过DOM这种方式来解析xml是用的比较少的。使用DOM方式，类似JS，可以调用getElementsByTagName()、getChildNodes()等等方法。</p>
<hr>
<p><strong>SAX</strong></p>
<p><code>SAX</code>解析<code>xml</code>是基于事件流的处理方式的。因此每解析到一个标签，它并不会记录这个标签之前的信息，而我们只会知道当前这个标签的名字和它的属性，至于标签里面的嵌套，上层标签的名字这些都是无法知道的。SAX解析xml最重要的步骤就是定义一个我们自己的<code>Handler</code>处理类，我们可以让其继承 <code>DefaultHandler</code>这个类，然后在里面重写5个回调方法，分别是：</p>
<ul>
<li>startDocument</li>
<li>startElement</li>
<li>characters</li>
<li>endElement</li>
<li>endDocument</li>
</ul>
<hr>
<p><strong>PULL</strong></p>
<p><code>Pull</code>解析和<code>SAX</code>解析类似，都是基于事件流的方式，在<code>Android</code>中自带了<code>Pull</code>解析的jar包，所以我们不需要导入第三方的jar包了。Pull解析器和SAX解析器虽有区别但也有相似性。</p>
<p><strong>他们的区别为：</strong><br><code>SAX</code>解析器的工作方式是自动将事件推入注册的事件处理器进行处理，因此你不能控制事件的处理主动结束；而<code>Pull</code>解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。</p>
<p><strong>他们的相似性在运行方式上:</strong></p>
<blockquote>
<p>Pull解析器也提供了类似SAX的事件（开始文档<code>START_DOCUMENT</code>和结束文档<code>END_DOCUMENT</code>，开始 元素 <code>TART_TAG</code>和结束元素<code>END_TAG</code>，遇到元素内容<code>TEXT</code>等），但需要调用<code>next()</code>方法提取它们（主动提取事件）。调用parser.nextText();方法获取标签内的文本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); </div><div class="line">XmlPullParser xmlPullParser = factory.newPullParser(); </div><div class="line">xml.setInput(new StringReader(xmlData)); </div><div class="line"> </div><div class="line">int eventType = xmlPullParser.getEventType(); </div><div class="line"> </div><div class="line">while(eventType!=XmlPullParser.END_DOCUMENT)&#123; </div><div class="line">    String nodeName = xmlPullParser.getName(); </div><div class="line">    switch(eventType)&#123; </div><div class="line">        case XmlPullParser.START_DOCUMENT:&#123;&#125; </div><div class="line">        case XmlPullParser.START_TAG:&#123;&#125; </div><div class="line">        case XmlPullParser.END_TAG:&#123;&#125;  </div><div class="line">    &#125;  </div><div class="line">    eventType = parser.next(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="foreach和for循环"><a href="#foreach和for循环" class="headerlink" title="foreach和for循环"></a>foreach和for循环</h3><p><strong>foreach</strong></p>
<p>foreach本质是通过迭代器遍历，有如下特点：</p>
<ul>
<li>无需获取容器大小</li>
<li>需要创建额外的迭代器变量</li>
<li>遍历期间得到的是对象，没有索引位置信息，因此没办法将指定索引位置对象替换为新对象</li>
</ul>
<hr>
<p><strong>for</strong></p>
<ul>
<li>for需要获取容器大小，如果计算大小比较耗时，那么for循环效率肯定低下</li>
<li>for循环是根据容器大小防止越界，因此每次循环需要进行一次比较</li>
</ul>
<p><strong>效率</strong></p>
<p>由于每次循环时，使用<code>for</code>循环都得计算容器大小并且还需要比较，因此，在对容器里面的每个元素进行遍历时，<code>foreach</code>效率更高。</p>
<p>这个结论也不是绝对的，在选择<code>for</code>，<code>foreach</code>的时候，应该考虑以下几点：</p>
<ul>
<li>如果只是读数据，优先选择foreach，因为效率高，而且代码简单，方便；</li>
<li>如果要写数据，即替换指定索引位置处的对象，就只能选择for了，而且选择第二个for效率更高！</li>
</ul>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><blockquote>
<p>NIO是非阻塞的IO，Java NIO由一下几个核心部分组成：<code>Channels</code>、<code>Buffers</code>、<code>Selectors</code>。</p>
</blockquote>
<p>虽然Java NIO中除此之外还有很多类和组件，但是Channel，Buffer和Selector构成了核心的API。其他组件如Pipe和FileLock,只不过是与其他三个核心组件共同使用的工具类。</p>
<ul>
<li><code>Channel</code>：基本上所有的IO在NIO中都从一个Channel开始，Channel有点像流。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。Channel和Buffer有好多类型，Channel主要有：FileChannel、DataGramChannel、SocketChannel、ServerSocketChannel。涵盖了UDP和TCP网络的IO以及文件IO。</li>
<li><code>Buffer：</code>NIO主要的Buffer有：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer这些Buffer涵盖了你能通过IO发送的基本数据类型。</li>
<li><code>Selector</code>：允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如一个聊天服务器中。要使用Selector，得先向Selector注册Channel然后调用它的select()方法。这个方法会一直堵塞知道某个注册的通道有事件就绪。一旦这个方法返回线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</li>
</ul>
<hr>
<p><strong>NIO的使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// 注册</div><div class="line">// 创建Selector对象   </div><div class="line">Selector sel = Selector.open();   </div><div class="line">// 创建可选择通道，并配置为非阻塞模式   </div><div class="line">ServerSocketChannel server = ServerSocketChannel.open();   </div><div class="line">server.configureBlocking(false);   </div><div class="line"> </div><div class="line">// 绑定通道到指定端口   </div><div class="line">ServerSocket socket = server.socket();   </div><div class="line">InetSocketAddress address = new InetSocketAddress(port);   </div><div class="line">socket.bind(address);   </div><div class="line"> </div><div class="line">// 向Selector中注册感兴趣的事件   </div><div class="line">server.register(sel, SelectionKey.OP_ACCEPT);    </div><div class="line">return sel;</div><div class="line"></div><div class="line"></div><div class="line">// 处理</div><div class="line">try &#123;    </div><div class="line">    while(true) &#123; </div><div class="line">        // 该调用会阻塞，直到至少有一个事件发生 </div><div class="line">        selector.select(); </div><div class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); </div><div class="line">        Iterator&lt;SelectionKey&gt; iter = keys.iterator(); </div><div class="line">        while (iter.hasNext()) &#123; </div><div class="line">            SelectionKey key = (SelectionKey) iter.next(); </div><div class="line">            iter.remove(); </div><div class="line">            process(key); </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125; catch (IOException e) &#123;    </div><div class="line">    e.printStackTrace();   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>ByteBuffer使用</strong></p>
<p>创建ByteBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//（1）使用allocate()静态方法</div><div class="line">ByteBuffer buffer=ByteBuffer.allocate(256);</div><div class="line">//以上方法将创建一个容量为256字节的ByteBuffer,如果发现创建的缓冲区容量太小,唯一的选择就是重新创建一个大小合适的缓冲区.</div><div class="line"></div><div class="line">//（2）通过包装一个已有的数组来创建如下,通过包装的方法创建的缓冲区保留了被包装数组内保存的数据.</div><div class="line">ByteBuffer buffer=ByteBuffer.wrap(byteArray);</div><div class="line">// 如果要将一个字符串存入ByteBuffer,可以如下操作:</div><div class="line">String sendString=&quot;你好,服务器. &quot;; </div><div class="line">ByteBuffer sendBuffer=ByteBuffer.wrap(sendString.getBytes(&quot;UTF-16&quot;));</div></pre></td></tr></table></figure>
<p>缓冲区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">buffer.flip();</div><div class="line">//这个方法用来将缓冲区准备为数据传出状态,执行以上方法后,输出通道会从数据的开头而不是末尾开始.回绕保持缓冲区中的数据不变,只是准备写入而不是读取.</div><div class="line">buffer.clear();</div><div class="line">//这个方法实际上也不会改变缓冲区的数据,而只是简单的重置了缓冲区的主要索引值.不必为了每次读写都创建新的缓冲区,那样做会降低性能.相反,要重用现在的缓冲区,在再次读取之前要清除缓冲区.</div></pre></td></tr></table></figure>
<p>3.3 一个简单例子<br>使用通道和ByteBuffer实现文件复制功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public void copy(String from, String to) throws IOException &#123; </div><div class="line">    // 分配缓存 </div><div class="line">    ByteBuffer buff = ByteBuffer.allocate(128); </div><div class="line">    // 输入、输出通道 </div><div class="line">    FileChannel fin = null; </div><div class="line">    FileChannel fout = null; </div><div class="line">    try &#123; </div><div class="line">        // 初始化输入输出通道 </div><div class="line">        fin = new FileInputStream(from).getChannel(); </div><div class="line">        fout = new FileOutputStream(to).getChannel(); </div><div class="line">        // 从输入通道循环读取数据到缓存，并把缓存数据写入到输出通道 </div><div class="line">        while (fin.read(buff) != -1) &#123; </div><div class="line">            buff.flip(); </div><div class="line">            fout.write(buff); </div><div class="line">            buff.clear(); </div><div class="line">        &#125; </div><div class="line">    &#125; catch (FileNotFoundException e) &#123; </div><div class="line"> </div><div class="line">    &#125; finally &#123; </div><div class="line">        try &#123; </div><div class="line">            if (fin != null) &#123; </div><div class="line">                fin.close(); </div><div class="line">            &#125; </div><div class="line">            if (fout != null) &#123; </div><div class="line">                fout.close(); </div><div class="line">            &#125; </div><div class="line">        &#125; catch (IOException e) &#123; </div><div class="line">            throw e; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line">//如果需要将ByteBuffer转为FloatBuffer，则可以通过调用：</div><div class="line">ByteBuffer buff = ByteBuffer.allocate(128); </div><div class="line">buff.asFloatBuffer()</div><div class="line">//ByteBuffer转为其他的Buffer，如:CharBuffer、DoubleBuffer、IntBuffer、LongBuffer、ShortBuffer，都有对应的asXXXBuffer()方法。</div></pre></td></tr></table></figure>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p><strong>什么是反射</strong></p>
<p>反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，容许程序在运行时加载、探知、使用编译期间未知的class。即Java的反射机制可以加载一个运行时才得知名称的class，获得其完整结构。所谓的反射机制就是Java语言在运行时拥有一项自观的能力，即程序可以在运行时访问、检测和修改它本身状态或行为的一种能力。通过这种能力可以彻底的了解自身的情况为下一步的动作做准备。</p>
<p><strong>反射操作的对象</strong></p>
<p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息保存着每个对象所属的类足迹。虚拟机利用运行时信息选择相应的方法执行。然而，可以通过专门的Java类访问这些信息。保存这些信息的类称为Class，泛型形式为Class。Class是反射机制的基础，反射API通过操作Class来获取其完整结构。</p>
<p>Java的反射机制的实现要借助于4个类：<code>Class</code>，<code>Constructor</code>，<code>Field</code>，<code>Method</code>，通过这四个对象我们可以粗略的看到一个类的各个组成部分</p>
<p><strong>反射提供的功能</strong></p>
<p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<p>两种编译：</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象,即通过。</li>
<li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</li>
</ul>
<p>反射机制优缺点:</p>
<ul>
<li>优点：就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中 它的灵活性就表现的十分明显。</li>
<li>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。并且它饶过了源码，会干扰原来的内部逻辑。</li>
</ul>
<p>反射机制中常用API函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">// getClass()方式：</div><div class="line">/** </div><div class="line">* Object类中的getClass()方法返回一个Class类型的实例 </div><div class="line">*/ </div><div class="line">Boolean var1 = true; </div><div class="line">Class&lt;?&gt; classType1 = var1.getClass(); </div><div class="line">//输出：class java.lang.Boolean  </div><div class="line">System.out.println(classType1);</div><div class="line"></div><div class="line">//（2）T.class方式：</div><div class="line">/** </div><div class="line">*  </div><div class="line">* 运用T.class 语法(T是任意的Java类型) </div><div class="line">*/ </div><div class="line">Class&lt;?&gt; classType2 = Boolean.class; </div><div class="line">//输出：class java.lang.Boolean  </div><div class="line">System.out.println(classType2);</div><div class="line"></div><div class="line">//（3）Class.forName()方式：</div><div class="line">/** </div><div class="line">*  </div><div class="line">* 运用static method Class.forName()（使用时应该提供异常处理器） </div><div class="line">*/ </div><div class="line">Class&lt;?&gt; classType3 = Class.forName(&quot;java.lang.Boolean&quot;); </div><div class="line">//输出：class java.lang.Boolean  </div><div class="line">System.out.println(classType3);</div><div class="line"></div><div class="line">//（4）TYPE语法方式：</div><div class="line">/** </div><div class="line">*  </div><div class="line">* 运用primitive wrapper classes的TYPE语法 </div><div class="line">* 这里返回的是原生类型,和Boolean.class返回的不同 </div><div class="line">*/ </div><div class="line"> </div><div class="line">Class&lt;?&gt; classType4 = Boolean.TYPE; </div><div class="line">//输出：boolean  </div><div class="line">System.out.println(classType4);</div><div class="line">//注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。虚拟机为每个类型管理一个Class对象。因此，可以用==运算符实现两个类对象比较的操作。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// Class常用的方法：</div><div class="line">/** </div><div class="line"> * 返回类的名字 </div><div class="line"> * 如：java.lang.String </div><div class="line"> */ </div><div class="line">String getName(); </div><div class="line"> </div><div class="line">/** </div><div class="line"> * 快速地创建一个类的实例 </div><div class="line"> * 调用默认构造器，如果该类没有默认构造器，抛出异常 </div><div class="line"> * 如果要为构造器提供参数， </div><div class="line"> * 使用java.lang.reflect.Constructor中的newInstance方法 </div><div class="line"> */ </div><div class="line">Object newInstance(); </div><div class="line"> </div><div class="line">/** </div><div class="line">*  返回超类 </div><div class="line">*/ </div><div class="line">getSuperclass(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 给定名称的形式分别返回类支持的public域、方法和构造器数组， </div><div class="line">* 其中包括超类的公有成员 </div><div class="line">*/ </div><div class="line">Field[] getFields(); </div><div class="line">Method[] getMethods(); </div><div class="line">Constructor&lt;?&gt;[] getConstructors(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 获取指定的域、方法、构造函数 </div><div class="line">*/ </div><div class="line">Field getField(String name) </div><div class="line">Method getMethod(String name, Class&lt;?&gt;... parameterTypes) </div><div class="line">Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure>
<hr>
<p>使用反射分析类</p>
<p>一个类主要由修饰符，域，构造器，方法组成，而Field、Method、Constructor类，分别用于描述类的域、方法和构造器。另外java.lang.reflect包中的Modifier类可以分析访问修饰符。那么用它们就可以分析类。</p>
<ul>
<li>Class getDeclaringClass() 返回一个用于描述类中定义的构造器、方法或域的Class对象</li>
<li>String getName() 返回相应条目的名称</li>
<li>int getModifiers() 返回整型数值，用不同的位开关描述访问修饰符的使用状况</li>
<li>Constructor Class[] getExceptionTypes() 返回一个用于描述方法抛出的异常类型的Class对象数组</li>
<li>Class[] getParameterTypes() 返回一个用于描述参数类型的Class对象数组</li>
<li>Field Class getType() 用于返回描述域所属类型的Class类型对象</li>
<li>static String toString(int modifiers) 返回对应modifiers位设置的修饰符的字符串表示</li>
<li>static boolean isXXX(int modifiers) 检测方法名中对应的修饰符在modifiers中的值</li>
</ul>
<p>访问权限问题：</p>
<p>由于反射机制的默认行为受限于Java的访问控制，比如，访问私有的方法，字段，除非拥有访问权限，否则Java安全机制允许查看任意对象有哪些域，而不允许读它们的值（读取将抛异常）。然而如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，就需要调用Field、Method、Constructor对象的<code>setAccessible()</code>方法。</p>
<ul>
<li>void setAccessible(boolean flag) 为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置</li>
<li>boolean isAccessible() 返回反射对象的可访问标志的值</li>
<li>static void setAccessible(AccessibleObject[] array, boolean flag) 一种设置对象数组可访问标志的快捷方法</li>
</ul>
<h3 id="Object的公用方法"><a href="#Object的公用方法" class="headerlink" title="Object的公用方法"></a>Object的公用方法</h3><p>Object的共有方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//创建并返回此对象的一个副本。 </div><div class="line">protected  Object    clone() ; </div><div class="line"> </div><div class="line">//指示其他某个对象是否与此对象“相等” </div><div class="line">boolean    equals(Object obj) ; </div><div class="line"> </div><div class="line">/** </div><div class="line">* 当垃圾回收器确定不存在对该对象的更多引用时， </div><div class="line">* 由对象的垃圾回收器调用此方法 </div><div class="line">*/ </div><div class="line">protected void finalize() ; </div><div class="line"> </div><div class="line">//返回此 Object 的运行时类 </div><div class="line">Class getClass(); </div><div class="line"> </div><div class="line">//返回该对象的哈希码值 </div><div class="line">int hashCode(); </div><div class="line"> </div><div class="line">//唤醒在此对象监视器上等待的单个线程 </div><div class="line">void notify(); </div><div class="line"> </div><div class="line">//唤醒在此对象监视器上等待的所有线程 </div><div class="line">void notifyAll(); </div><div class="line"> </div><div class="line">//返回该对象的字符串表示 </div><div class="line">String toString(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 在其他线程调用此对象的 notify() </div><div class="line">* 方法或 notifyAll() 方法前，导致当前线程等待 </div><div class="line">*/ </div><div class="line">void wait(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法， </div><div class="line">* 或者超过指定的时间量前，导致当前线程等待 </div><div class="line">*/ </div><div class="line">void wait(long timeout); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法， </div><div class="line">* 或者其他某个线程中断当前线程，或者已超过某个实际时间量前， </div><div class="line">* 导致当前线程等待 </div><div class="line">*/ </div><div class="line">void wait(long timeout, int nanos);</div></pre></td></tr></table></figure>
<h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><p><strong>父类方面</strong></p>
<p>这两个方法来自不同的类分别是：<code>sleep</code>来自<code>Thread</code>类；<code>wait</code>来自<code>Object</code>类。</p>
<p>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</p>
<p><strong>锁方面</strong></p>
<p>最主要是<code>sleep</code>方法没有释放锁，而<code>wait</code>方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br><code>sleep</code>不出让系统资源；<code>wait</code>是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般<code>wait</code>不会加时间限制，因为如果<code>wait</code>线程的运行资源不够，再出来也没用，要等待其他线程调用<code>notify/notifyAll</code>唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。<code>sleep(milliseconds)</code>可以用时间指定使它自动唤醒过来，如果时间不到只能调用<code>interrupt()</code>强行打断。<br><code>Thread.sleep(0)</code>的作用是“触发操作系统立刻重新进行一次CPU竞争”。</p>
<p><strong>使用范围方面</strong></p>
<p>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized(x)&#123;  </div><div class="line">      x.notify()  </div><div class="line">     //或者wait()  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BlockingQueue-CountDownLatch"><a href="#BlockingQueue-CountDownLatch" class="headerlink" title="BlockingQueue CountDownLatch"></a>BlockingQueue CountDownLatch</h3><p><code>BlockingQueue</code></p>
<p><code>BlockingQueue</code>接口定义了一种阻塞的<code>FIFO queue</code>，每一个<code>BlockingQueue</code>都有一个容量：<br>当容量满时，往<code>BlockingQueue</code>中添加数据时会造成阻塞,当容量为空时，取元素操作会阻塞。<br><code>BlockingQueue</code>有两个实现类：<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>。</p>
<p><code>ArrayBlockingQueue</code></p>
<ul>
<li>一个由数组支持的有界阻塞队列</li>
<li>按先进先出原则排序</li>
<li>一旦创建好这个数组，就不能再增加其容量</li>
<li>试图向已满的队列中放入元素会导致操作受阻塞</li>
<li>试图从空的队列中提取元素将导致类似的阻塞。</li>
</ul>
<p><code>LinkedBlockingQueue</code></p>
<ul>
<li>LinkedBlockingQueue是一个基于已链接节点的、范围任意的blocking queue的实现</li>
<li>此队列按FIFO（先进先出）排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素</li>
<li>新元素插入到队列的尾部，并且队列检索操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低.</li>
<li>可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。</li>
<li>如果未指定容量，则它等于Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点 ，容量范围可以在构造方法参数中指定作为防止队列过度扩展。</li>
<li>此对象是 线程阻塞-安全的</li>
<li>不接受null元素</li>
<li>实现了Collection和Iterator接口的所有可选 方法</li>
<li>在JDK5/6中，LinkedBlockingQueue和ArrayBlocingQueue等对象的poll(long timeout, TimeUnit unit)存在内存泄露Leak的对象AbstractQueuedSynchronizer.Node，据称JDK5会在Update12里Fix，JDK6会在Update2里Fix</li>
</ul>
<p><strong>ArrayBlockingQueue和LinkedBlockingQueue的区别</strong></p>
<ul>
<li>队列中锁的实现不同<br><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；<br><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock<br>在生产或消费时操作不同</li>
<li><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；<br><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为Node进行插入或移除，会影响性能</li>
<li>队列大小初始化方式不同<br><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小；<br><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></li>
</ul>
<hr>
<p><code>CountDownLatch</code></p>
<p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。主要方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public CountDownLatch(count); </div><div class="line">public void countDown(); </div><div class="line">public void await() ;</div></pre></td></tr></table></figure>
<p>构造方法指定了计数的次数。countDown方法，当前线程调用此方法则计数减一。await方法，调用该方法会一直阻塞当前线程，直到计时器的值为0.</p>
<h3 id="锁的等级"><a href="#锁的等级" class="headerlink" title="锁的等级"></a>锁的等级</h3><p><code>synchronized</code>在修饰代码块的时候需要一个<code>reference</code>对象作为锁的对象. 在修饰实例方法的时候默认是当前实例对象作为锁的对象. 在修饰类方法（静态方法）时候默认是当前类的<code>Class</code>对象作为锁的对象.</p>
<p><code>synchronized</code>使用总结如下</p>
<ul>
<li>对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性</li>
<li>在静态方法上的锁，和实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。</li>
<li>关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单例的，就能互斥。</li>
<li>静态方法加锁，能和所有其他静态方法加锁的 进行互斥</li>
<li>静态方法加锁，和xx.class 锁效果一样，直接属于类的</li>
</ul>
<h3 id="synchronized-lock-reentrantLock"><a href="#synchronized-lock-reentrantLock" class="headerlink" title="synchronized lock reentrantLock"></a>synchronized lock reentrantLock</h3><p><strong>synchronized</strong></p>
<p>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，它是在 软件层面依赖JVM实现同步。</p>
<p><code>synchronized 方法的缺陷：</code></p>
<blockquote>
<p>若将一个大的方法声明为synchronized将会大大影响效率，典型地，若将线程类的方法run()声明为synchronized，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何synchronized方法的调用都永远不会成功。</p>
</blockquote>
<p>解决方案: 通过 synchronized关键字来声明synchronized 块。</p>
<hr>
<p><strong>Lock</strong></p>
<p><code>Lock</code>接口实现提供了比使用<code>synchronized</code>方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的<code>Condition</code>对象。在硬件层面依赖特殊的CPU指令实现同步更加灵活。</p>
<p><strong>什么是Condition</strong></p>
<p><code>Condition</code>接口将<code>Object</code>监视器方法（<code>wait</code>、<code>notify</code> 和 <code>notifyAll</code>）分解成截然不同的对象，以便通过将这些对象与任意 Lock实现组合使用，为每个对象提供多个等待<code>set</code>（wait-set）。其中，<code>Lock</code>替代了<code>synchronized</code>方法和语句的使用，<code>Condition</code>替代了 <code>Object</code>监视器方法的使用。</p>
<p>虽然<code>synchronized</code>方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁。例如，某些遍历并发访问的数据结果的算法要求使用”hand-over-hand”或”chain locking”：获取节点 A的锁，然后再获取节点B的锁，然后释放A并获取C，然后释放B并获取D，依此类推。Lock接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用这种技术。</p>
<p>随着灵活性的增加，也带来了更多的责任。不使用块结构锁就失去了使用<code>synchronized</code>方法和语句时会出现的锁自动释放功能。在大多数情况下，应该使用以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lock l = ...; //lock接口的实现类对象 </div><div class="line">l.lock(); </div><div class="line">try &#123; </div><div class="line">    // access the resource protected by this lock </div><div class="line">&#125; finally &#123; </div><div class="line">    l.unlock(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>java.util.concurrent.locks</code>包中有很多<code>Lock</code>的实现类，常用的有<code>ReentrantLock</code>、<code>ReadWriteLock</code>（实现类ReentrantReadWriteLock）.它们是具体实现类，不是Java语言关键字。</p>
<hr>
<p><strong>ReentrantLock</strong></p>
<p>一个可重入的互斥锁<strong>Lock</strong>，它具有与使用<code>synchronized</code>方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p>
<p>最典型的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class X &#123; </div><div class="line">   private final ReentrantLock lock = new ReentrantLock(); </div><div class="line">   // ... </div><div class="line"> </div><div class="line">   public void m() &#123;  </div><div class="line">     lock.lock();  // block until condition holds </div><div class="line">     try &#123; </div><div class="line">       // ... method body </div><div class="line">     &#125; finally &#123; </div><div class="line">       lock.unlock() </div><div class="line">     &#125; </div><div class="line">   &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>重入性：指的是同一个线程多次试图获取它所占有的锁，请求会成功。当释放锁的时候，直到重入次数清零，锁才释放完毕。</p>
</blockquote>
<p><code>ReentrantLock</code>的<code>lock</code>机制有2种，<strong>忽略中断锁</strong>和<strong>响应中断锁</strong>，这给我们带来了很大的灵活性。比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候<code>ReentrantLock</code>就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（<code>synchronized</code>原语就是如此）；第二，B线程中断自己（或者别的线程中断它），<code>ReentrantLock</code> 处理了这个中断，并且不再等待这个锁的到来，完全放弃。</p>
<p><strong>ReentrantLock相对于synchronized多了三个高级功能</strong></p>
<ol>
<li>等待可中断: 在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.<code>tryLock(long timeout, TimeUnit unit)</code></li>
<li>公平锁: 按照申请锁的顺序来依次获得锁称为公平锁.<code>synchronized</code>的是非公平锁,<code>ReentrantLock</code>可以通过构造函数实现公平锁.<code>new RenentrantLock(boolean fair)</code>公平锁和非公平锁。这2种机制的意思从字面上也能了解个大概：即对于多线程来说，公平锁会依赖线程进来的顺序，后进来的线程后获得锁。而非公平锁的意思就是后进来的锁也可以和前边等待锁的线程同时竞争锁资源。对于效率来讲，当然是非公平锁效率更高，因为公平锁还要判断是不是线程队列的第一个才会让线程获得锁。</li>
<li>绑定多个<code>Condition</code>: 通过多次<code>newCondition</code>可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过<code>await()</code>，<code>signal()</code></li>
</ol>
<hr>
<p><strong>synchronized和lock的用法与区别</strong></p>
<ol>
<li><code>synchronized</code>是托管给JVM执行的，而<code>Lock</code>是<code>Java</code>写的控制锁的代码。</li>
<li><code>synchronized</code>原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。　</li>
<li><code>Lock</code>用的是乐观锁方式。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li>
<li><code>ReentrantLock</code>必须在<code>finally</code>中释放锁，否则后果很严重，编码角度来说使用<code>synchronized</code>更加简单，不容易遗漏或者出错。</li>
<li><code>ReentrantLock</code>提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而<code>synchronized</code>一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。</li>
<li><code>synchronized</code>的话，锁的范围是整个方法或<code>synchronized</code>块部分；而<code>Lock</code>因为是方法调用，可以跨方法，灵活性更大</li>
</ol>
<p>一般情况下都是用<code>synchronized</code>原语实现同步，除非下列情况使用<code>ReentrantLock</code>:</p>
<ul>
<li>某个线程在等待一个锁的控制权的这段时间需要中断</li>
<li>需要分开处理一些wait-notify，<code>ReentrantLock</code>里面的<code>Condition</code>应用，能够控制<code>notify</code>哪个线程</li>
<li>具有公平锁功能，每个到来的线程都将排队等候</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>线程池基础</strong></p>
<p>配置线程池一般如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor( </div><div class="line">                    CORE_POOL_SIZE,MAXIMUM_POOL_SIZE,KEEP_ALIVE,TimeUnit.SECONDS, </div><div class="line">                      sPoolWorkQueue,sThreadFactory </div><div class="line">                      );</div></pre></td></tr></table></figure>
<p>当一个任务加入到线程池时:</p>
<ol>
<li>如果此时线程池中的数量小于<code>corePoolSize</code>，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量等于 <code>corePoolSize</code>，但是缓冲队列 <code>workQueue</code>未满，那么任务被放入缓冲队列。</li>
<li>如果此时线程池中的数量大于<code>corePoolSize</code>，缓冲队列<code>workQueue</code>满，并且线程池中的数量小于<code>maximumPoolSize</code>，新建线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量大于<code>corePoolSize</code>，缓冲队列<code>workQueue</code>满，并且线程池中的数量等于<code>maximumPoolSize</code>，那么通过 <code>handler</code>所指定的策略来处理此任务。</li>
<li>当线程池中的线程数量大于 <code>corePoolSize</code>时，如果某线程（非核心线程）空闲时间超过<code>keepAliveTime</code>，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li>
</ol>
<p>也就是,处理任务的优先级为：</p>
<ul>
<li>核心线程corePoolSize</li>
<li>任务队列workQueue</li>
<li>最大线程maximumPoolSize</li>
</ul>
<p>如果三者都满了，使用handler处理被拒绝的任务（一般为抛出java.util.concurrent.RejectedExecutionException异常）</p>
<hr>
<p><strong>线程池类型</strong></p>
<p>线程池主要有以下4种：</p>
<ol>
<li><code>FixedThreadPool</code>：线程数量固定的线程池，线程处于空闲状态时不会被回收，除非线程被关闭。当所有线程都处于活动状态时，新的任务都会处于等待状态，直到有线程空闲出来。</li>
<li><code>CachedThreadPool</code>：线程数量不固定，只有非核心线程，可以放任意多个线程（Integer.MAX_VALUE）,线程池里所有线程处于活动状态时，创建新的线程处理新来的任务。否则利用闲置的线程处理新任务。线程池里空闲线程有超时机制，时长为60秒。</li>
<li><code>ScheduledThreadPool</code>：核心线程数量是固定的，非核心线程是没有限制。当非核心线程闲置时会被立即回收。</li>
<li><code>SingleThreadExector</code>：内部只有一个核心线程，确保所有任务在同一个线程中按顺序执行。</li>
</ol>
<hr>
<p><strong>线程池使用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Runnable task=new Runnable()&#123; </div><div class="line">     Public void run()&#123; </div><div class="line">       //TODO ....... </div><div class="line">    &#125; </div><div class="line">&#125;; </div><div class="line"> </div><div class="line">//FixedThreadPool使用 </div><div class="line">ExecutorService fixedThreadPool=Executors.newFixedThreadPool(4); </div><div class="line">fixedThreadPool.execute(task); </div><div class="line"> </div><div class="line">//CachedThreadPool的使用 </div><div class="line">ExecutorService cachedThreadPool=Executors.newCachedThreadPool(); </div><div class="line">cachedThreadPool.execute(task);  </div><div class="line"> </div><div class="line">//ScheduledThreadPool的使用 </div><div class="line">ExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(4); </div><div class="line">//2000ms后执行task </div><div class="line">scheduledThreadPool.schedule(task,2000,TimeUnit.MILLISECONDS); </div><div class="line">//延迟10ms后，每隔1000ms执行一次task </div><div class="line">scheduledTheadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);  </div><div class="line"> </div><div class="line">//SingleThreadExector的使用 </div><div class="line">ExecutorService sigleThreadPool=Executors.newSingleThreadExecutor(); </div><div class="line">fixedThreadPool.execute(task);</div></pre></td></tr></table></figure>
<hr>
<p><strong>线程池的优点</strong></p>
<ul>
<li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销</li>
<li>能有效控制线程池的最大并发数，避免大量线程之间因互相抢占系统资源而导致阻塞。</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ul>
<h3 id="线程-ThreadLocal"><a href="#线程-ThreadLocal" class="headerlink" title="线程 ThreadLocal"></a>线程 ThreadLocal</h3><p>创建新线程的两种方法:</p>
<ul>
<li>通过实现<code>Runable</code>接口,再将<code>Runnable</code>作为<code>Thread</code>的构造函数参数创建Thread对象</li>
<li>通过继承Thread类本身。</li>
</ul>
<p>其实，Java中真正能创建新线程的只有Thread对象，通过Runnable的方式，最终还是需要通过Thread对象来创建线程。</p>
<p>当<code>JVM</code>启动时，通常都会有单个非守护线程（它通常会调用某个指定类的main方法）。<code>JVM</code>会继续执行线程，直到下列任一情况出现时为止：</p>
<ul>
<li>调用了Runtime类的<code>exit</code>方法，并且安全管理器允许退出操作发生。</li>
<li>非守护线程的所有线程都已停止运行，无论是通过从对run方法的调用中返回，还是通过抛出一个传播到run方法之外的异常。</li>
</ul>
<hr>
<p><strong>ThreadLocal设计理念和作用</strong></p>
<p><strong>设计理念</strong></p>
<p>为每个线程创造一个资源的复本。将每一个线程存取数据的行为加以隔离，实现的方法就是给予每个线程一个特定空间来保管该线程所独享的资源。</p>
<p><strong>作用</strong></p>
<p>为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。</p>
<p><strong>ThreadLocal使用</strong></p>
<p><code>ThreadLocal</code>实例通常是类中的<code>private static</code>字段，它们希望将状态与某一个线程相关联。每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且<code>ThreadLocal</code>实例是可访问的，在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 首先创建ThreadLocal对象：</div><div class="line">ThreadLocal&lt;Integer&gt; mValue=new ThreadLocal&lt;Integer&gt;();</div><div class="line">// 然后在线程中调用set和get方法来设置和获取值，例如：</div><div class="line">mValue.set(1); </div><div class="line">int value=mValue.get();</div></pre></td></tr></table></figure>
<p><strong>实现原理</strong></p>
<p>简单地说，就是在<code>ThreadLocal</code>类中有一个<code>Map</code>，用于存储每一个线程的变量的副本。<code>Map</code>的<code>Key</code>是<code>Thread</code>，<code>value</code>就是副本的值。</p>
<p>深入源码去看，<code>ThreadLocal</code>把线程和线程局部变量存在<code>ThreadLocalMap</code>中，而<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类，我们来看看<code>ThreadLocalMap</code>的部分源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; </div><div class="line"> </div><div class="line">    Object value; </div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; </div><div class="line">        super(k); </div><div class="line">        value = v; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>Map</code>的<code>key</code>是<code>ThreadLocal</code>对象的弱引用，当要抛弃掉<code>ThreadLocal</code>对象时，垃圾收集器会忽略这个<code>key</code>的引用而清理掉<code>ThreadLocal</code>对象 。</p>
<p>那么到底是<code>ThreadLocal</code>还是<code>Thread</code>持有<code>ThreadLocalMap</code>对象的引用呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* ThreadLocal values pertaining to this thread.  </div><div class="line"> * This map is maintained by the ThreadLocal class. </div><div class="line"> */ </div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure>
<p><code>ThreadLocalMap</code>变量属于<code>Thread</code>的内部属性,不同的<code>Thread</code>拥有完全不同的<code>ThreadLocalMap</code>变量.<code>Thread</code>中的<code>ThreadLocalMap</code>变量的值是在<code>ThreadLocal</code>对象进行set或者get操作时创建的.　 　　 在创建<code>ThreadLocalMap</code>之前,会首先检查当前<code>Thread</code>中的<code>ThreadLocalMap</code>变量是否已经存在,如果不存在则创建一个；如果已经存在,则使用当前<code>Thread</code>已创建的<code>ThreadLocalMap</code>.　</p>
<p><strong>ThreadLocal的接口方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * 返回此线程局部变量的初始值 </div><div class="line"> * </div><div class="line"> * 线程第一次使用 get() 方法访问变量时将调用此方法，但如果线程之前调用 </div><div class="line"> * 了 set(T) 方法，则不会对该线程再调用 initialValue 方法。通常，此 </div><div class="line"> * 方法对每个线程最多调用一次，但如果在调用 get() 后又调用了  </div><div class="line"> * remove()，则可能再次调用此方法。 </div><div class="line"> *  </div><div class="line"> * 该实现返回 null；如果程序员希望线程局部变量具有 null 以外的值，则 </div><div class="line"> * 必须为 ThreadLocal 创建子类，并重写此方法。通常将使用匿名内部类完 </div><div class="line"> * 成此操作。 </div><div class="line">*/ </div><div class="line">protected T initialValue(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 返回此线程局部变量的当前线程的值 </div><div class="line">*  </div><div class="line">* 如果变量没有用于当前线程的值，则先 </div><div class="line">* 将其初始化为调用initialValue() 方法返回的值。 </div><div class="line">*/ </div><div class="line">public T get(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 将此线程局部变量的当前线程副本中的值设置为指定值 </div><div class="line">*  </div><div class="line">* 大部分子类不需要重写此方法，它们只依靠 initialValue() 方法 </div><div class="line">* 来设置线程局部变量的值 </div><div class="line">*/ </div><div class="line">public void set(T value); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 移除此线程局部变量当前线程的值 </div><div class="line">*  </div><div class="line">* 如果此线程局部变量随后被当前线程 读取，且这期间当前线程没有 </div><div class="line">* 设置其值，则将调用其 initialValue() 方法重新初始化其值。 </div><div class="line">* 这将导致在当前线程多次调用 initialValue 方法。 </div><div class="line">*/ </div><div class="line">public void remove();</div></pre></td></tr></table></figure>
<p>如果希望线程局部变量初始化其它值，那么需要自己实现ThreadLocal的子类并重写该方法，通常使用一个内部类对ThreadLocal进行实例化。</p>
<p><strong>ThreadLocal如何做到线程安全</strong></p>
<p>从上面的分析我们可以得出：</p>
<ul>
<li>因为每个<code>Thread</code>在进行对象访问时,访问的都是各自线程自己的<code>ThreadLocalMap</code>，所以保证了<code>Thread</code>与<code>Thread</code>之间的数据访问隔离。</li>
<li>不同的<code>ThreadLocal</code>实例操作同一<code>Thread</code>时，<code>ThreadLocalMap</code>在存储时采用当前<code>ThreadLocal</code>的实例作为<code>key</code>来保证数据访问隔离（上面源码Entry处可以看出）。　</li>
</ul>
<p><strong>TheadLocal模式与同步机制的区别</strong></p>
<ol>
<li>实现机制: 同步机制采用了“以时间换空间”的方式,提供一份变量,让不同的线程排队访问.而ThreadLocal采用了“以空间换时间”的方式,为每一个线程都提供一份变量的副本,从而实现同时访问而互不影响。</li>
<li>同步共享方面: Java中的synchronized是一个保留字,它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性.在同步机制中,通过对象的锁机制保证同一时间只有一个线程访问变量.此时,被用作“锁机制”的变量是多个线程共享的；而ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本，从而隔离了多个线程的数据，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。　 　 3.使用场合同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式。而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制。如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal。</li>
</ol>
<h3 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h3><blockquote>
<p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
</blockquote>
<p><strong>强引用(StrongReference)</strong></p>
<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如代码String s=”abc”中变量s就是字符串对象”abc”的一个强引用。只要你给强引用对象s赋空值null,该对象就可以被垃圾回收器回收。因为该对象此时不再含有其他强引用。</p>
<p><strong>软引用（SoftReference）</strong></p>
<p>如果内存足够，不回收；如果内存不足，则回收。软引用可用来实现内存敏感的高速缓存。软引用可以和引用队列<code>ReferenceQueue</code>联合使用，如果软引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">String str=new String(&quot;Test&quot;);</div><div class="line">ReferenceQueue&lt;String&gt; rq=new ReferenceQueue&lt;String&gt;(); </div><div class="line">SoftReference&lt;String&gt; sr=new SoftReference&lt;String&gt;(str,rq); </div><div class="line">str = null;         // 将强引用撤销</div><div class="line"></div><div class="line">// 或者</div><div class="line">SoftReference&lt;String&gt; sr=new SoftReference&lt;String&gt;(str); </div><div class="line">str=null;//将强引用撤掉</div><div class="line"></div><div class="line">// 取出对象</div><div class="line">String s = sr.get();</div></pre></td></tr></table></figure>
<p>如果被回收，则s为null，否则，s即为str所指引的对象”Test”</p>
<p><strong>弱引用(WeakReference)</strong></p>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象，弱引用非常适合存储元数据。另一个使用弱引用的例子是<code>WeakHashMap</code>，它是除<code>HashMap</code>和<code>TreeMap</code>之外，Map接口的另一种实现。<code>WeakHashMap</code>有一个特点：<code>Map</code>中的键值(keys)都被封装成弱引用，也就是说一旦强引用被删除，<code>WeakHashMap</code>内部的弱引用就无法阻止该对象被垃圾回收器回收。弱引用的使用跟软引用使用方式相同，只是将<code>SoftReference</code>替换为<code>WeakReference</code>。</p>
<p><strong>虚引用(PhantomReference)</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用 必须 和引用队列 （<code>ReferenceQueue</code>）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p><strong>static静态修饰符</strong></p>
<p>在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的。<code>static</code>修饰符表示静态的，在类加载时<code>JVM</code>会把它放到<strong>方法区</strong>，被本类以及本类的所有实例所共用。在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间。如果一个被所有实例共用的方法被申明为<code>static</code>，那么就可以节省空间，不用每个实例初始化的时候都被分配到内存。</p>
<p>我们比较常见的<code>static</code>修饰是在静态变量和静态方法中。它们可以直接通过类名来访问。下面我们看看关于静态代码块和静态类。</p>
<hr>
<p><strong>静态代码块</strong></p>
<p>说起静态代码块，就不得不说类初始化。类初始化是类加载的最后一步，前面类加载过程中，除了加载阶段用户可以通过自定义类加载器参与以外，其余动作都是虚拟机主导和控制。到了初始化阶段，才是真正执行类中定义Java程序代码。</p>
<p>准备阶段中，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划初始化类变量。初始化过程其实是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是按照语句在源文件中出现的顺序。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。</p>
<p><code>&lt;clinit&gt;()</code>方法与类构造函数（或者说实例构造器()）不同，他不需要显式地调用父类构造器，虚拟机会保证子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</p>
<hr>
<p><strong>静态类</strong></p>
<ul>
<li>只能在内部类中定义静态类</li>
<li>静态内部类与外层类绑定，即使没有创建外层类的对象，它一样存在。</li>
<li>静态类的方法可以是静态的方法也可以是非静态的方法，静态的方法可以在外层通过静态类调用，而非静态的方法必须要创建类的对象之后才能调用。</li>
<li>只能引用外部类的static成员变量（也就是类变量）。</li>
<li>如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态的。</li>
</ul>
<h3 id="集合的区别"><a href="#集合的区别" class="headerlink" title="集合的区别"></a>集合的区别</h3><p><strong>Map</strong></p>
<blockquote>
<p>键映射到值的对象。</p>
</blockquote>
<p>有如下特点:</p>
<ul>
<li>一个映射不能包含重复的键</li>
<li>每个键最多只能映射到一个值。</li>
<li>某些映射实现可明确保证其顺序，如TreeMap类</li>
<li>另一类映射实现则不保证顺序如HashMap</li>
</ul>
<p><code>Map</code>可以将<code>key</code>序列、<code>value</code>序列单独抽取出来。使用<code>keySet()</code>抽取key序列，将所有<code>key</code>生成一个<code>Set</code>。使用<code>values</code>抽取<code>value</code>序列，将所有value生成一个<code>Collection</code>，为什么key生成<code>Set</code>，而value生成<code>Collection</code>？因为key总是独一无二，<code>value</code>允许重复。</p>
<p>Map接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Set&lt;K&gt; keySet(); </div><div class="line">Collection&lt;V&gt; values(); </div><div class="line"> </div><div class="line">V remove(Object key); </div><div class="line">V get(Object key); </div><div class="line">V put(K key, V value); </div><div class="line">void putAll(Map&lt;? extends K, ? extends V&gt; m); </div><div class="line"> </div><div class="line">boolean containsKey(Object key); </div><div class="line">boolean containsValue(Object value); </div><div class="line"> </div><div class="line">void clear(); </div><div class="line">int size(); </div><div class="line">boolean isEmpty();</div></pre></td></tr></table></figure>
<p><strong>Set</strong></p>
<p>不能包含重复元素的<code>Collection</code>。如下特征：</p>
<ul>
<li>Set不包含满足e1.euqals(e2)</li>
<li>最多包含一个null元素(这里是指HashSet,TreeSet不支持插入null)</li>
<li>不可随机访问包含的元素</li>
<li>Set没有同步方法。</li>
</ul>
<p>Set接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">boolean add(E e); </div><div class="line">boolean remove(Object o); </div><div class="line"> </div><div class="line">boolean addAll(Collection&lt;? extends E&gt; c); </div><div class="line">boolean removeAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">boolean contains(Object o); </div><div class="line">boolean containsAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">boolean retainAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">Object[] toArray(); </div><div class="line">T[] toArray(T[] a); </div><div class="line"> </div><div class="line">void clear(); </div><div class="line">int size(); </div><div class="line">boolean isEmpty();</div></pre></td></tr></table></figure>
<hr>
<p><strong>List</strong></p>
<p>如下特征：</p>
<ul>
<li>可随机访问包含的元素</li>
<li>元素是有序的</li>
<li>可在任意位置增、删元素</li>
<li>允许重复元素。</li>
</ul>
<p>List接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">E get(int index); </div><div class="line">E set(int index, E element); </div><div class="line"> </div><div class="line">boolean add(E e); </div><div class="line">boolean remove(Object o); </div><div class="line"> </div><div class="line">boolean addAll(Collection&lt;? extends E&gt; c); </div><div class="line">boolean removeAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">boolean contains(Object o); </div><div class="line">boolean containsAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">int indexOf(Object o); </div><div class="line">int lastIndexOf(Object o); </div><div class="line"> </div><div class="line">boolean retainAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">Object[] toArray(); </div><div class="line"> </div><div class="line">void clear(); </div><div class="line">int size(); </div><div class="line">boolean isEmpty();</div></pre></td></tr></table></figure>
<p><strong>Queue</strong></p>
<p>队列，特点是先进先出。</p>
<p><code>Queue</code>在使用时尽量避免<code>Collection</code>的<code>add()</code>和<code>remove()</code>方法，而是要使用<code>offer()</code>来加入元素，使用<code>poll</code>来获取并移出元素。他们的优点是通过返回值可以判断成功与否。<code>add()</code>和<code>remove()</code>方法在失败的时候会抛出异常。</p>
<p>如果使用而不移出该元素，使用<code>element()</code>或者<code>peek()</code>方法。值得注意的是<code>LinkedList</code>类实现了<code>Queue</code>接口，因此我们可以把<code>LinkedList</code>当初<code>Queue</code>来用。</p>
<p><code>Queue</code>实现通常不允许插入<code>null</code>元素。尽管某些实现（如LinkedList）并不禁止将null插入到Queue中，即使在允许null的实现中，也不应将null插入到Queue中，因为<code>null</code>也作<code>poll</code>方法的一个特殊返回值，表明队列不包含元素。</p>
<p>Queue接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//插入新元素到队列，如果插入成功，返回true， </div><div class="line">//如果队列已满，抛出IllegalStateException异常 </div><div class="line">boolean add(E e); </div><div class="line"> </div><div class="line">//插入新元素到队列，如果插入成功返回true </div><div class="line">//如果队列已满，返回false，但不抛出异常 </div><div class="line">boolean offer(E e); </div><div class="line"> </div><div class="line">//返回第一个元素，并将该元素从队列中删除 </div><div class="line">//如果队列为空，抛出异常 </div><div class="line">E remove(); </div><div class="line"> </div><div class="line">//返回第一个元素，并将该元素从队列中删除 </div><div class="line">//如果队列为空，返回null </div><div class="line">E poll(); </div><div class="line"> </div><div class="line">//返回队列的第一个元素， </div><div class="line">//如果队列为空，抛异常 </div><div class="line">E element(); </div><div class="line"> </div><div class="line">//返回队列的第一个元素， </div><div class="line">//如果队列为空，返回null </div><div class="line">E peek();</div></pre></td></tr></table></figure>
<p><code>Queue</code>接口有子接口<code>BlockingQueue</code>和<code>Deque</code>，<code>BlockingQueue</code>表示阻塞队列；<code>Deque</code>是双向队列，即可以从两端插入元素。<code>BlockingQueue</code>有如下几个实现类：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
</ul>
<p>主要看看BlockingQueue的两个新方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//插入一个新元素，如果队列已满，则一直等待（阻塞） </div><div class="line">void put(E e) throws InterruptedException; </div><div class="line"> </div><div class="line">//返回队列的第一个元素并将该元素从队列里删除，如果队里为空，则一直等待（阻塞） </div><div class="line">E take() throws InterruptedException;</div></pre></td></tr></table></figure>
<p><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>是阻塞队列的不同实现，即一个是通过数组方式，一个是通过链表的方式实现的阻塞队列。</p>
<p>有个特殊的接口<code>BlockingDeque</code>，<code>BlockingDeque</code>既实现了<code>BlockingQueue</code>又实现了<code>Deque</code>,而<code>BlockingDeque</code>的实现类有</p>
<ul>
<li>LinkedBlockingDeque</li>
<li>前面我们说到，接口Deque是双向队列。接口Deque添加了如下新方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void addFirst(E e); </div><div class="line">void addLast(E e); </div><div class="line">boolean offerFirst(E e); </div><div class="line">boolean offerLast(E e); </div><div class="line">E removeFirst(); </div><div class="line">E removeLast(); </div><div class="line">E pollFirst(); </div><div class="line">E pollLast(); </div><div class="line">E getFirst(); </div><div class="line">E getLast(); </div><div class="line">E peekFirst(); </div><div class="line">E peekLast();</div></pre></td></tr></table></figure>
<hr>
<p><strong>Stack</strong></p>
<p><code>Stack</code>继承自<code>Vector</code>（可增长的对象数组），也是同步的。他通过五个操作对类Vector进行了扩展，允许将向量视为堆栈。他提供了通常的<code>push</code>和<code>pop</code>操作，以及取堆栈顶点的<code>peek</code>方法。测试堆栈是否为空的<code>empty</code>方法、在堆栈中查找项并确定对堆栈顶距离的<code>search</code>方法。</p>
<p>Stack类的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public E push(E item); </div><div class="line">public synchronized E pop(); </div><div class="line"> </div><div class="line">//返回栈顶的元素，但不将其出栈 </div><div class="line">public synchronized E peek(); </div><div class="line">public synchronized int search(Object o); </div><div class="line">public boolean empty();</div></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常类继承关系图:</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/throwable.png" alt="img"></p>
<p><strong>Throwable</strong></p>
<p><code>Throwable</code>类是所有错误或异常的超类。只有当对象是此类或其子类之一的实例时，才能通过<code>JVM</code>或者是通过<code>throw</code>语句抛出；另外<code>catch</code>子句中的参数类型也必须是该类型。</p>
<p><code>Throwable</code>类及其子类有两个构造方法:</p>
<ul>
<li>不带参数</li>
<li>带有 String 参数，此参数可用于生成详细消息。</li>
</ul>
<p><code>Throwable</code>包含了其线程创建时线程执行堆栈的快照。它还包含了给出有关错误更多信息的消息字符串。<code>Java</code>将可抛出(Throwable)的结构分为三种类型：</p>
<ul>
<li>错误(Error)</li>
<li>运行时异常(RuntimeException)</li>
<li>被检查的异常(Checked Exception)</li>
</ul>
<hr>
<p><strong>Error</strong></p>
<p><code>Error</code>是<code>Throwable</code>的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。和<code>RuntimeException</code>一样， 编译器也不会检查<code>Error</code>。当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误，程序本身无法修复这些错误的。 　</p>
<hr>
<p><strong>Exception</strong></p>
<p><code>Exception</code>类及其子类是<code>Throwable</code>的一种形式，它指出了合理的应用程序想要捕获的条件。对于可以恢复的条件使用被检查异常（Exception的子类中除了<code>RuntimeException</code>之外的其它子类），对于程序错误使用运行时异常。　</p>
<p><code>ClassNotFoundException</code></p>
<p>当应用程序试图使用以下方法通过字符串名加载类时：</p>
<ul>
<li>Class 类中的 forName 方法。</li>
<li>ClassLoader 类中的 findSystemClass 方法。</li>
<li>ClassLoader 类中的 loadClass 方法。</li>
</ul>
<p>但是没有找到具有指定名称的类的定义，抛出该异常。</p>
<p><code>CloneNotSupportedException</code></p>
<p>当调用<code>Object</code>类中的<code>clone</code>方法复制对象，但该对象的类无法实现<code>Cloneable</code>接口时，抛出该异常。重写<code>clone</code>方法的应用程序也可能抛出此异常，指示不能或不应复制一个对象。</p>
<p><code>IOException</code></p>
<p>当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</p>
<ul>
<li>EOFException: 当输入过程中意外到达文件或流的末尾时，抛出此异常。此异常主要被数据输入流用来表明到达流的末尾。注意：其他许多输入操作返回一个特殊值表示到达流的末尾，而不是抛出异常。</li>
<li>FileNotFoundException: 当试图打开指定路径名表示的文件失败时，抛出此异常。在不存在具有指定路径名的文件时，此异常将由 <code>FileInputStream</code>、<code>FileOutputStream</code>和<code>RandomAccessFile</code>构造方法抛出。如果该文件存在，但是由于某些原因不可访问，比如试图打开一个只读文件进行写入，则此时这些构造方法仍然会抛出该异常。</li>
<li>MalformedURLException: 抛出这一异常指示出现了错误的URL。或者在规范字符串中找不到任何合法协议，或者无法解析字符串。　</li>
<li>UnknownHostException: 指示主机IP地址无法确定而抛出的异常。</li>
</ul>
<hr>
<p><strong>RuntimeException</strong></p>
<p>是那些可能在Java虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的<code>RuntimeException</code>的任何子类都无需在<code>throws</code>子句中进行声明。<code>Java</code>编译器不会检查它。当程序中可能出现这类异常时，还是会编译通过。虽然<code>Java</code>编译器不会检查运行时异常，但是我们也可以通过<code>throws</code>进行声明抛出，也可以通过<code>try-catch</code>对它进行捕获处理。</p>
<ul>
<li><p><code>ArithmeticException</code>：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</p>
</li>
<li><p><code>ClassCastException</code>：当试图将对象强制转换为不是实例的子类时，抛出该异常。例如：Object x = new Integer(0);</p>
</li>
<li><p><code>IllegalArgumentException</code>：抛出的异常表明向方法传递了一个不合法或不正确的参数。</p>
</li>
<li><p><code>IllegalStateException</code>：在非法或不适当的时间调用方法时产生的信号。换句话说，即Java环境或Java应用程序没有处于请求操作所要求的适当状态下。</p>
</li>
<li><p><code>IndexOutOfBoundsException</code>：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 应用程序可以为这个类创建子类，以指示类似的异常。</p>
</li>
<li><p><code>NoSuchElementException</code>：由<code>Enumeration</code>的<code>nextElement</code>方法抛出，表明枚举中没有更多的元素。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NullPointerException</div></pre></td></tr></table></figure>
<p>：当应用程序试图在需要对象的地方使用null时，抛出该异常。这种情况包括：</p>
<ol>
<li>调用null对象的实例方法。</li>
<li>访问或修改null对象的字段。</li>
<li>将null作为一个数组，获得其长度。</li>
<li>将null作为一个数组，访问或修改其时间片。</li>
<li>将null作为Throwable值抛出。</li>
<li>应用程序应该抛出该类的实例，指示其他对null对象的非法使用。</li>
</ol>
</li>
</ul>
<hr>
<p><strong>SOF（堆栈溢出 StackOverflow）</strong></p>
<blockquote>
<p>当应用程序递归太深而发生堆栈溢出时，抛出StackOverflowError错误。</p>
</blockquote>
<p>程序中一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过默认大小而导致溢出。我在8G的内存下，用eclipse进行递归调用测试，递归11410次后抛SOF异常</p>
<p>栈溢出的原因：</p>
<ul>
<li>递归调用</li>
<li>大量循环或死循环</li>
<li>全局变量是否过多</li>
<li>数组、List、map数据过大</li>
</ul>
<hr>
<p><strong>Android的OOM（Out Of Memory）</strong></p>
<blockquote>
<p>当内存占有量超过了虚拟机的分配的最大值时就会产生内存溢出（VM里面分配不出更多的page）</p>
</blockquote>
<p>一般出现情况：</p>
<ul>
<li>加载的图片太多或图片过大时</li>
<li>分配特大的数组</li>
<li>内存相应资源过多没有来不及释放。</li>
</ul>
<p>解决方法：</p>
<ol>
<li>在内存引用上做处理</li>
<li>对图片进行边界压缩, 配合软引用使用</li>
<li>显示的调用GC来回收内存例如<code>if(bitmapObject.isRecycled()==false) //如果没有回收 bitmapObject.recycle();</code></li>
<li>优化Dalvik虚拟机的堆内存分配<ul>
<li>增强堆内存的处理效率<code>VMRuntime.getRuntime().setTargetHeapUtilization(0.75);</code></li>
<li>设置堆内存的大小: <code>VMRuntime.getRuntime().setMinimumHeapSize(6 * 1024 * 1024);</code> 设置最小heap内存为6MB大小</li>
</ul>
</li>
<li>用LruCache和AsyncTask解决</li>
</ol>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">double floor(double a);     // 向下取整</div><div class="line"></div><div class="line">double random();            // 产生随机数取值范围[0,1)</div><div class="line"></div><div class="line">double ceil();              // 向上取整</div><div class="line"></div><div class="line">long round(double a);       // 四舍五入</div></pre></td></tr></table></figure>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>equals与==的区别</strong></p>
<ul>
<li><code>==</code>：对于基本类型，比较的是它们的值。对于复合类型（直接在堆中分配空间），比较的是它们在内存中的地址。</li>
<li><code>equals</code>：该方法属于Object，而所有类都继承于Object这个基类，因此每个类都有这个方法。Object类中equals的默认实现是return (this == obj);，即默认是比较对象的内存地址。但在库中的一些类会覆盖重写equals这个方法，如：<code>String</code>、<code>Integer</code>、<code>Date</code>这些类中equals有自身的实现，而不再是比较类在堆内存中的地址。String中的equals，首先判断==，如果地址相同，那一定是返回true；如果地址不相同，再比较字符串字面值是否相等。</li>
</ul>
<hr>
<p><strong>Switch能否用string做参数?</strong></p>
<p>在Java7之前，<code>switch</code>只支持<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>及其对应的封装类，以及<code>Enum</code>类型，在Java 7中，String类型被加上。</p>
<hr>
<p><strong>String、StringBuffer与StringBuilder的区别</strong></p>
<ol>
<li>字符串是否可变<ul>
<li>String: 使用字符数组保存字符串：private final char value[];关键字final决定了String对象不可变。</li>
<li>StringBuilder和StringBuffer继承自AbStractStringBuilder类，AbstractStringBuilder类也是使用字符数组保存字符串：char[] value;没有final，可知这两个对象都是可变的。</li>
</ul>
</li>
<li>线程安全<ul>
<li>String对象不可变，也就可以理解为常量，显然线程安全。</li>
<li>StringBuffer对方法加了同步锁，因此是线程安全的。</li>
<li>StringBuilder没有加锁，是非线程安全的。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>String 常用的函数</strong></p>
<p><strong>split</strong></p>
<p>split函数原型为：<code>String[] split(String regex)</code>。参数<code>regex</code>不是一个简单的字符串，而是一个正则表达式。因此，对于正则表达式中的关键字你需要使用转意符<code>\</code>，例如.和<code>|</code>都是转义字符,必须得加<code>&quot;\\&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如果用.作为分隔的话,必须写为String.split(&quot;\\.&quot;)，而不能直接这样String.split(&quot;.&quot;);</div><div class="line">如果用|作为分隔的话,必须写为String.split(&quot;\\|&quot;)，而不能直接这样String.split(&quot;|&quot;);</div><div class="line">如果在一个字符串中有多个分隔符,可以用|作为连字符，比如待分割的字符串为String s=&quot;my; name,is HuaChao&quot;，如果希望把单词提取出来（以标点符号和空格为分割字符），可以写为：s.split(&quot;,| |;&quot;);注意， 两个|之间有空格，&quot;,| |;&quot;表示，以,或空格以及;分割字符串。</div></pre></td></tr></table></figure>
<p><strong>replace、replaceAll、replaceFirst</strong></p>
<ul>
<li>replace:原型为String replace(char oldChar, char newChar) ，即将所有的oldChar字符替换为newChar字符</li>
<li>replace:原型为String replace(CharSequence target, CharSequence replacement) ，即将所有的target字符串替换为replacement字符串</li>
<li>replaceAll：原型为String replaceAll(String regex, String replacement)，参数regex从名称可以看出，它是一个正则表达式。replacement为替换的新字符串，即将原字符串中，所有满足正则表达式regex的部分替换为replacement</li>
<li>replaceFirst：原型为String replaceFirst(String regex, String replacement) ，跟replaceAll很像，只不过replaceFirst是替换第一个满足正则表达式regex的部分。</li>
</ul>
<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws Exception &#123; </div><div class="line">    String s=&quot;my.name.is.HuaChao&quot;;  </div><div class="line">    System.out.println(s.replace(&apos;.&apos;, &apos;*&apos;));  </div><div class="line">    System.out.println(s.replace(&quot;.&quot;, &quot;*&quot;));  </div><div class="line">    System.out.println(s.replaceAll(&quot;.&quot;, &quot;*&quot;));  </div><div class="line">    System.out.println(s.replaceFirst(&quot;.&quot;, &quot;*&quot;));  </div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">my*name*is*HuaChao </div><div class="line">my*name*is*HuaChao </div><div class="line">****************** </div><div class="line">*y.name.is.HuaChao</div></pre></td></tr></table></figure>
<p>运行结果中，很好理解，第1个replace里面的参数是字符，不是正则表达式，replace会把所有的.字符替换为<code>*</code>；同样，第二个replace里面的参数是字符串，不是正则表达式；而replaceAll中，第一个参数是正则表达式，第二个参数是字符串，而正则表达式中的<code>.</code>是表示任意字符，因此，会把所有的字符替换为<code>*</code>；最后replaceFirst，只替换第一个字符。</p>
<hr>
<p><strong>正则表达式</strong></p>
<p>如果我们需要从字符串中匹配出满足我们自定义的正则表达式的部分，就可以通过使用Pattern这个类。我们先看一个实际应用，假设我们要取出一个字符串中所有的字母，并显式出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123; </div><div class="line">    String dataStr = &quot;---&gt;我是干扰字符&lt;---M12v,L23f,d34&quot;; </div><div class="line">    Pattern pattern = Pattern.compile(&quot;[a-zA-Z]&quot;); </div><div class="line">    Matcher matcher = pattern.matcher(dataStr); </div><div class="line">    // 遍历匹配正则表达式的字符串 </div><div class="line">    while (matcher.find()) &#123; </div><div class="line">        // s为匹配的字符串 </div><div class="line">        String s = matcher.group(); </div><div class="line">        System.out.println(s);  </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">//  M v L f d</div></pre></td></tr></table></figure>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><strong>ArrayList</strong></p>
<p>ArrayList类的定义为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;,RandomAccess,Cloneable,Serializable</div></pre></td></tr></table></figure>
<p>特性:</p>
<ul>
<li>可变大小的数组</li>
<li>非线程安全</li>
<li>当更多的元素加入到ArrayList时，其大小会动态的增长。每次增长的空间是其size的50%。初始容量是10.</li>
<li>允许null元素</li>
</ul>
<hr>
<p><strong>LinkedList</strong></p>
<p>LinkedList类定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<p>LinkedList有如下特性：</p>
<ul>
<li>是一个双链表</li>
<li>非线程安全</li>
<li>在添加和删除元素元素时具有比ArrayList更好的性能</li>
<li>LinkedList还实现了Queue接口（非直接实现，是通过实现Queue的子接口Deque间接实现Queue），该接口比List提供了更多方法。包括从尾部添加元素：<code>offer(E)</code>、返回第一个元素但不出队:<code>peek()</code>、返回第一个元素并出队：<code>poll()</code>等。</li>
<li>允许null元素</li>
</ul>
<p>由于LinkedList不同步,可以通过如下方式转化为同步的List</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list= Collections.synchronizedList(new LinkedList());</div></pre></td></tr></table></figure>
<hr>
<p><strong>Vector</strong></p>
<p>Vector类定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable</div></pre></td></tr></table></figure>
<p>Vector类有如下特性：</p>
<ul>
<li>Vector和ArrayList类似，但属于强同步类。</li>
<li>比ArrayList多了线程安全。</li>
<li>默认每次动态增加空间是当前大小的2倍；如果在构造函数Vector(int initialCapacity, int capacityIncrement)中指定了capacityIncrement，每次动态增加的大小为capacityIncrement</li>
<li>初始容量是10.</li>
<li>允许null元素</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>首先各个子类的继承关系</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/map.png" alt="img"></p>
<p>类的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//HashMap </div><div class="line">public class HashMap&lt;K,V&gt; </div><div class="line">    extends AbstractMap&lt;K,V&gt; </div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable&#123;&#125; </div><div class="line"> </div><div class="line">//Hashtable </div><div class="line">public class Hashtable&lt;K,V&gt; </div><div class="line">    extends Dictionary&lt;K,V&gt; </div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;&#125; </div><div class="line"> </div><div class="line">//ConcurrentHashMap </div><div class="line">public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; </div><div class="line">        implements ConcurrentMap&lt;K, V&gt;, Serializable &#123;&#125; </div><div class="line"> </div><div class="line">//TreeMap </div><div class="line">public class TreeMap&lt;K,V&gt; </div><div class="line">    extends AbstractMap&lt;K,V&gt; </div><div class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;&#125; </div><div class="line"> </div><div class="line">//LinkedHashMap </div><div class="line">public class LinkedHashMap&lt;K,V&gt; </div><div class="line">    extends HashMap&lt;K,V&gt; </div><div class="line">    implements Map&lt;K,V&gt;&#123;&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>HashMap内部实现</strong></p>
<p><code>HashMap</code>本质是数组加链表。根据<code>key</code>取得<code>hash</code>值，然后计算出数组下标，如果多个<code>key</code>对应到同一个下标，就用链表串起来。新插入的在前面。不保证映射顺序，特别是它不保证该顺序恒久不变。里面存放的是<code>Map.Entry</code>类，该类本质是个键值对。</p>
<ul>
<li><code>HashMap</code>数据结构：根据<code>key</code>的<code>hashCode</code>来计算<code>hash</code>值，只要<code>hashCode</code>相同，计算出来的<code>hash</code>值就一样。出现<code>hash</code>冲突，就采用链表的方式，将相同<code>hash</code>值的对象用链表连接。</li>
<li><code>HashMap</code>存取：<code>put</code>新元素时，首先根据<code>key</code>的<code>hashCode</code>重新计算<code>hash</code>值（二次hash），根据这个新的<code>hash</code>值得到这个元素在数组的位置（下标），如果数组已经存放其他元素，那么该位置元素以链表形式存放，新加入的放链头，最先加入的在链尾。根据Key的hashCode二次hash的算法函数hash（int h），此方法加入了高位计算，防止低位不变而高位变化时造成的<code>hash</code>冲突。函数的具体实现如下(<code>&gt;&gt;&gt;</code>表示右移1位并忽略符号位，空位以0补齐。而<code>&gt;&gt;</code>表示右移不忽略符号位，即相当于除以2)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static int hash(int h)&#123; </div><div class="line">    h ^= (h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12); </div><div class="line">    return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时得到了二次hash，二次hash的主要目的就是将高位引入计算，使得计算出来的位置值与高位也有关。将二次hash值对数组长度取模运算这样一来元素的分布就比较均匀。但是，模运算的消耗比较大。在<code>HashMap</code>中这样做：调用<code>indexFor(int h,int length)</code>方法计算该对象应该保存在<code>table</code>数组的那个索引处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h,int length)&#123; </div><div class="line">    return h &amp; (length-1); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法非常巧妙，它通过<code>h&amp;(table.length-1)</code>来得到该对象的保存位，而<code>HashMap</code>底层数组的长度总是<code>2的n次方</code>（即只有一位上是1，其他位上是0），这是<code>HashMap</code>在速度上的优化。</p>
<p><code>HashMap</code>扩容（<code>resize</code>、<code>rehash</code>）：由上面可知，每次数组扩容为原来的两倍。扩容会带来一个性能上的问题，就是每次扩容需要重新计算每个元素的位置。那么<code>HashMap</code>什么时候进行扩容呢？这个跟<code>loadFactor</code>（加载因子）有关，默认情况下<code>loadFactor</code>为<code>0.75</code>.即当<code>HashMap</code>元素超过<code>length*0.75</code>时，需要<strong>扩大一倍</strong>，然后重新计算元素在数组的位置，这是一个非常消耗性能的操作，所以，如果已经预知<code>HashMap</code>中元素个数那么预设元素个数能够有效提高<code>HashMap</code>性能。</p>
<ul>
<li><code>Fail-Fast</code>(快速失败)机制： <code>HashMap</code>不是线程安全的，因此在使用迭代器过程中，其他线程修改了Map，那么将抛出<code>ConcurrentModificationException</code>异常，这就是<code>fail-fast</code>策略。实现原理为，通过<code>modCount</code>域，<code>modCount</code>顾名思义就是修改次数，对<code>HashMap</code>内容的修改都将增加这个值，在迭代器初始化过程会将这个值赋给迭代器的<code>expectedModCount</code>，迭代过程中，判断<code>modCount</code>跟<code>expectedModCount</code>是否相等，如果不相等就表示已经有其他的线程修改了Map。</li>
</ul>
<hr>
<p><strong>ConcurrentHashMap</strong></p>
<p>在HashMap的基础上,<code>ConcurrentHashMap</code>将数据分为多个<code>segment</code>，默认<code>16</code>个，然后每次操作对一个<code>segment</code>加锁，避免多线程锁的几率，提高并发效率。</p>
<hr>
<p><strong>HashTable和HashMap</strong></p>
<ul>
<li><code>HashMap</code>父类为<code>AbstractMap</code>，方法不同步，K，V可为null，添加新的kv，若k相同，则将新的v覆盖。</li>
<li><code>HashTable</code>父类为<code>Dictionary</code>，方法同步，k，v不可为null，添加新的kv，若k相同，则将新的v覆盖。</li>
</ul>
<hr>
<p><strong>TreeMap、HashMap、LinkedHashMap的区别</strong></p>
<ul>
<li><code>TreeMap</code> 实现<code>SortMap</code>接口，能够把它保存的记录根据键排序，默认是<strong>按键值升序排序</strong>，也可以指定排序的比较器（通过构造器传入<code>Comparator</code>对象），当用<code>Iterator</code>遍历<code>TreeMap</code>时，得到的记录是排过序的。</li>
<li><code>LinkedhashMap</code>，是<code>HashMap</code>子类，保存了记录的插入顺序，在用<code>iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的，如果需要输出的顺序和输入的相同，那么<code>LinkedHashMap</code>可以实现。LRU算法里面使用到<code>LinkedHashMap</code>,之所以用这个类而不用<code>LinkedList</code>，主要是<code>LinkedHashMap</code>取值速度快，免去了<code>LinkedList</code>遍历搜索过程。</li>
</ul>
<h3 id="Collections和Arrays"><a href="#Collections和Arrays" class="headerlink" title="Collections和Arrays"></a>Collections和Arrays</h3><p>由于<code>collections</code>主要针对<code>Collection</code>对象, 先看看<code>Collection</code>子类继承结构</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/collection.png" alt="img"></p>
<hr>
<p><strong>Collections</strong></p>
<p><code>Java.util.Collections</code>是一个包装类（工具类、帮助类），主要是针对集合类操作。它包含各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，有如下功能：</p>
<ol>
<li>二分搜索算法进行查找</li>
<li>为Collection添加不定数量参数作为子元素</li>
<li>将一个List所有元素复制到另一个</li>
<li>判断两个元素是否有相同的元素:</li>
<li>获取Collection最大、最小元素</li>
<li>用于对集合中的元素进行排序</li>
<li>将线程不安全的Map、Set转为线程安全的对象</li>
<li>返回单例</li>
</ol>
<p>部分函数原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">static boolean addAll(Collection&lt;? super T&gt; c, T... elements); </div><div class="line">static int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c); </div><div class="line">static void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src); </div><div class="line">//如果没有相同的元素返回true </div><div class="line">static boolean disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2); </div><div class="line">//最大最小值 </div><div class="line">static T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp); </div><div class="line">static T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp); </div><div class="line">//逆序 </div><div class="line">static Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) </div><div class="line">//返回只包含指定对象的单例Set </div><div class="line">static Set&lt;T&gt; singleton(T o); </div><div class="line">//返回只包含指定对象的单例列表 </div><div class="line">static List&lt;T&gt; singletonList(T o); </div><div class="line">//返回只包含指定对象的单例Map </div><div class="line">static Map&lt;K,V&gt; singletonMap(K key, V value); </div><div class="line">//排序 </div><div class="line">static void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c); </div><div class="line">//交换指定位置的两个元素 </div><div class="line">static void swap(List&lt;?&gt; list, int i, int j) </div><div class="line">//将线程不安全的Collection转为线程安全的Collection </div><div class="line">static Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c); </div><div class="line">static List&lt;T&gt; synchronizedList(List&lt;T&gt; list); </div><div class="line">static Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m); </div><div class="line">static Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);</div></pre></td></tr></table></figure>
<hr>
<p><strong>Arrays</strong></p>
<p>这些方法都是静态方法。主要是针对数组操作。Arrays跟Collections很像，包含如下功能：</p>
<ul>
<li>二分搜索算法进行查找</li>
<li>将数组转List对象</li>
<li>复制数组指定范围的元素为一个新的数组</li>
<li>给数组指定范围的每个元素赋一个值，排序等等</li>
</ul>
<p>函数部分原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">//针对基本类型的查找 </div><div class="line">//如果查找的数组类型是int[],则函数如下 </div><div class="line">//其他的基本类型对应的二分搜索函数原型为把int替换指定的类型就好 </div><div class="line">static int binarySearch(int[] a, int key); </div><div class="line">//针对基本类型，在指定范围进行二分搜索 </div><div class="line">//其他基本类型类似 </div><div class="line">static int binarySearch(int[] a, int fromIndex, int toIndex, int key); </div><div class="line"> </div><div class="line">//针对类对象数组的二分搜索 </div><div class="line">static int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) </div><div class="line"> </div><div class="line">//针对一个数组，复制其元素到一个新的数组， </div><div class="line">//并将新的数组返回. </div><div class="line">//其他基本类型相似，将float替换掉即可 </div><div class="line">static float[] copyOf(float[] original, int newLength); </div><div class="line"> </div><div class="line">//复制数组指定范围的元素到一个新的数组， </div><div class="line">//并将新的数组返回 </div><div class="line">//其他基本类型类似，将byte替换即可 </div><div class="line">static byte[] copyOfRange(byte[] original, int from, int to); </div><div class="line">//复制指定范围的类对象数组 </div><div class="line">static  T[] copyOfRange(T[] original, int from, int to); </div><div class="line"> </div><div class="line">//判断两个基本类型数组里面的元素是否相等 </div><div class="line">//其他基本类型只需将char替换 </div><div class="line">static boolean equals(char[] a, char[] a2); </div><div class="line"> </div><div class="line">//判断两个类对象数组里面的元素是否相同 </div><div class="line">static boolean equals(Object[] a, Object[] a2); </div><div class="line"> </div><div class="line">//为基本类型数组里面的每一个元素赋相同的值 </div><div class="line">//其他基本类型将boolean替换 </div><div class="line">static void fill(boolean[] a, boolean val); </div><div class="line">//类数组一样 </div><div class="line">static void fill(Object[] a, Object val) </div><div class="line"> </div><div class="line">//返回hash码,基本类型替换long </div><div class="line">static int hashCode(long[] a); </div><div class="line">static int hashCode(Object[] a); </div><div class="line"> </div><div class="line">//排序,基本类型替换byte </div><div class="line">static void sort(byte[] a); </div><div class="line">static void sort(byte[] a, int fromIndex, int toIndex); </div><div class="line">//模板类型排序 </div><div class="line">static void sort(T[] a, Comparator&lt;? super T&gt; c); </div><div class="line">static void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c); </div><div class="line"> </div><div class="line">//toString，基本类型替换long </div><div class="line">static String toString(long[] a); </div><div class="line">static String toString(Object[] a);</div></pre></td></tr></table></figure>
<h3 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h3><p><strong>hashCode()方法</strong></p>
<p>因为<code>Object</code>类提供了<code>hashCode()</code>方法，因此，每个类对象都拥有<code>hashCode()</code>方法。而Object的 <code>hashCode</code>是一个<code>native</code>方法,我们就不去深究其具体的实现了。<br><code>hashCode</code>方法主要作用是为了配合散列的集合一起工作。散列集合包括<code>HashSet</code>、<code>HashMap</code>以及<code>HashTable</code>。</p>
<hr>
<p><strong>HashSet判断对象是否存在集合中</strong></p>
<p>我们知道，集合中是不允许重复元素存在的，当<code>HashSet</code>需要添加新的对象<code>obj</code>时，如何判断<code>obj</code>是否已经存在于集合中呢？</p>
<ul>
<li>调用<code>obj.hashCode()</code>，得到对应的<code>hashcode</code>值。</li>
<li>如果集合中没有存储这个<code>hashcode</code>对应的对象，则直接添加。</li>
<li>如果集合中已经存储了这个<code>hashcode</code>对应的对象，则调用equals判断是否对象相同。</li>
</ul>
<p>从上面过程可知，如果你重写<code>equals</code>方法，必须重写<code>hashCode</code>函数。因为：</p>
<p>如果只重写<code>equals</code>，根据你的规则将两个对象<code>equals</code>返回<code>true</code>，但是<code>hashCode</code>默认却不同，集合还是会添加新元素。</p>
<hr>
<p><strong>HashSet存取</strong></p>
<p><code>HashSet</code>是基于<code>HashMap</code>来实现的。<code>HashSet</code>相当于只利用<code>HashMap</code>的<code>Key</code>，而<code>value</code>使用一个 <code>static final</code>的<code>Object</code>对象标识。一次<code>HashSet</code>的存取相当于<code>HashMap</code>的一次存取，只不过<code>HashSet</code>只看重<code>Key</code>部分，不需要<code>Value</code>部分。因此，我们只需看接下来小节中的<code>HashMap</code>的put和get方法。</p>
<hr>
<p><strong>HashMap的put和get方法</strong></p>
<p>我们知道，<code>HashMap</code>里面的结构是<code>数组+链表</code>。链表里面存储的元素就是键值对<code>HashMap.Entry&lt;K,V&gt;</code>对象。在存放<code>Key-Value</code>时，过程如下：</p>
<ol>
<li>首先根据<code>key</code>的<code>hashCode</code>找到对应数组的位置</li>
<li>然后遍历该位置的链表，查找<code>key</code>是否已经存在</li>
<li>如果<code>key</code>已经存在，则直接更新<code>value</code>,并将旧的<code>value</code>作为函数返回</li>
<li>如果<code>key</code>不存在，则通过头插法，将新的键值对放入当前链表的第一个位置</li>
</ol>
<p><strong>注意，null key总是放入数组的第0个位置，因为null的哈希码为0</strong></p>
<p>put方法已经讲解完，get方法相对就比较简单了:</p>
<ol>
<li>首先根据key的hashCode找到对应数组的位置</li>
<li>然后遍历该位置的链表，查找key是否已经存在</li>
</ol>
<h3 id="return和finally执行顺序"><a href="#return和finally执行顺序" class="headerlink" title="return和finally执行顺序"></a>return和finally执行顺序</h3><p><strong>结论</strong></p>
<ol>
<li>不管有木有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>如果语句上的执行顺序是先return后finally，会先执行return后面的语句，这个语句的结果是最终的返回值result。result会被保存下来，再执行finally，待finally执行完成后，再结束函数，将result的值返回。这种情形的finally对变量的值修改不会影响最终的函数返回。</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li>
</ol>
<h3 id="Override与Overload区别"><a href="#Override与Overload区别" class="headerlink" title="Override与Overload区别"></a>Override与Overload区别</h3><p><strong>Override(重写、覆盖)</strong></p>
<p><code>Override</code>是子类对父类的允许访问的方法的实现过程进行重新编写，<code>Override</code>一个函数需要注意以下几点：</p>
<ul>
<li>返回值、函数名、形参都不能改变。即外壳不变，重写内在实现。</li>
<li>子类方法不能缩小父类方法的访问权限（反过来是可以的）</li>
<li><code>final</code>的方法不能被重写</li>
<li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明</li>
<li>子类和父类在同一个包中，子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li>
<li>子类和父类不在同一个包中，子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。</li>
<li>重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写</li>
<li>如果不能继承一个方法，则不能重写这个方法( 父类的private方法)。</li>
</ul>
<p>解释一下强制性异常和非强制性异常：</p>
<ul>
<li>除了<code>RuntimeException</code>外，都是强制性异常</li>
<li>所谓强制性异常就是在编写程序的过程中必需在抛出异常的部分<code>try catch</code> 或者向上<code>throws</code>异常</li>
<li>所谓非强制性异常就和上面相反了。不过你当然也可以<code>try catch</code>或者<code>thows</code>，只不过这不是强制性的。</li>
</ul>
<hr>
<p><strong>Overload(重载)</strong></p>
<p>重载是在同一个类里面，<strong>方法名字相同，而参数不同，返回类型可以相同也可以不同的多个方法</strong>。每个重载的方法都必须有一个独一无二的参数类型列表。</p>
<p>重载规则如下：</p>
<ul>
<li>被重载的方法必须改变参数列表；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
</ul>
<h2 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote>
<p>所谓CAS(Compare And Swap) 即比较并交换</p>
</blockquote>
<p>在<code>Intel</code>处理器中，比较并交换通过指令的 <code>cmpxchg</code> 系列实现。CAS有三个操作数：</p>
<ul>
<li>内存位置（V）</li>
<li>预期原值（A）</li>
<li>新值(B)</li>
</ul>
<p>如果内存位置<code>V</code>的值与预期<code>A</code>原值相匹配，那么处理器会自动将该位置值更新为新值<code>B</code>。否则，处理器不做任何操作。</p>
<p>无论哪种情况，它都会在 <code>CAS</code> 指令之前返回该位置的值。（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值。）CAS有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
<p><strong>CAS应用</strong></p>
<p>比较典型的应用就是<code>AtomicInteger</code>,可以看到，对<code>i++</code>和<code>i--</code>，都是通过<code>CAS</code>，并且通过一个死循环，<code>compareAndSet</code>函数内部就是通过<code>jni</code>操作<code>CAS</code>指令。直到<code>CAS</code>操作成功跳出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private volatile int value; </div><div class="line">    /** </div><div class="line">     * Gets the current value. </div><div class="line">     * </div><div class="line">     * @return the current value </div><div class="line">     */ </div><div class="line">    public final int get() &#123; </div><div class="line">        return value; </div><div class="line">    &#125; </div><div class="line">    /** </div><div class="line">     * Atomically increments by one the current value. </div><div class="line">     * </div><div class="line">     * @return the previous value </div><div class="line">     */ </div><div class="line">    public final int getAndIncrement() &#123; </div><div class="line">        for (;;) &#123; </div><div class="line">            int current = get(); </div><div class="line">            int next = current + 1; </div><div class="line">            if (compareAndSet(current, next)) </div><div class="line">                return current; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    /** </div><div class="line">     * Atomically decrements by one the current value. </div><div class="line">     * </div><div class="line">     * @return the previous value </div><div class="line">     */ </div><div class="line">    public final int getAndDecrement() &#123; </div><div class="line">        for (;;) &#123; </div><div class="line">            int current = get(); </div><div class="line">            int next = current - 1; </div><div class="line">            if (compareAndSet(current, next)) </div><div class="line">                return current; </div><div class="line">        &#125; </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="GC收集器"><a href="#GC收集器" class="headerlink" title="GC收集器"></a>GC收集器</h3><ul>
<li>Serial收集器</li>
<li>ParNew收集器</li>
<li>Parallel Scavenge收集器</li>
<li>Serial Old收集器</li>
<li>Parallel Old收集器</li>
<li>CMS收集器</li>
<li>G1收集器</li>
</ul>
<hr>
<p><strong>Serial收集器</strong></p>
<p>从名字可以看出，这个收集器是一个单线程的收集器。但是，它的“单线程”的意义并不仅仅说明它只会使用一个<code>CPU</code>或一条收集线程去完成垃圾收集工作，更重要的是，<strong>在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</strong>。</p>
<p><code>&quot;Stop The World&quot;</code>是在用户不可见的情况下，把用户正常工作的线程全部停掉，这对很多应用是难以接受的，试想一下，要是你的计算机每运行1小时就暂停响应5分钟，你会是什么样的心情！</p>
<p>运行示意图:</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/GC_Serial.png" alt="img"></p>
<p>对于<code>&quot;Stop The World&quot;</code>给用户带来的不良体验，虚拟机设计者表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间时候，肯定也会让你老老实实地在椅子上或房间外呆着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”</p>
<p>从<code>JDK1.3</code>开始，<code>HotSpot</code>虚拟机开发团队为消除或减少工作线程因内存回收而导致停顿的努力一直进行着。从<code>Serial</code>收集器到<code>Parallel</code>收集器，再到<code>Concurrent Mark Sweep（CMS）</code>乃至GC收集器的最前沿成功<code>Garbage First（G1）</code>收集器，用户线程停顿时间不短缩短，但是仍然无法完全消除！</p>
<p><strong>应用场景</strong></p>
<p>虽然<code>Serial收集器</code>看起来“老而无用、食之无味弃之可惜”，但实际上到目前为止，它依然是虚拟机运行在<code>Client模式下</code>的默认新生代收集器。它有着优于其他收集器的地方：简单高效（与其他收集器的单线程比）。</p>
<p>对于限定单个CPU的环境来说，<code>Serial收集器</code>由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</p>
<p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不是频繁发生，这点停顿还是可以接受的，所以Serial收集器对应运行<code>Client模式</code>下的虚拟机来说是一个很好的选择。</p>
<hr>
<p><strong>ParNew 收集器</strong></p>
<p><strong>运行过程:</strong></p>
<p><code>ParNew收集器</code>其实就是<code>Serial收集器</code>的<strong>多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SruvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在现实上，这两种收集器也共用了相当多代码。</p>
<p><code>ParNew收集器</code>工作示意图:</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/GC_ParNew.png" alt="img"></p>
<p><strong>应用场景</strong></p>
<p><code>ParNew收集器</code>除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在<code>Server模式下</code>的虚拟机中首选的新生代收集器。其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能<code>与CMS收集器</code>配合工作。</p>
<p><code>ParNew收集器</code>在单CPU的环境中绝对不会有比<code>Serial收集器</code>更好的效果。甚至由于存在线程交互的开销，该收集器在通过超线程技术实现两个CPU环境中都不能百分百地保证可以超越<code>Serial收集器</code>。当然，随着CPU数量增加，它对于GC时，系统资源的有效利用还是很有好处。它默认开启的收集线程数与CPU数量相同，在CPU非常多（例如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）环境下，可以使用<code>-XX:ParalleGCThreads</code>参数来限制垃圾收集的线程数。</p>
<hr>
<p><strong>Parallel Scavenge收集器</strong></p>
<p><code>Parallel Scavenge收集器</code>是一个新生代收集器，它也是使用<strong>复制算法</strong>的收集器，又是并行的多线程收集器….看上去和ParNew都一样，那它有啥特别的地方呢？</p>
<p><code>Parallel Scavenge收集器</code>的特点是它的关注点与其他收集器不同，<code>CMS</code>等收集器的关注点是<strong>尽可能第缩短垃圾收集时用户线程停顿时间</strong>，而<code>Parallel Scavenge收集器</code>的目标则是<strong>达到一个可控制的吞吐量</strong>。所谓的吞吐量就是：</p>
<blockquote>
<p>CPU用于运行用户代码的时间与CPU总消耗时间的比值，即：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
</blockquote>
<p>虚拟机总共运行<code>100分钟</code>，其中垃圾收集消耗掉<code>1分钟</code>，那吞吐量就是<code>99%</code>。</p>
<hr>
<p><strong>Serial Old收集器</strong></p>
<p><code>Serial Old</code>是<code>Serial收集器</code>的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给<code>Client模式下的虚拟机</code>使用。如果在Server模式下，它主要还有两大用途：</p>
<ul>
<li>在JDK1.5以及之前版本中与<code>Parallel Scavenge收集器</code>搭配使用</li>
<li>作为CMS收集器的后备预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用</li>
</ul>
<p>运行示意图和<code>Serial收集器类似</code></p>
<hr>
<p><strong>Parallel Old收集器</strong></p>
<p><code>Parallel Old收集器</code>是<code>Parallel Scavenge收集器</code>的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK1.6中才开始提供。</p>
<p>Parallel Old收集器运行示意图如下：</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/ParallelOld.png" alt="img"></p>
<hr>
<p><strong>CMS收集器</strong></p>
<p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目的的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统服务器上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户最好的体验。<code>CMS收集器</code>就非常符合这类应用的需求。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出，<code>CMS收集器</code>是基于“标记-清除”算法实现的，它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>其中，初始标记、重新标记着两个步骤仍然需要<code>“Stop The World”</code>。初始标记仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快。并发标记阶段就是进行<code>GC Roots Tracing</code>的过程。而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记稍长一些，但远比并发标记时间短。</p>
<p>由于整个过程中耗时最长的<strong>并发标记和并发清除过程</strong>收集器线程都可以与用户线程一起工作，所有总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。CMS运作步骤如下：</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/CMS.png" alt="img"></p>
<p>CMS是一款优秀的收集器，它的主要优点从名字上体现出来：并发收集、低停顿。但是CMS还远达不到完美程度，它有以下3个明显的缺点：</p>
<ul>
<li><code>CMS收集器</code>对<code>CPU</code>资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</li>
<li><code>CMS收集器</code>无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致另一次<code>Full GC</code>产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。因此，CMS不能像其他收集器那样等到老年代几乎完全被填满再进行收集，CMS需要预留一部分空间。</li>
<li>由于CMS基于<code>“标记-清除”</code>算法，意味着收集结束时会有大量空间碎片产生。</li>
</ul>
<hr>
<p><strong>G1收集器</strong></p>
<p><code>G1（Garbage First）收集器</code>是当今收集器技术发展的最前沿成果之一。G1是面向服务端应用的垃圾收集器，与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li>并行与并发：充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器需要停顿Java线程执行的GC动作，G1仍然能通过并发方式让Java程序继续执行。</li>
<li>分代收集：与其他收集器一样，分代概念在G1中依然得以保存。</li>
<li>空间整合：与CMS的“标记-清理”算法不同，G1从整体上看是基于“标记-整理”算法实现的收集器，从局部上看是基于“复制”算法实现的，这两种算法意味着G1运作期间不会产生内存空间碎片。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得从超出N毫秒，这几乎已经是实时Java的垃圾收集器的特征了。</li>
</ul>
<p>G1运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>运行示意图如下：</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/GC_G1.png" alt="img"></p>
<h3 id="内存模型和分区"><a href="#内存模型和分区" class="headerlink" title="内存模型和分区"></a>内存模型和分区</h3><p><strong>逻辑内存模型</strong></p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/memorymodel.png" alt="img"></p>
<hr>
<p><strong>内存分区</strong></p>
<ul>
<li><code>程序计数器</code>: 较小的内存空间。线程私有。可以看成是<strong>当前线程所执行的字节码的行号指示器</strong>。通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。此内存区域<strong>是唯一一个在JVM规范中没有规定任何OutofMemoryError情况的区域</strong>。</li>
<li><code>Java虚拟机栈</code>: 线程私有，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成，就对应一个栈帧在虚拟机栈中的<strong>入栈</strong>和到<strong>出栈</strong>的过程。会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>.</li>
<li><code>本地方法栈</code>: 功能与虚拟机栈类似。区别在于本地方法栈为<code>native</code>方法服务。</li>
<li><code>Java堆</code>: <code>JVM</code>所管理的内存中最大的一块。所有线程所共享。可分为：<code>新生代</code>和<code>老年代</code>。新生代可再细分为：<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>。有<code>OutOfMemoryError</code>异常。</li>
<li><code>方法区</code>: 跟<code>Java</code>堆一样，是各个线程共享区域。存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池是方法区一部分。</li>
<li><code>直接内存</code>: 不属于虚拟机运行时数据区的一部分。<code>NIO</code>引入了一种<strong>基于通道与缓冲区的IO方式</strong>。他可以使用<code>Native</code>函数库直接分配堆外内存，然后通过一个存储在<code>Java</code>堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。避免<code>Java</code>堆和<code>Native</code>堆之间来回复制数据，在某种场景中显著提高性能。由于不在堆中分配，因此不受到堆大小限制。但既然是内存总有会被用完时候，因此会抛出<code>OutOfMemoryError</code>。</li>
</ul>
<h3 id="新生代老年代"><a href="#新生代老年代" class="headerlink" title="新生代老年代"></a>新生代老年代</h3><p><strong>新生代于老年代占空间比例</strong></p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/newold.png" alt="img"></p>
<p>堆被划分为<strong>新生代</strong>和<strong>老年代</strong>。默认比例为<code>1:2</code>（可以通过<code>–XX:NewRatio</code> 设定）。新生代又分为<code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code>。这样划分的目的是为了使 ˚能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<p>新生代分为的三个部分, 默认比例为<code>Eden:from:to=8:1:1</code>（可以通过参数<code>–XX:SurvivorRatio</code> 来设定，–<code>XX:SurvivorRatio =8</code>表示<code>Eden</code>与一个<code>Survivor</code>空间比例为8:1）</p>
<hr>
<p><strong>存活对象的拷贝</strong></p>
<p>一般新建的对象会分配到<code>Eden</code>区。这些对象经过第一次<code>Minor GC</code>后，如果仍然存活，将会被移到<code>Survivor</code>区。在<code>Survivor</code>每熬过一轮<code>Minor GC</code>年龄就增加1。</p>
<p>当年龄达到一定程度时(年龄阈值，默认为<code>15</code>，可以通过<code>-XX:MaxTenuringThreshold</code>来设置)，就会被移动到老年代。</p>
<p><code>from</code>和<code>to</code>之间会经常互换角色，<code>from</code>变成<code>to</code>，<code>to</code>变成<code>from</code>。每次<code>GC</code>时，把<code>Eden</code>存活的对象和<code>From Survivor</code>中存活且没超过年龄阈值的对象复制到<code>To Survivor</code>中，<code>From Survivor</code>清空，变成<code>To Survivor</code>。</p>
<p><strong>Minor GC与Full GC</strong></p>
<p><code>Java</code>中的堆也是<code>GC</code>收集垃圾的主要区域。GC分为两种：</p>
<ul>
<li>Minor GC</li>
<li>Full GC</li>
</ul>
<p><code>Minor GC</code>是发生在<strong>新生代中</strong>的垃圾收集动作，所采用的是<strong>复制算法</strong>，因为<code>Minor GC</code>比较频繁，因此一般回收速度较快。<code>Full GC</code> 是发生在<strong>老年代</strong>的垃圾收集动作，所采用的是<strong>标记-清除算法</strong>，速度比Minor GC慢10倍以上。</p>
<p>大对象直接进入<strong>老年代</strong>。比如很长的字符串以及数组。通过设置<code>-XX：PretenureSizeThreshold</code>，令大于这个值得对象直接在老年代分配。这样做是为了避免在<code>Eden</code>和两个<code>Survivor</code>之间发生大量的内存复制。</p>
<blockquote>
<p>什么时候发生 Minor GC？什么时候发生Full GC？<br>当新生代Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。<br>老年代空间不足时Full GC</p>
</blockquote>
<h3 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h3><p>判断哪些对象是存活的，哪些对象消亡的，典型的有两种方法：</p>
<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<hr>
<p><strong>引用计数</strong></p>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器+1，引用失效计数器-1；<strong>任何时候计数器为0</strong>的对象就是不可能再被使用。这有个问题是，两个对象相互引用导致两个对象都无法被回收。</p>
<hr>
<p><strong>可达性分析</strong></p>
<p>通过一系列的<code>GC Roots</code>对象作为起点，从这些节点开始向下搜索。搜索所走过的路称为引用链。当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象不可用。</p>
<p>可作为<code>GC Root</code>的对象有：</p>
<ul>
<li>虚拟机栈（栈帧的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用对象</li>
</ul>
<p>即使在可达性分析中不可达的对象，也并非是“非死不可”，这时候他们暂时处于“缓刑”阶段。要真正宣告一个对象死亡，需要经历两个阶段：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li>
<li>如果这个对象被判断为有必要执行<code>finalize()</code>方法。那么这个对象会被放到一个<code>F-Queue</code>队列中，并在稍后由一个虚拟机自动建立的、优先级低的<code>Finalizer线程</code>去执行它，这里的“执行”是指虚拟机会触发这个方法，但并不承诺等待它运行结束。这是为了防止<code>finalize()</code>方法执行缓慢使得<code>F-Queue</code>队列其他对象永久等待。</li>
</ol>
<p>因此，对象可以在<code>finalize()</code>方法里把自己赋值给一个变量，以达到“自救”的目的，但是这样的“自救”只能用一次（虚拟机只会调用一次<code>finalize()</code>方法）。</p>
<h3 id="GC的三种收集方法"><a href="#GC的三种收集方法" class="headerlink" title="GC的三种收集方法"></a>GC的三种收集方法</h3><p><strong>1.标记-清除</strong></p>
<p>分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，他的标记过程在上面几行中已经提到过。</p>
<p>不足：</p>
<ul>
<li>标记和清除两个过程效率不高</li>
<li>标记清除后产生大量不连续的内存碎片。</li>
<li>该算法主要用在老年代区域。</li>
</ul>
<hr>
<p><strong>2.复制算法</strong></p>
<p>将内存分为两部分，每次使用其中一块，当这块内存用完，就将还存活的对象复制到另一块上面。</p>
<p>不足：</p>
<ul>
<li>浪费一半内存</li>
</ul>
<p>通常用在新生代区域中，有个改进的方法是将新生代分为Eden、From Survivor、To Survivor。</p>
<hr>
<p><strong>3.标记-整理</strong></p>
<p>标记过程和标记清除一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动。</p>
<p>主要用在老年代区域。</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类加载的5个过程分为:</p>
<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
</ul>
<hr>
<p><strong>1.加载</strong></p>
<ol>
<li>通过类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p><strong>2.验证</strong></p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证。</li>
</ol>
<p><strong>3.准备</strong></p>
<p>为类变量（<code>static</code>）分配内存并设置类变量的初始值。</p>
<blockquote>
<p>注意，实例变量并不在这个阶段分配内存。为类变量设置初始值并不是定义的值。<br>比如static int value = 123;那么变量value在准备阶段过后初始值为0，而不是123。值123是在<code>&lt;clinit&gt;()</code>方法中赋予。</p>
</blockquote>
<p><strong>4.解析</strong></p>
<p>将常量池内的符号引用转为直接的引用.</p>
<p><strong>5.初始化</strong></p>
<p>按照<code>static块</code>和<code>static变量</code>在文件中的出现顺序，合并到<code>&lt;clinit&gt;()</code>方法中。实例变量由<code>&lt;init&gt;()</code>函数赋值。</p>
<h3 id="静态分派-动态分派"><a href="#静态分派-动态分派" class="headerlink" title="静态分派 动态分派"></a>静态分派 动态分派</h3><p><strong>静态分派</strong></p>
<p><strong>概念:</strong>静态分派与重载有关，虚拟机在重载时是通过参数的静态类型，而不是运行时的实际类型作为判定依据的；静态类型在编译期是可知的；</p>
<p>看如下例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line">    static abstract class Human &#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Man extends Human &#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Woman extends Human &#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public void sayHello(Human guy) &#123; </div><div class="line">        System.out.println(&quot;hello,guy!&quot;); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public void sayHello(Man guy) &#123; </div><div class="line">        System.out.println(&quot;hello gentleman!&quot;); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public void sayHello(Woman guy) &#123; </div><div class="line">        System.out.println(&quot;hello lady!&quot;); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123; </div><div class="line">        Human man = new Man(); </div><div class="line">        Human woman = new Woman(); </div><div class="line"> </div><div class="line">        Test test = new Test(); </div><div class="line">        test.sayHello(man); </div><div class="line">        test.sayHello(woman); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello,guy! </div><div class="line">hello,guy!</div></pre></td></tr></table></figure>
<p>稍微有Java开发经验的人都能得到正确的答案。但是为什么会选择执行参数类型为<code>Human</code>的重载呢？在解决这个问题之前，我们先按如下代码定义两个重要概念：</p>
<p><code>Human man = new Man();</code></p>
<p>上面代码中，<code>Human</code>称为<strong>变量的静态类型</strong>；后面的<code>Man</code>则称为<strong>变量的实际类型</strong>。<br>静态类型和实际类型在程序中都可以发生一些变化，区别是：</p>
<ul>
<li>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译期可知的</li>
<li>实际类型变化的结果在运行期才能确定，编译器在编译程序时并不知道一个对象的实际类型是什么。例如下面代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//实际类型变化 </div><div class="line">Human man=new Man(); </div><div class="line">man=new Woman(); </div><div class="line"> </div><div class="line">//静态类型变化 </div><div class="line">test.sayHello((Man)man); </div><div class="line">test.sayHello((Woman) man)</div></pre></td></tr></table></figure>
<p>使用哪个重载版本，完全取决于<strong>传入参数的数量</strong>和<strong>数据类型</strong>。代码中刻意定义两个静态类型相同，但实际类型不同的变量，但虚拟机在重载时，是通过参数的<strong>静态类型</strong>而不是<strong>实际类型</strong>作为判断依据。并且静态类型在编译期是可知的，因此，在编译阶段，<code>javac</code>编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了<code>sayHello(Human)</code>作为调用目标，并把这个方法的符号引用写到<code>man()</code>方法里面两条<code>invokevirtual</code>指令参数中。</p>
<blockquote>
<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用就是方法重载。</p>
</blockquote>
<p><strong>重载方法的匹配优先级</strong></p>
<p><strong>基本类型中</strong>，以<code>char</code>为例，按照如下优先级：</p>
<p><code>char&gt;int&gt;long&gt;float&gt;double&gt;Character&gt;Serializable&gt;Object&gt;...</code>其中…为变长参数，</p>
<p>注意：<code>char</code>到<code>byte</code>或<code>short</code>之间的转换是不安全的</p>
<p><strong>引用类型中</strong>，需要根据继承关系进行匹配，注意只跟其编译时类型即静态类型相关。</p>
<hr>
<p><strong>动态分派</strong></p>
<p>动态分派与<code>重写(Override)</code>相关。同样，看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line">    static abstract class Human &#123; </div><div class="line">        protected abstract void sayHello(); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Man extends Human &#123; </div><div class="line">        @Override </div><div class="line">        protected void sayHello() &#123; </div><div class="line">            System.out.println(&quot;man say hello&quot;); </div><div class="line"> </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Woman extends Human &#123; </div><div class="line">        @Override </div><div class="line">        protected void sayHello() &#123; </div><div class="line">            System.out.println(&quot;woman say hello&quot;); </div><div class="line"> </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123; </div><div class="line">        Human man = new Man(); </div><div class="line">        Human woman = new Woman(); </div><div class="line"> </div><div class="line">        man.sayHello(); </div><div class="line">        woman.sayHello(); </div><div class="line"> </div><div class="line">        man = new Woman(); </div><div class="line">        man.sayHello(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">man say hello </div><div class="line">woman say hello </div><div class="line">woman say hello</div></pre></td></tr></table></figure>
<p>代码很简单，基本都能回答正确。但是现在问题是，虚拟机是如何知道调用哪个方法？</p>
<p>显然这里不能再根据静态类型决定，因为静态类型同样都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时执行了不同的行为，并且变量<code>man</code>在两次调用中执行了不同的方法。</p>
<p>导致这个现象的原因很明显，是这两个变量的<strong>实际类型</strong>不同，java虚拟机是如何根据实际类型来分派方法执行版本呢？</p>
<p>看一下这两句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Human man=new Man(); </div><div class="line">Human woman=new Woman();</div></pre></td></tr></table></figure>
<p>这两个对象是即将要执行sayHello()方法的所有者，称为接受者。</p>
<p>由于<code>invokevirtual</code>指令执行第一步就是在运行期间确定接受者的实际类型，所以两次调用中的<code>invokevirtual</code>指令<strong>把常量池中类方法符号引用解析到不同的直接引用上</strong>，这个过程就是Java语言中方法重写的本质。这种运行期<strong>根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名空间。简单说：</p>
<ul>
<li>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</li>
<li>否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要他们的类加载器不同，那这两个类就必定不等。</li>
</ul>
<p>这里指的“相等”，包括代表<code>Class</code>对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果，而包括使用<code>instanceof</code>关键字做对象所属关系判定等情况。</p>
<p>如果没有注意到类加载器的影响，在某些情况下，可能会产生具有迷惑性的结果，看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line">    static ClassLoader myLoader = new ClassLoader() &#123; </div><div class="line">        @Override </div><div class="line">        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; </div><div class="line"> </div><div class="line">            if (!name.equals(&quot;com.szysky.Test&quot;)) </div><div class="line">                return super.loadClass(name); </div><div class="line"> </div><div class="line">            try &#123; </div><div class="line">                String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) </div><div class="line">                        + &quot;.class&quot;; </div><div class="line"> </div><div class="line">                InputStream is = getClass().getResourceAsStream(fileName); </div><div class="line">                if (is == null) &#123; </div><div class="line">                    return super.loadClass(fileName); </div><div class="line">                &#125; </div><div class="line">                byte[] b = new byte[is.available()]; </div><div class="line">                is.read(b); </div><div class="line">                return defineClass(name, b, 0, b.length); </div><div class="line"> </div><div class="line">            &#125; catch (IOException e) &#123; </div><div class="line">                throw new ClassNotFoundException(name); </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125;; </div><div class="line"> </div><div class="line">    public static void main(String[] args) throws Exception &#123; </div><div class="line"> </div><div class="line">        Object obj = myLoader.loadClass(&quot;com.szysky.Test&quot;); </div><div class="line">        System.out.println(obj); </div><div class="line">        System.out.println(obj instanceof com.szysky.Test); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class com.szysky.Test </div><div class="line">false</div></pre></td></tr></table></figure>
<p>从第二句发现，这个对象与类<code>com.szysky.Test</code>做所属类型检查时返回了false，这是因为虚拟机中存在了两个Test类，一个是由系统应用程序类加载器加载的，另一个是由我们自定义的类加载器加载，虽然都是来自同一个class文件，但依然是两个独立的类，对象所属类型检查结果自然为false。</p>
<hr>
<p><strong>自定义类加载器</strong></p>
<p>首先，定义一个类加载器MyClassLoader.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class MyClassLoader extends ClassLoader &#123; </div><div class="line">    // 类加载器的名称 </div><div class="line">    private String name; </div><div class="line">    // 类存放的路径 </div><div class="line">    private String classpath = &quot;E:/&quot;; </div><div class="line"> </div><div class="line">    MyClassLoader(String name) &#123; </div><div class="line">        this.name = name; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    MyClassLoader(ClassLoader parent, String name) &#123; </div><div class="line">        super(parent); </div><div class="line">        this.name = name; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">    @Override </div><div class="line">    public Class&lt;?&gt; findClass(String name) &#123;  </div><div class="line">        byte[] data = loadClassData(name); </div><div class="line">        return this.defineClass(name, data, 0, data.length); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public byte[] loadClassData(String name) &#123; </div><div class="line">        try &#123; </div><div class="line">            name = name.replace(&quot;.&quot;, &quot;//&quot;); </div><div class="line">            System.out.println(name); </div><div class="line">            FileInputStream is = new FileInputStream(new File(classpath + name </div><div class="line">                    + &quot;.class&quot;)); </div><div class="line">            byte[] data = new byte[is.available()]; </div><div class="line">            is.read(data); </div><div class="line">            is.close(); </div><div class="line">            return data; </div><div class="line"> </div><div class="line">        &#125; catch (Exception e) &#123; </div><div class="line">            e.printStackTrace(); </div><div class="line">        &#125; </div><div class="line">        return null; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义待加载的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TestObject &#123; </div><div class="line">    public void print() &#123; </div><div class="line">        System.out.println(&quot;hello ClassLoader&quot;); </div><div class="line"> </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line"> </div><div class="line">    public static void main(String[] args) throws InstantiationException, </div><div class="line">            IllegalAccessException, ClassNotFoundException &#123; </div><div class="line">        // 新建一个类加载器 </div><div class="line">        MyClassLoader cl = new MyClassLoader(&quot;myClassLoader&quot;); </div><div class="line">        // 加载类，得到Class对象 </div><div class="line">        Class&lt;?&gt; clazz = cl.loadClass(&quot;com.szysky.TestObject&quot;); </div><div class="line">        // 得到类的实例 </div><div class="line">        TestObject test= (TestObject) clazz.newInstance(); </div><div class="line">        test.print(); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以正常输出语句.</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从虚拟机的角度来讲，只存在<strong>两种不同的类加载器</strong></p>
<ul>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）。使用C++语言实现（针对HotSpot虚拟机而言），是虚拟机自身的一部分。</li>
<li>所有其他的类加载器。使用Java语言实现，独立于虚拟机外部，并且全部继承自抽象类<code>java.lang.ClassLoader</code></li>
</ul>
<p>从Java程序员角度来看，类加载器还可以划分的更细致一点，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p>
<ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器</li>
</ul>
<hr>
<p><strong>启动类加载器</strong></p>
<p>这个类加载器将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定路径中的，并且是虚拟机识别的（仅按文件名识别，如：<code>rt.jar</code>，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如<code>java.lang.ClassLoader.getClassLoader()</code>方法所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@CallerSensitive </div><div class="line">public ClassLoader getClassLoader() &#123; </div><div class="line">    ClassLoader cl = getClassLoader0(); </div><div class="line">    if (cl == null) </div><div class="line">        return null; </div><div class="line">    SecurityManager sm = System.getSecurityManager(); </div><div class="line">    if (sm != null) &#123; </div><div class="line">        ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass()); </div><div class="line">    &#125; </div><div class="line">    return cl; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>扩展类加载器(Extension ClassLoader)</strong></p>
<p>这个类加载器由<code>sum.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<p><strong>应用程序类加载器（Application ClassLoader</strong></p>
<p>这个类加载器由<code>sum.misc.Launcher$AppClassLoader</code>实现。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值。所以，一般也称它为系统类加载器。它负责加载用户类路径<code>（ClassPath）</code>上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<hr>
<p><strong>双亲委派模型</strong></p>
<p>如下图所示，这种类加载器之间的层次关系，称为类加载器的双亲委派模型。</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/classLoad.png" alt="img"></p>
<p>双亲委派模型要求：</p>
<blockquote>
<p>除了顶层启动类加载器以外，其余的类加载器都应当有自己的父类加载器。</p>
</blockquote>
<p>这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用<strong>组合关系来复用父加载器的代码</strong>。它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p><strong>双亲委派模型工作过程</strong></p>
<p>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是：</p>
<blockquote>
<p>Java类随着它的类加载器一起具备了一种带优先级的层次关系</p>
</blockquote>
<p>例如：类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器进行加载，因此<code>Object</code>类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为<code>java.lang.Object</code>的类，并放在<code>ClassPath</code>中，那系统中将出现多个不同的<code>Object</code>类，Java类型体系中最基础的行为也就无法保证，应用程序也将变得一片混乱。</p>
<p>实现双亲委派模型的代码都集中在<code>java.lang.ClassLoader的loadClass()</code>方法中，逻辑清晰易懂：</p>
<ul>
<li>先检查是否已经被加载过，若没有加载，则调用父加载器的loadClass()方法</li>
<li>若如加载器为空，则默认使用启动类加载器作为父加载器</li>
<li>如果父加载失败，抛出ClassNotFoundException异常之后，再调用自己的findClass()方法进行加载</li>
</ul>
<p>以下是<code>ClassLoader</code>的<code>loadClass()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) </div><div class="line">        throws ClassNotFoundException &#123; </div><div class="line">    Class&lt;?&gt; c = findLoadedClass(name); </div><div class="line">    if (c == null) &#123; </div><div class="line">        try &#123; </div><div class="line"> </div><div class="line">            if (parent != null) &#123; </div><div class="line">                c = parent.loadClass(name, false); </div><div class="line">            &#125;else&#123; </div><div class="line">                c=findBootstrapClassOrNull(name); </div><div class="line">            &#125; </div><div class="line">        &#125; catch (ClassNotFoundException e) &#123; </div><div class="line">            //如果父类加载器抛出ClassNotFoundException， </div><div class="line">            //说明父类加载器无法完成加载请求 </div><div class="line">        &#125; </div><div class="line">        if(c==null)&#123; </div><div class="line">            //在父类加载器无法加载的时候 </div><div class="line">            //再调用本身的findClass方法进行类加载 </div><div class="line">            c=findClass(name); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    if(resolve)&#123; </div><div class="line">        resolveClass(c); </div><div class="line">    &#125; </div><div class="line">    return c; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象创建-内存分布-访问定位"><a href="#对象创建-内存分布-访问定位" class="headerlink" title="对象创建 内存分布 访问定位"></a>对象创建 内存分布 访问定位</h3><p>对象在JVM中是如何创建、如何布局以及如何访问的。讨论这个问题需要限定在具体的虚拟机和集中在某一个内存区域上才有意义。我们这个所说的是<strong>Sun的HotSpot虚拟机的Java堆内存区域</strong>，深入探讨HotSpot虚拟机在Java堆中对象的分配、布局和访问全过程。</p>
<hr>
<p><strong>对象的创建</strong></p>
<p>在语言层面上，创建对象（例如克隆、反序列化）通常仅仅是一个<code>new</code>关键字而已，而在虚拟机中，对象（文中探讨的对象限于普通对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</p>
<ol>
<li><p><code>new指令开始:</code> 虚拟机遇到一个new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，需要先执行相应的类加载过程。参考类加载的五个过程。</p>
</li>
<li><p><code>为对象分配内存:</code> 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（下一节介绍如何完全确定）。<strong>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来</strong></p>
<ul>
<li><p><code>划分空间:</code>假设<code>Java</code>堆中内存是绝对规整的，所有用到的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为<code>“指针碰撞”</code>。如果Java堆中的内存<strong>并不是规整的</strong>，已使用的内存和空闲的内存相互交错，那就<strong>没有办法简单地进行指针碰撞了</strong>，此时：虚拟机就必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<code>“空闲列表”</code>。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用<code>Serial</code>、<code>ParNew</code>等带<code>Compact</code>过程的收集器时，系统采用的分配算法是指针碰撞，而使用<code>CMS</code>这种基于<code>Mark_sweep</code>算法的收集器时，通常采用空闲列表。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">划分的线程安全:</div></pre></td></tr></table></figure>
<p>除如何划分可用空间外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的操作，即使是仅仅修改一个指针所指向的位置，在并发情况下是线程不安全的，可能出现正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理——实际上虚拟机采用<code>CAS</code>配上失败重试的方式保证更新操作的原子性；</li>
<li>把内存分配动作按照线程划分在不同的内存空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer ，TLAB）。哪个线程要分配内存，就在哪个线程的<code>TLAB</code>上分配，只有<code>TLAB</code>用完并分配新的<code>TLAB</code>时才需要同步锁。虚拟机是否使用<code>TLAB</code>，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>内存空间初始化为零值:</code>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用<code>TLAB</code>，这一工作过程也可以提前至<code>TLAB</code>分配时进行。</p>
<ul>
<li>这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型对应的零值。</li>
<li>接下来，虚拟机要对对象进行必要的设置，例如：这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。上面工作都完成后，从虚拟机的角度来看，一个新的对象已经诞生了，但从Java程序来说，对象创建才刚刚开始，所有的字段都还为零，需要进行一些初始化操作。</li>
</ul>
</li>
</ol>
<p>小结: 对象的创建过程如下:</p>
<ul>
<li>虚拟机首先需要进行类加载检查</li>
<li>检查通过之后，根据类加载完成后确定的内存大小，为对象分配内存</li>
<li>接着，需要对分配到的内存空间都初始化为零值</li>
<li>然后，虚拟机要对对象设置一些基本信息，如对象是那个类的实例、对象的哈希码、对象的GC分代年龄信息、如何才能找到类的元数据信息等，到这里虚拟机创建对象的工作已经完成</li>
<li>最后，从程序的角度，我们还需要对对象进行初始化操作。</li>
</ul>
<hr>
<p><strong>对象的内存布局</strong></p>
<p>在<code>HotSpot</code>虚拟机中，对象在内存中存储的局部可以分为3块区域：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<blockquote>
<p><code>HotSpot</code>虚拟机的对象头包括两部分信息</p>
</blockquote>
<ul>
<li>用于存储对象自身的运行时数据<ul>
<li>哈希码（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳<ul>
<li>这部分数据长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为<code>“Mark Word”</code>。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构能够记录的限度。但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计成为一个固定的数据结构以便在极小的空间存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</li>
</ul>
</li>
</ul>
</li>
<li>类型指针，即对象指向它的类元数据的指针<ul>
<li>对象头的另外一个部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针（还有通过句柄的方式）。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例数据部分</p>
</blockquote>
<p>接下来的实例数据部分是对象真正存储的有限信息，也是程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配参数（<code>FieldAllocationStyle</code>）和字段在Java源码中定义顺序的影响。</p>
<p>HotSpot虚拟机默认的分配策略为:</p>
<p><code>longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers)</code></p>
<p>从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提的条件下，在父类中定义的变量会出现在子类之前。如果<code>CompactFields</code>参数值为<code>true</code>，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<blockquote>
<p>第三部分对齐填充并不是必然存在的，</p>
</blockquote>
<p>也没有特别的含义，它仅仅起着占位符的作用。由于<code>HotSpot VM</code>的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<hr>
<p><strong>对象的访问定位</strong></p>
<p>建立对象是为了使用对象，我们的Java程序需要通过<code>栈上的reference</code>数据来<code>操作堆上的具体对象</code>。由于<code>reference</code>类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/handlepoll.png" alt="img"></p>
<p>如果是直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/pointpoll.png" alt="img"></p>
<p>这两种对象访问方式各有优势：</p>
<ul>
<li>使用句柄来访问的最大好处就是<code>reference</code>中存储的是<strong>稳定的句柄地址</strong>，在对象被移动（垃圾收集时移动对象是非常普遍的行为）是只会改变句柄中的实例数据指针，而reference本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁。<code>Sun HotSpot</code>虚拟机采用的是第二种方式。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/java/面试之Java篇/" data-id="cj7hnifd6000q6opjsgyqttac" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/java/面试之Java篇/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-git/git操作再识 拥抱开始" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/git/git操作再识 拥抱开始/">Git操作再识 拥抱开始</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/git/git操作再识 拥抱开始/">
            <time datetime="2017-09-12T00:02:04.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/git/">git</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/git/">git</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p><strong>Linux</strong></p>
<p><code>$ sudo yum install git</code></p>
<p>或者</p>
<p><code>$ sudo apt-get install git</code></p>
<p><strong>Mac</strong></p>
<p>直接在<code>Terminal</code>执行<code>git</code>命令, 如果没有会提示安装方法.</p>
<p>如果喜欢安装程序的话, <a href="http://git-scm.com/download/mac" target="_blank" rel="external">点这里</a></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>第一次安装, 千万别要忘了配置你的git的使用者名字和邮箱. 这个道理很简单, 每一次的提交时需要记录提交者的, 如果没有提交者, 那么bug出现找谁来背锅??</p>
<h3 id="查看config"><a href="#查看config" class="headerlink" title="查看config"></a>查看config</h3><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。</p>
<p><strong>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。</strong></p>
<p><code>$ git config --system --list</code></p>
<hr>
<p><strong>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。</strong></p>
<p><code>$ git config --global --list</code></p>
<hr>
<p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：针对该仓库。</p>
<p>每一个级别覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p>
<hr>
<p><strong>当然, 也可以查看某一项配置信息.</strong></p>
<ul>
<li>形式:<code>git config [--global|--system] &lt;key&gt;</code></li>
</ul>
<p><em>查看最终的配置属性值</em><br><code>$ git config user.name</code></p>
<p><em>查看当前系统的属性值</em><br><code>$ git config --global user.name</code></p>
<hr>
<h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><p><code>$ git config --global user.name &quot;name&quot;</code></p>
<p><code>$ git config --global user.email xxx@163.com</code></p>
<p>使用<code>--global</code>选项, 当以后在该系统上做的任何操作都会使用此属性. 如果你需要在某一个特定的项目使用其他名字和邮箱, 那么可以通过设置<strong>项目中的config文件</strong>, 这样config中的属性会覆盖掉<strong>global的全局属性</strong>, 并且当在其他项目中并不会造成影响. 使用方式只需要去掉<code>--global</code>参数即可修改项目中的<code>.git/config</code>文件</p>
<p><code>$ git config user.name &quot;name&quot;</code></p>
<hr>
<p><strong>获取帮助手册</strong></p>
<p>形式: <code>git help &lt;verb&gt;</code> 或者 <code>git &lt;verb&gt; --help</code></p>
<p>比如查看config手册</p>
<p><code>$ git help config</code></p>
<h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>例如: 生成别名之后可以在日后用简短的表示来使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.br branch</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure>
<h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><p>对于自动生成的文件, 日志, 编译的临时文件等. 可以对其进行配置, 让git不追踪这些文件</p>
<p>规范如下:</p>
<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反</li>
</ul>
<p><code>glob模式</code>是指shell所使用的简化了的正则表达式.</p>
<ul>
<li><code>*</code> :匹配零个或多个任意字符</li>
<li><code>[abc]</code> :只匹配括号内的任意一个字符</li>
<li><code>[0-9]</code> :使用短划线表示范围, 可以匹配0到9之间的任何字符.</li>
<li><code>?</code> :匹配任意一个字符</li>
<li><code>**</code>:匹配任意的中间目录,例如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>,<code>a/b/c/z</code>等</li>
</ul>
<p>如下给出一个样板:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 忽略所有以 .c结尾的文件</div><div class="line">*.c</div><div class="line"></div><div class="line"># 但是 stream.c 会被git追踪</div><div class="line">!stream.c</div><div class="line"></div><div class="line"># 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO</div><div class="line">/TODO</div><div class="line"></div><div class="line"># 忽略所有在build文件夹下的文件</div><div class="line">build/</div><div class="line"></div><div class="line"># 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt</div><div class="line">doc/*.txt</div><div class="line"></div><div class="line"># 忽略所有在doc目录下的.pdf文件</div><div class="line">doc/**/*.pdf</div></pre></td></tr></table></figure>
<h2 id="仓库的基础操作"><a href="#仓库的基础操作" class="headerlink" title="仓库的基础操作"></a>仓库的基础操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure>
<h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 添加全部暂存区和历史区不存在的或者有更改的 `.c`结尾的文件</div><div class="line">$ git add *.c </div><div class="line">  </div><div class="line"># 添加全部暂存区和历史区不存在的或者有更改的文件</div><div class="line">$ git add .  </div><div class="line"></div><div class="line"># 指定文件添加</div><div class="line">$ git add test.c</div></pre></td></tr></table></figure>
<hr>
<h3 id="status仓库"><a href="#status仓库" class="headerlink" title="status仓库"></a>status仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"></div><div class="line"># 如果需要显示一种紧凑式格式</div><div class="line">$ git status --short      # 等价于 $ git status -s</div></pre></td></tr></table></figure>
<p>紧凑式中字母的表示含义如下:</p>
<ul>
<li><code>??</code> :表示新添加的未追踪的文件</li>
<li><code>M</code> :M出现在右边,表示该文件被修改但是还没有放入暂存区</li>
<li><code>M</code> :M出现在左边,表示文件被修改已经放入了暂存区</li>
<li><code>MM</code> :出现两个,代表此文件在工作区修改已经放入了暂存区, 但之后有进行了修改,没有添加到暂存区</li>
</ul>
<hr>
<h3 id="diff仓库"><a href="#diff仓库" class="headerlink" title="diff仓库"></a>diff仓库</h3><p>如果你想知道文件具体修改的内容, 那么<code>diff</code>会很有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 查看以追踪但尚未暂存的文件更新了哪些部分, 不添加额外参数</div><div class="line">$ git diff</div><div class="line"></div><div class="line"># 对使用了add添加到了暂存区的内容, 使用--staged参数或者--cached</div><div class="line">$ git diff --staged</div></pre></td></tr></table></figure>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 常规做法</div><div class="line">$ git commit -m &quot;commit message&quot;</div><div class="line"></div><div class="line"># 如果不使用-m参数添加提交信息, git会使用默认的编译器如vi进行提交描述编写.</div><div class="line"># 可通过$ git config --global core.edit 设定喜欢的编译器</div><div class="line"></div><div class="line"># 跳过暂存区操作, 直接从工作区提交到历史区</div><div class="line">$ git commit -a -m &quot;&quot;          #等价于: $ git commit -am &quot;&quot;</div></pre></td></tr></table></figure>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>如果在工作区间对一个文件进行删除, 需要先进行<code>add</code>,然后才可以提交. 使用<code>git rm</code>可以直接在工作区间删除文件, 并提交到暂存区.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git rm fileName</div><div class="line"></div><div class="line"># 如果文件修改,并添加了暂存区, 需要使用-f参数来强制删除(force)</div><div class="line">$ git rm -f fileName</div><div class="line"></div><div class="line"># 可以使用glob模式,如下</div><div class="line">$ git rm log/\*.log         # 删除log目录下所有名称是.log结尾文件</div><div class="line">$ git rm \*~                # 删除以~结尾的所有文件</div></pre></td></tr></table></figure>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>同样使用<code>git rm</code>会方便很多, 并且如果相对文件重命名也可以如此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git mv file_from file_to</div></pre></td></tr></table></figure>
<p>当执行了这条语句之后, 只需要在下一次<code>commit</code>即可, 不需要考虑额外操作. 等价于如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv file_from file_to</div><div class="line">$ git rm file_from</div><div class="line">$ git rm file_to</div></pre></td></tr></table></figure>
<h3 id="查看历史提交"><a href="#查看历史提交" class="headerlink" title="查看历史提交"></a>查看历史提交</h3><p>如果是最基本的<code>git log</code>, 那么会按提交时间列出所有更新, 包括提交的SHA-1校验和, 作者名称,邮箱,提交时间,提交说明. 下面说说常用选项.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -p:仅显示最近x次的提交  格式 $ git log -p -x</div><div class="line">$ git log -p -2             # 查看最近的两次提交内容</div><div class="line"></div><div class="line"></div><div class="line"># --stat:简略的显示每次提交的内容更改, 如哪些文件变更,多少删除,多少添加等</div><div class="line">$ git log --stat</div><div class="line"></div><div class="line"># --pretty: 指定默认不同格式展示信息</div><div class="line">$ git log --pretty=oneline              #每次提交用一行显示</div><div class="line"></div><div class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;  </div><div class="line"># 效果:1a99c42 - 苏, 19 hours ago : 无意义提交</div></pre></td></tr></table></figure>
<p><strong>关于format对应的常用占位符的写法和意义</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%H</td>
<td>提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td>%h</td>
<td>提交对象的简短哈希字串</td>
</tr>
<tr>
<td>%T</td>
<td>树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td>%t</td>
<td>树对象的简短哈希字串</td>
</tr>
<tr>
<td>%P</td>
<td>父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td>%p</td>
<td>父对象的简短哈希字串</td>
</tr>
<tr>
<td>%an</td>
<td>作者（author）的名字</td>
</tr>
<tr>
<td>%ae</td>
<td>作者的电子邮件地址</td>
</tr>
<tr>
<td>%ad</td>
<td>作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td>%ar</td>
<td>作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%cn</td>
<td>提交者(committer)的名字</td>
</tr>
<tr>
<td>%ce</td>
<td>提交者的电子邮件地址</td>
</tr>
<tr>
<td>%cd</td>
<td>提交日期</td>
</tr>
<tr>
<td>%cr</td>
<td>提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%s</td>
<td>提交说明</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>图形展示分支的合并历史</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --oneline   #oneline只是让输出看起来比较舒服</div></pre></td></tr></table></figure>
<hr>
<p><strong>git log的一些其他操作</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td>–stat</td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td>–shortstat</td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td>–name-only</td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td>–name-status</td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td>–abbrev-commit</td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td>–relative-date</td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td>–graph</td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td>–pretty</td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<p><strong>查找一个字符串的出现和删除的提交</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 使用限制符-S后面紧跟要查询的字符串</div><div class="line">$ git log -Smethod_name</div><div class="line"></div><div class="line"># 或者针对一个文件进行更改的提交查询, 只需要在后面追加文件名称即可</div><div class="line">$ git log fileName</div></pre></td></tr></table></figure>
<p>哈哈,即使如果你不小心写个隐藏bug不管几个月之后,如果老大要想找出问题是写引发的其实很简单.例如这样<br><code>$ git log -p fileName</code> 想甩锅?算了吧,还是认错以后多注意吧.</p>
<p><strong>还有一些限制log输出的选项</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-(n)</td>
<td>仅显示最近的 n 条提交</td>
</tr>
<tr>
<td>–since, –after</td>
<td>仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td>–until, –before</td>
<td>仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td>–author</td>
<td>仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td>–committer</td>
<td>仅显示指定提交者相关的提交。</td>
</tr>
<tr>
<td>–grep</td>
<td>仅显示含指定关键字的提交</td>
</tr>
<tr>
<td>-S</td>
<td>仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<p>一个实际的例子，如果要查看 Git 仓库中，2016 年 11 月1号到7号，作者叫苏的提交文件，可以用下面的查询命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log --pretty=&quot;%h - %s&quot; --author=苏 --since=&quot;2016-11-01&quot; \</div><div class="line">   --before=&quot;2016-11-07&quot;</div></pre></td></tr></table></figure>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p><strong>amend重新提交</strong></p>
<p>当我们<code>commit</code>之后突然发现漏掉了一个文件, 这个时候不可能对一个文件再进行<code>commit</code>一次, 这样做就显得很多余, 而如果版本回退之前再添加也比较麻烦. 这个时候就可以使用这个<code>amend</code>命令.如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;版本1.5开发代码&quot;</div><div class="line"></div><div class="line"># 正当你松了一口气的时候发现配置文件忘记修改了, 你赶紧修改,并适合用add到暂存区</div><div class="line">$ git add project.property</div><div class="line">$ git commit --amend         </div><div class="line"># 你会神奇的发现你没有增加任何多余的操作就把漏掉的文件补齐到最后一次提交中</div></pre></td></tr></table></figure>
<hr>
<p><strong>取消暂存的文件</strong></p>
<p>就是对文件进行了<code>git add</code>操作. 这个时候可以<code>reset</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 让暂存区的文件变成文件修改但是没有添加暂存区的状态</div><div class="line">$ git reset HEAD fileName</div></pre></td></tr></table></figure>
<p><strong>撤销对文件的修改</strong></p>
<p>场景: 当文件修改了, 但是还没有进行<code>git add</code>的时候还只是在工作区间, 还原成最后一次提交的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- filename</div></pre></td></tr></table></figure>
<p>要注意使用, 使用之前确定是否要抛弃已经添加的内容. 因为这个动作可能让你最新添加的内容彻底丢失. 因为没有进行<code>commit</code>, 一般来说进行了<code>commit</code>的内容都是可以恢复的.</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote>
<p>Git可以给历史中的某一个提交打上标签, 以示重要. 比如每次正式版本的上线等.</p>
</blockquote>
<p><strong>列出标签</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line"></div><div class="line"># 如果你只关心某一部分的标签, 例如只对v2.x的标签感兴趣,你可以这样做</div><div class="line">$ git tag -l &apos;v2.*&apos;</div></pre></td></tr></table></figure>
<hr>
<p><strong>创建标签</strong></p>
<p>标签分为两种一种是<code>附加标签</code>另一种是<code>轻量标签</code>.</p>
<ul>
<li>附加标签: 会保存打标签者的信息, 时间和附加信息. 最后更随打标签的提交</li>
<li>轻量标签: 只是在一个提交上做一个标记. 存储在一个专门保存标签的文件,指向提交的hash值</li>
</ul>
<p>先来看附加标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.0 -m &apos;附加信息&apos;</div></pre></td></tr></table></figure>
<p>轻量标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v1.0</div></pre></td></tr></table></figure>
<p>后期打标签, 就是对已经提交某次提交进行追加标签设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 可以先使用git log --oneline获取提交历史的hash值</div><div class="line">$ git log --oneline</div><div class="line"></div><div class="line"># 然后把hash值赋值到标签语句之后</div><div class="line">$ git tag -a v1.1 a6b4c97</div></pre></td></tr></table></figure>
<p><strong>共享标签</strong></p>
<p>默认情况下, <code>git push</code>不会把标签传递到远程服务器. 需要显示的推送标签共享到服务器<br>例如: <code>git push origin [tagname]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin v1.4</div><div class="line"></div><div class="line"># 如果想把本地上所有在远程服务器上的不存在标签删除掉,可以这样</div><div class="line">$ git push origin --tags</div></pre></td></tr></table></figure>
<hr>
<p><strong>检出标签</strong></p>
<p>git中不能真正的检出一个标签, 但是可以在标签处创建一个新的分支.如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b checkbranch2 v2.0</div></pre></td></tr></table></figure>
<hr>
<p><strong>查看标签对应的信息</strong></p>
<p>使用<code>git show &lt;标签名&gt;</code>可以查看对应标签的详细信息, 如果<code>git show</code>这样的命令只是显示上次提交的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v1.4</div></pre></td></tr></table></figure>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="分支的创建"><a href="#分支的创建" class="headerlink" title="分支的创建"></a>分支的创建</h3><p>分支的创建, 其实本质就是创建一个可以移动的指针,这个指针名就是新的分支名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line"></div><div class="line"># 上面的只是创建了一个分支. 并没有切换, 可以使用一条命令创建并且换到新分支</div><div class="line">$ git checkout -b dev</div><div class="line"></div><div class="line"># 可以通过`git log`命令查看各个分支所指向的对象</div><div class="line">$ git log --oneline --decorate</div><div class="line"></div><div class="line"># 如果你想查看图形式的分叉历史,可以这样:</div><div class="line">$ git log --oneline --decorate --graph --all</div></pre></td></tr></table></figure>
<h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>所谓的分支切换就是<code>HEAD</code>指针的指向的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div></pre></td></tr></table></figure>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>利用<code>git merge &lt;要合并到的目标分支&gt;</code>, 这条命令会把当前所在分支与目标分支的内容合并, 可以这样理解, 如果当你试图向目标分支合并时, 如果当前分支可以顺着一个分支走下去, 那么本质上其实只是当前指针的向前移动, 由于这种情况下的合并并没有需要解决的分期, 所以git会称这个是<code>fast-forward</code>快速前进.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge dev</div></pre></td></tr></table></figure>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当一个功能分支开发完毕之后, 并进行了合并, 通常这个分支也就被删除,以保证仓库中的干净.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 删除dev分支</div><div class="line">$ git branch -d dev</div><div class="line"></div><div class="line"># 如果dev分支还有未提交的内容,为了保证你的数据安全git默认是不允许删除,可以使用`-D`强制删除</div><div class="line">$ git branch -D dev</div></pre></td></tr></table></figure>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>git branch</code>命令不只是可以创建于删除分支. 如果不添加任何参数, 那么会得到所有分支的一个列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git branch        # 其中一个分支前面的*代表,目前检出的分支就是HEAD指针所指向的分支</div><div class="line"></div><div class="line"># 追加-v参数 可以展示每一个分支最后一次提交</div><div class="line">$ git branch -v</div><div class="line"></div><div class="line"># --merged:查看那些分支已经合并到当前分支</div><div class="line">$ git branch --merged        # 一般这个列表展示的除了*号的其他分支, 都可以删除</div><div class="line"></div><div class="line"># --no-merged:查看所有包含未合并工作的分支</div><div class="line">$ git branch --no-merged</div></pre></td></tr></table></figure>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><blockquote>
<p>和合并<code>merge</code>相似的效果都是合并分支, 但是使用变基<code>rebase</code>可以让提交历史变得更简洁. 如下</p>
</blockquote>
<p><img src="http://szysky.com/2016/11/01/Git%E5%86%8D%E8%AF%86-%E4%B8%80-%E6%8B%A5%E6%8A%B1%E5%BC%80%E5%A7%8B/rebase_1.png" alt="img"></p>
<p><img src="http://szysky.com/2016/11/01/Git%E5%86%8D%E8%AF%86-%E4%B8%80-%E6%8B%A5%E6%8A%B1%E5%BC%80%E5%A7%8B/rebase_2.png" alt="img"></p>
<p>图片1是<code>merge</code>合并效果, 图片2是<code>rebase</code>合并效果. 明显变基会让提交历史看起来更加干净. 使用如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># rebase &lt;目标分支名&gt; [需要移动变基底的分支]</div><div class="line">$ git rebase master experiment </div><div class="line"> </div><div class="line"># 此时目标分支后面会追加另一个分支的提交. 此时只需要切换到master分支,合并分支即可.</div><div class="line">$ git checkout master</div><div class="line">$ git merge experiment</div></pre></td></tr></table></figure>
<p><code>rebase</code>原理就是, 从目标分支和要变基的分支向上查找出共同祖先节点就是<code>c2</code>, 然后把要变基的分支到<code>c2</code>节点的所有提交,提取出相应的修改生成一个副本, 并追加到目标分创建相对应的提交. 此时变基的分支指向<code>目标分支master</code>的后面某一次提交. 此时只要使用修改<code>master</code>指向指针使用<code>merge</code>即可.</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 获得远程的仓库列表</div><div class="line">$ git ls-remote origin</div><div class="line"></div><div class="line"># 如果想获得更多的信息</div><div class="line">$ git remote show origin</div><div class="line"></div><div class="line"># 查看远程分支和本地分支</div><div class="line">$ git branch -a</div></pre></td></tr></table></figure>
<hr>
<p><strong>拉取远程分支</strong></p>
<p>假设远程如果有一个<code>dev</code>分支, 你使用<code>fetch</code>进行抓取. 这个时候, 本地不会自动生成一个可编辑的副本, 换句话说就是这种情况下, 不会有一个新的<code>dev</code>本地分支, 只有一个不可以修改的<code>origin/dev</code>指针. 这个时候可以运行<code>git merge origin/dev</code>命令, 将这些远程dev分支的工作合并到当前分支. 如果想要在自己本地的dev分支上工作, 可以将其建立在远程分支之上.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>创建远程分支</strong></p>
<p>如果你的本地有一个新建的<code>dev</code>分支, 并且你进行了提交, 此时你想把这个分支也提交到远程的<code>dev</code>分支, 但是远程还没有创建<code>dev</code>, 这个时候可以使用如下命令: <code>git push &lt;远程仓库名&gt; &lt;要推送的本地分支&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>删除远程分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 删除远程dev分支</div><div class="line">$ git push origin --delete dev</div></pre></td></tr></table></figure>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 <code>跟踪分支</code>（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入<code>git pull</code>，<code>Git</code> 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 <code>master</code> 分支。 最简单的就是之前看到的例子，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/dev</div><div class="line"></div><div class="line"># 如果想要自定义本地分支名字</div><div class="line">$ git checkout -b 任意分支名字 origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支</strong>，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 设置HEAD指向的分支的上游为远程dev分支</div><div class="line">$ git branch -u origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>查看设置的所有跟踪分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -vv</div></pre></td></tr></table></figure>
<h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git clone &lt;url&gt;</div><div class="line"></div><div class="line"># 如果你想创建自己的仓库名, 就是本地根文件夹的名称, 那么可以如下追加名称</div><div class="line">$ git clone &lt;url&gt; [dirName]</div></pre></td></tr></table></figure>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 默认查看远程仓库的方式</div><div class="line">$ git remote </div><div class="line"></div><div class="line"># 查看远程仓库的读写权限. 如果可以看到(push)说明提交的推送</div><div class="line">$ git remote -v</div></pre></td></tr></table></figure>
<p>如果需要查看某一个仓库更多的信息时, 使用<code>git remote show ...</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote show origin</div></pre></td></tr></table></figure>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 格式: git remote add [shortName] &lt;url&gt;  同时可以指定一个仓库的引用名称,例如</div><div class="line">$ git remote add rp git@github.com:suzeyu1992/GitOperateDemo.git</div><div class="line"></div><div class="line"># 此时你想对新加的远程进行拉取动作, 只需要使用之前的引用名称就可以</div><div class="line">$ git fetch rp</div></pre></td></tr></table></figure>
<h3 id="远程仓库的拉取推送"><a href="#远程仓库的拉取推送" class="headerlink" title="远程仓库的拉取推送"></a>远程仓库的拉取推送</h3><p><strong>拉取</strong></p>
<p>大家常用的可能是<code>git pull</code>这个指令. 这个指令的通常会从服务器上抓取数据自动尝试合并到当前所在分支.</p>
<p>而我们可以也可以利用<code>git fetch</code>进行本地分支所追踪的远程分支没有提交. 然后我们可以手动的进行合并.</p>
<p><strong>推送</strong></p>
<p><code>git push [remote-name] [branch-name]</code> 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>只有当对服务器有写入权限, 并且之前没有人提交, 这条命令才会生效.</p>
<p>上面的这两个推送也好拉取也好. 如果所在分支设置了远程服务器分支的追踪, 那么可以省略掉后面的仓库名和分支名. 如果没有设置那么必须显示的指定.</p>
<h3 id="远程仓库移除重命名"><a href="#远程仓库移除重命名" class="headerlink" title="远程仓库移除重命名"></a>远程仓库移除重命名</h3><p>对远程仓库的名称进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rename oldName newName</div></pre></td></tr></table></figure>
<p>想要移除一个远程仓库,例如服务器搬走了,不再使用一个特定镜像,或者一个贡献者不再贡献</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rm 仓库名</div></pre></td></tr></table></figure>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/git/git操作再识 拥抱开始/" data-id="cj7sum2vn0000wapjx5pq2h2v" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/git/git操作再识 拥抱开始/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap12_远程设备其余通信方式" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/">《Android 编程实战》Chap12_远程设备其余通信方式</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/">
            <time datetime="2017-09-12T00:00:31.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android中的连接技术"><a href="#Android中的连接技术" class="headerlink" title="Android中的连接技术"></a>Android中的连接技术</h2><p>大多数<code>Android</code>设备都支持多种连接技术. 通常, 例如<code>USB</code>, <code>蓝牙</code>, <code>Wi-Fi</code>.</p>
<ul>
<li><code>USB</code> 使用API通过USB进行原始串行通信, 或者使用谷歌专门为访问Android设备硬件配件定义的Android开放配件协议(Android Open Accessory Protocol, AOAP). AOAP是通过配件开发套件(Accessory Development Kit, ADK)支持的.</li>
<li><code>Bluetooth</code> Android设备都支持经典蓝牙配置文件(Classic Bluetooth Protocol), 它适合更耗电的操作, 比如视频流. <code>Android 4.3</code>开始支持蓝牙低功耗以及蓝牙智能(Bluetooth Smart)技术, 它能够和支持GATT配置的设备进行通信(如心脏检测器,计步器以及其他低功率配件)</li>
<li><code>Wi-Fi</code> 比如需要更多数据密集型通信的场景, <code>Android</code>支持三种Wi-Fi操作模式: <code>infrastructure(连接到一个接入点的的标准wifi)</code>, <code>网络共享(android设备充当其他设备wifi的接入点)</code>, <code>WiFi-Direct</code>这个模式比较有趣, 在一些新的设备可以和<code>infrastructure</code>模式进行并行工作. 允许应用程序建立对等的wifi网络, 而不需要专门的访问点.</li>
</ul>
<h2 id="Android-USB"><a href="#Android-USB" class="headerlink" title="Android USB"></a>Android USB</h2><p>Android中<code>USB</code>相关的API位于<code>android.hardware.usb</code>包. 如果需要usb外设的了解可以查看官网文档的usb/accessory相关介绍.</p>
<p>在<code>USB</code>的设计中, 会有一个设备充当<strong>主机</strong>. 除了其他功能, 主机还可以给所连接的设备供电, 这就是不需要给USB鼠标添加额外的电池, 以及可以使用笔记本上的USB端口给智能手机充电的原因.</p>
<p><code>Android设备</code>也可以作为USB主机为外部设备充电, 这意味着可以把例如读卡器,指纹扫描,以及其他usb外设连接到手机设备上.</p>
<p>了解一下就好了如果需要更多, <a href="https://developer.android.com/guide/topics/connectivity/usb/index.html" target="_blank" rel="external">参考资料</a></p>
<h2 id="蓝牙低功耗"><a href="#蓝牙低功耗" class="headerlink" title="蓝牙低功耗"></a>蓝牙低功耗</h2><p>在<code>Android 4.3</code>开始支持蓝牙智能, 包括心率监视器, 活动跟踪器等蓝牙低功耗<code>BLE</code>设备的支持.</p>
<p>如果需要<code>蓝牙低功耗</code>比较感兴趣, 可以查看<a href="http://szysky.com/2016/10/08/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B12-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">博客的android蓝牙系列</a></p>
<h2 id="Android-Wi-Fi"><a href="#Android-Wi-Fi" class="headerlink" title="Android Wi-Fi"></a>Android Wi-Fi</h2><p><code>Wi-Fi</code>是Wi-Fi联盟管理的各种技术的统称. <code>Wi-Fi Direct</code>是运行在802.11n标准之上的额外技术. 使用该技术的设备不需要专门的连接点, 这点和蓝牙很相似, 不过<code>Wi-Fi Direct</code>使用高速的<code>Wi-Fi</code>进行通信.</p>
<p>但是, 即使设备都不再同一个<code>Wi-Fi</code>, 为了建立连接仍然需要发现它们. 发现意味着找到运行服务的设备的ip地址. Android已经内置了网络发现API, 支持标准的<code>Wi-Fi(infrastructure)和Wi-Fi Direct</code>, 可以让设备发现使用<code>DNS-SD</code>协议声明的服务.</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Android提供了标准的发现机制, 允许开发者宣布自己的服务以及发现本地网络上的服务. 该实现包括两个标准: <code>mDNS和DNS-SD</code>. <code>mDNS</code>是一个多播协议, 使用UDP组播协议宣布和发现主机. <code>DNS-SD</code>是一个服务发现协议, 用于宣布和发现运行在远程主机(通常限于本地网络)的服务. 可以通过<code>android.net.nsd</code>包以及<code>NsdManager</code>使用这些功能.</p>
<p>以下代码可以来声明一个设备中的服务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  声明设备中标准Wi-Fi的服务</div><div class="line">*/</div><div class="line">private void announceService()&#123;</div><div class="line">   NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">   NsdServiceInfo nsdServiceInfo = new NsdServiceInfo();</div><div class="line">   nsdServiceInfo.setPort(8081);</div><div class="line">   nsdServiceInfo.setServiceName(&quot;wifi服务哦&quot;);</div><div class="line">   nsdServiceInfo.setServiceType(&quot;_http._tcp.&quot;);</div><div class="line"></div><div class="line">   nsdManager.registerService(nsdServiceInfo, NsdManager.PROTOCOL_DNS_SD, new NsdManager.RegistrationListener() &#123;</div><div class="line">       @Override</div><div class="line">       public void onRegistrationFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line">           Log.e(TAG, &quot;onRegistrationFailed: &quot; );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onUnregistrationFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line">           Log.e(TAG, &quot;onUnregistrationFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceRegistered(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.e(TAG, &quot;onServiceRegistered: &quot; );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceUnregistered(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.e(TAG, &quot;onServiceUnregistered: &quot; );</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Note: 如果不给设置服务名, 那么会使用wifi网络中的设备IP地址. mDNS的服务类型必须是一个有效的类型. 再调用了注册方法后, <code>NsdManager</code>开始宣布在本地<code>Wi-Fi</code>上的服务, 当注册状态发生变化后会触发监听回调.</p>
<p>如果要发现一个服务, 使用同样的API实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  发现一个服务</div><div class="line">*/</div><div class="line">private void discoverService()&#123;</div><div class="line">   NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">   nsdManager.discoverServices(&quot;_http._tcp.&quot;, NsdManager.PROTOCOL_DNS_SD, new NsdManager.DiscoveryListener() &#123;</div><div class="line">       @Override</div><div class="line">       public void onStartDiscoveryFailed(String serviceType, int errorCode) &#123;</div><div class="line">           Log.d(TAG, &quot;onStartDiscoveryFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onStopDiscoveryFailed(String serviceType, int errorCode) &#123;</div><div class="line">           Log.d(TAG, &quot;onStopDiscoveryFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onDiscoveryStarted(String serviceType) &#123;</div><div class="line">           Log.d(TAG, &quot;onDiscoveryStarted: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onDiscoveryStopped(String serviceType) &#123;</div><div class="line">           Log.d(TAG, &quot;onDiscoveryStopped: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceFound(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.d(TAG, &quot;onServiceFound&quot;);</div><div class="line">           NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">           nsdManager.resolveService(serviceInfo, new NsdManager.ResolveListener() &#123;</div><div class="line">               @Override</div><div class="line">               public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">               @Override</div><div class="line">               public void onServiceResolved(NsdServiceInfo serviceInfo) &#123;</div><div class="line">                   Log.w(TAG, &quot;主机: &quot;+serviceInfo.getHost() +&quot;      端口:&quot;+serviceInfo.getPort() );</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceLost(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.d(TAG, &quot;onServiceLost: &quot;);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 需要使用服务类型来搜索服务, 一旦服务的状态发生变化(发现和丢失某些东西, 启动和停止发现服务)都会收到回调. 如果需要解析更详细的信息, 通过<code>NsdManager#resolverService()</code>方法来解析. 解析成功会回调函数.</p>
<p>通过<code>NsdManager</code>使用网络发现服务可以在不强制用户手动输入IP地址的情况下和本地设备进行通信. 当要创建共享数据的应用或者建立一个本地多人游戏时, 这是一个选择项.</p>
<h3 id="Wi-Fi-Direct"><a href="#Wi-Fi-Direct" class="headerlink" title="Wi-Fi Direct"></a>Wi-Fi Direct</h3><p><code>Wi-Fi Direct</code>是Wi-Fi联盟802.11标准的一部分, 允许在设备间进行高速的Wi-Fi通信, 而不需要专门的接入点. 它基本上是一个采用Wi-Fi技术的对等协议. 所有运行2.3及后续版本的设备都支持<code>Wi-Fi Direct</code>, 但是知道<code>Android 4.1</code>以及网络服务发现API的引入, 开发人员才真正对<code>Wi-Fi Direct</code>变得感兴趣.</p>
<p>在运行<code>Android 4.0</code>或更高的版本的设备上, 通常可以并行地运行<code>Wi-Fi Direct</code>, 这意味着设备可以同时支持<code>Wi-Fi Direct</code>以及普通的<code>Wi-Fi</code>.</p>
<p>主要API<code>WifiP2pManager</code> 来在一端设备创建并发布服务并监听变化, 另一端通过监听对等的设备并使用<code>WifiP2pServiceRequest</code>来搜索, 当搜索到可用符合的设备进行连接. 当两个设备建立连接, 服务端的注册的广播就会接收到通知. 并进行后续操作处理.</p>
<p>使用<code>WiFi Direct</code>最主要的原因是不需要现有的WIFI基础设施. 同时, 由于建立过程不需要额外的PIN码或者密码, 使用这种方式连接设备会很容易.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/" data-id="cj7hnifdv00146opje8f2zhjj" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap11_网络 Web服务" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/">《Android 编程实战》Chap11_网络 Web服务</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/">
            <time datetime="2017-09-11T23:59:43.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android上的网络调用"><a href="#Android上的网络调用" class="headerlink" title="Android上的网络调用"></a>Android上的网络调用</h2><p>虽然<code>Android</code>同时支持<code>TCP</code>和<code>UDP</code>通信, 但应用程序的大部分网络调用都是建立在<code>TCP</code>之上的<code>HTTP</code>请求完成的.</p>
<p>网络操作的两个比较重要的规则:</p>
<ol>
<li>永远不要在主线程做耗时操作</li>
<li>在<code>Service</code>而不是<code>Activity</code>中执行网络操作. 因为有很多情况下, 在<code>Activity</code>中执行网络操作, 很多时候需要考虑<code>Activity</code>快速切换的状态. 比如用户按了主屏幕键, 然后1秒后又回到了应用程序.</li>
</ol>
<h3 id="HttpUrlConnection"><a href="#HttpUrlConnection" class="headerlink" title="HttpUrlConnection"></a>HttpUrlConnection</h3><p><code>Android</code>提供了两个用于<code>HTTP</code>通信的API. <code>Apache</code>的<code>HttpClient</code>和<code>HttpUrlConnection</code>. 两者都能提供相同的功能. 但是推荐<code>HttpUrlConnection</code>, 因为谷歌一直在对其维护. 比如透明的响应压缩, 响应缓存.</p>
<p><code>Android 4.0(ICS)</code>提供响应缓存功能, 所以如果要支持早期的版本, 开发者需要使用手动实现通过反射来初始化缓存. 如果应用最低支持4.0, 那么使用以下代码开启.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpResponseCache httpResponseCache = HttpResponseCache.install(new File(getCacheDir, &quot;http&quot;), CACHE_SIZE);</div></pre></td></tr></table></figure>
<p>为应用选择一个合适的缓存大小. 如果只获取少量的数据, 可以选择几兆大小的缓存. 缓存对应用程序是私有的, 所以相对来说是比较安全的.</p>
<p>比如说<code>HTTP GET</code>请求, <a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/blob/0d16eb99528aa7ed7bfc238e881222879ab7d95f/Network/app/src/main/java/com/szysky/note/network/HTTPGet.java" target="_blank" rel="external">可以看事例代码</a></p>
<p><strong>或者说上传文件</strong></p>
<p>比如说传送图片或者其他文件到服务器, 由于Java API并没有提供一个可以直接上传文件的的方法. 使用HTTP发送数据涉及使用<code>HTTP POST</code>发送<code>body</code>中的数据. 而body需要设置一些特殊的格式, 并且还要正确地设置<code>header</code>字段. 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">private static final long MAX_FIXED_SIZE = 5 * 1024 * 1024;</div><div class="line">private static final String CRLF = &quot;\r\n&quot;;</div><div class="line">/**</div><div class="line">*  使用HTTP POST往服务器发送文件</div><div class="line">*/</div><div class="line">public int postFileToURL(File file, String mimeType, URL url) throws IOException &#123;</div><div class="line"></div><div class="line">   DataOutputStream requestData = null;</div><div class="line">   try &#123;</div><div class="line">       long fileSize = file.length();</div><div class="line">       String fileName = file.getName();</div><div class="line"></div><div class="line">       // 创建一个随机边界符字符串</div><div class="line">       Random random = new Random();</div><div class="line">       byte[] randomBytes = new byte[16];</div><div class="line">       random.nextBytes(randomBytes);</div><div class="line">       String boundary = Base64.encodeToString(randomBytes, Base64.NO_WRAP);</div><div class="line"></div><div class="line">       // 配置请求设置</div><div class="line">       HttpURLConnection uc = (HttpURLConnection) url.openConnection();</div><div class="line">       uc.setUseCaches(false);</div><div class="line">       uc.setDoOutput(true);           // 设置可以发送数据</div><div class="line">       uc.setRequestMethod(&quot;POST&quot;);</div><div class="line"></div><div class="line">       // 设置HTTP header</div><div class="line">       uc.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</div><div class="line">       uc.setRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</div><div class="line">       uc.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data;boundary=&quot;+boundary);</div><div class="line"></div><div class="line">       // 如果文件大于max_fixed_size, 使用分块流模式</div><div class="line">       if (fileSize &gt; MAX_FIXED_SIZE)&#123;</div><div class="line">           uc.setChunkedStreamingMode(0);</div><div class="line">       &#125;else&#123;</div><div class="line">           uc.setFixedLengthStreamingMode((int)fileSize);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // 打开文件方便读取</div><div class="line">       FileInputStream fileIn = new FileInputStream(file);</div><div class="line">       // 打开服务器连接</div><div class="line">       OutputStream out = uc.getOutputStream();</div><div class="line">       requestData = new DataOutputStream(out);</div><div class="line"></div><div class="line">       // 开始写数据</div><div class="line">       // 首先写入第一个边界符</div><div class="line">       requestData.writeBytes(&quot;--&quot; +boundary + CRLF);</div><div class="line">       // 让服务器知道文件名</div><div class="line">       requestData.writeBytes(&quot;Content-Disposition: form-data; name=\&quot;&quot;+ fileName + &quot;\&quot;; filename=\&quot;&quot;+fileName + CRLF);</div><div class="line">       // 文件的MIME类型</div><div class="line">       requestData.writeBytes(&quot;Content-Type: &quot;+mimeType + CRLF);</div><div class="line"></div><div class="line">       // 循环读取本地文件, 并写入服务器</div><div class="line">       int bytesRead;</div><div class="line">       byte[] buffer = new byte[8 * 1024];</div><div class="line">       while((bytesRead = fileIn.read(buffer)) != -1)&#123;</div><div class="line">           requestData.write(buffer, 0, bytesRead);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // 写入边界字符串, 表明已到文件结尾</div><div class="line">       requestData.writeBytes(CRLF);</div><div class="line">       requestData.writeBytes(&quot;--&quot; +boundary +&quot;--&quot;+ CRLF);</div><div class="line">       requestData.flush();</div><div class="line"></div><div class="line">       return uc.getResponseCode();</div><div class="line"></div><div class="line">   &#125; catch (IOException e) &#123;</div><div class="line">       e.printStackTrace();</div><div class="line">   &#125;finally &#123;</div><div class="line">       if (requestData != null)&#123;</div><div class="line">           requestData.close();</div><div class="line">       &#125;</div><div class="line">       return -1;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码, 需要要知道如何使用边界字符串告诉服务器文件的开始和结束位置. 另外上面还通过检查文件的大小而决定是<code>使用分块流模式(chunked streaming mode)</code>,还是<code>使用固定长度流模式</code> . 对于<code>分块流模式</code>参数0表示系统的默认大小, 这是大多数程序在该模式下的大小. 分块基本上意味着数据分部分发送数据, 每一部分都附有该块大小. 分块能更有效地使用内存, 并较少oom异常的分享, 然而, 使用固定长度的数据流模式通常更快, 但它需要更多的内存.</p>
<h3 id="OkHttp和SPDY"><a href="#OkHttp和SPDY" class="headerlink" title="OkHttp和SPDY"></a>OkHttp和SPDY</h3><p><code>HTTP</code>的一个大问题就是每个连接只允许一个请求和响应, 这迫使浏览器和其他客户端为了并行请求必须生成多个<code>套接字socket</code>连接. 虽然对于客户端连接问题就不那么大了, 但是如果是服务器端那么面临的状态就不同而语了. 在2009年, 谷歌开始着手更新<code>HTTP协议</code>来解决这些问题. 其结果就是<code>SPDY协议</code>, 它允许在一个套接字连接上发送多个<code>HTTP请求</code>. 该协议已成为下一代<code>HTTP</code>事实上的开放标准, 但它不会取代<code>HTTP</code>, 而是改良了如何通过网络请求和响应. 而<code>HTTP IETF</code>工作组日前已宣布即将开始<code>HTTP 2.0</code>的工作, 并使用<code>SPDY协议</code>作为起点.</p>
<p>如果同时开始客户端和服务端代码, 研究一下使用<code>SPDY</code>来代替常规的<code>HTTP/1.1</code>还是不错的, 因为<code>SPDY</code>能显著降低网络负载, 并能提高性能. 主流浏览器目前已经很好地支持<code>SPDY</code>, 并且已经有很多平台的实现版本, 启动就包括<code>Android</code>.</p>
<p>如果选择<code>SPDY</code>作为通信协议, 建议使用<code>OkHttp</code>, 它是<code>Square</code>公司开发的, 该库只是一个支持<code>SPDY</code>的新改进的<code>HTTP</code>客户端. 内部使用<code>HttpUrlConnection</code>接口.</p>
<p>当初始化<code>OkHttpClient</code>实例时, 它会初始化所有的东西, 比如连接池和响应缓存. 即使是普通的HTTP请求, 该实现也非常快, 使用OkHttp进行SPDY通信能显著提升网络调用的性能.</p>
<h3 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h3><p>运行标准的HTTP之上, 是HTTP的扩展. <code>Web Socket</code>允许在客户端和服务器端之前进行基于消息的异步通信. 首先客户端发送一个常规的<code>HTTP GET</code>请求, 该请求包含特殊的<code>HTTP请求头</code>, 表明客户端希望把连接升级为<code>Web Socket</code>连接.</p>
<p>如下当使用<code>Web Socket</code>时,客户端发送的请求示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /websocket HTTP/1.1</div><div class="line">Host: myserver.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: xxxxxxxxxxxxxxxxxx==</div><div class="line">Sec-WebSocket-Protocol: chat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://myserver.com</div></pre></td></tr></table></figure>
<p>如果接收客户端的请求, 下面是服务器对请求的响应:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: xxxxxxxxxxxxxxxxxxx=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<blockquote>
<p>客户端的请求头中的值并不是对每一种情况都有效, 而应根据Web Socket协议规范来计算. 通常情况下, 如果使用现成的<code>Web Socket</code>通信库, 开发者就不需要考虑这些情况.</p>
</blockquote>
<p>当<code>Web socket</code>连接建立后, 双方可以给对方发送异步消息. 通信的消息可以是文本, 或者二进制, 通常数据量是很小的. 如果需要传输大的文件, 最好还是使用标准的<code>Http</code>. <code>Web socket</code>用于发送符合相对较小的通知.</p>
<p>关于使用, 可以使用<code>Android</code>中标准的<code>Socket</code>类来实现自己的<code>Web Socket</code>客户端, 但也可以使用现有的第三方库. 比如由<code>Nathan Rajlich</code>为Java实现的WebSocket. 可以看<a href="http://java-websocket.org/" target="_blank" rel="external">介绍</a>. 另外, 这个库还包含了一个服务器的实现.</p>
<h2 id="网络和功耗"><a href="#网络和功耗" class="headerlink" title="网络和功耗"></a>网络和功耗</h2><p>手机功耗, 一般手机中消耗第一应该是屏幕, 然后第二往往和网络流量有关.</p>
<p>智能手机的无线硬件如WiFi和蜂窝网络芯片都有内置省电功能, 他们能在网络流量不活跃时自动关闭连接, 并能把功耗降到一个非常低的水平. 当应用程序要发送数据或者等待接收输入数据和包时, 网络硬件将禁用省电模式, 以便能尽可能快速和有效地发送数据.</p>
<h3 id="一般准则"><a href="#一般准则" class="headerlink" title="一般准则"></a>一般准则</h3><p>在请求网络前, 首先考虑用户目前是否确实需要这些数据. 其次考虑是否需要全部数据, 或者只是数据的前十条而已, 如果服务器也可以进行gzip压缩, 要记得打开透明压缩, 并选择数据的数据格式, 例如json.</p>
<h3 id="高效的网络轮询"><a href="#高效的网络轮询" class="headerlink" title="高效的网络轮询"></a>高效的网络轮询</h3><p>网络轮询有几个缺点, 但是有时只能使用轮询来完成在线服务器的新数据的检查. 这时就别忘了<code>AlarmManager</code>这个API可以方便的进行轮询.</p>
<h3 id="服务器端推送"><a href="#服务器端推送" class="headerlink" title="服务器端推送"></a>服务器端推送</h3><p>减少网络调用次数最好的解决办法就是使用服务器端推送. 这样可以让服务器主动通知客户端有新的数据需要检索. 服务器端推送可以有很多种方式, 它可以不直接连接互联网(比如监听短信), 也可以是长期保持获取的常规TCP套接字连接.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/" data-id="cj7hnifdt00126opj74bshbyk" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap10_隐藏的Android API" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/">《Android 编程实战》Chap10_隐藏的Android API</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/">
            <time datetime="2017-09-11T23:59:03.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="官方API和隐藏API"><a href="#官方API和隐藏API" class="headerlink" title="官方API和隐藏API"></a>官方API和隐藏API</h2><p>SDK文档中的所有类, 接口, 方法以及常量都属于官方API. 虽然这些API通常能满足大多数应用的需求, 但开发者有时候需要访问更多的东西, 但却不知道如何在官方API中找到它们.</p>
<p><code>Android SDK</code>中包含了一个<code>JAR</code>文件(android.jar), 在编译代码的时候会引用它, 该文件位于<code>&lt;sdk root&gt;/platforms/android-&lt;API Level&gt;/目录</code>. 不过这里面全是空类, 方法中所有的代码都被移除了, 只声明了<code>public</code>和<code>protected</code>的类. 构建Android平台时, SDK会包含该JAR文件.</p>
<p>通过检查每一个源文件, 并移除所有被<code>@hide</code>注解的域(常量), 方法和类, 在构建SDK时会生成方法体为空的<code>android.jar</code>文件. 这意味着仍然可以在运行的设备上方法这些符号, 但是在编译时却找不到.</p>
<p>Android会自动隐藏某些API, 而不需要使用<code>@hide</code>注解. 这些API位于<code>com.android.internal</code>包中, 不属于<code>android.jar</code>文件, 但却包含大量供android平台使用的内部代码. android系统应用还包含一些其他隐藏API, 这些API通常提供没有包含在官方SDK中的系统<code>ContentProvider</code>信息.</p>
<h2 id="发现隐藏API"><a href="#发现隐藏API" class="headerlink" title="发现隐藏API"></a>发现隐藏API</h2><p>寻找API最简单的方法是在<code>Android</code>源码中搜索他们. 但是<code>Android</code>源码非常多, 还好有几个在线网站已经对这些代码进行了索引, 并提供了搜索功能. <a href="http://androidxref.com/" target="_blank" rel="external">AndroidXRef</a>就是其中的一个.</p>
<p>大部分隐藏的API都位于<code>frameworks</code>项目, 所有<code>android</code>包中的API都可以在frameworks项目中找到, 该项目还包含大部分<code>com.android.internal</code>包中的API.</p>
<h2 id="安全地调用隐藏API"><a href="#安全地调用隐藏API" class="headerlink" title="安全地调用隐藏API"></a>安全地调用隐藏API</h2><p>对于需要编译时链接的API, 也就是接口, 类, 或者方法, 开发者有两个选择. 第一种修改SDK的JAR文件, 使之包含所有需要的类和接口, 并使用该SDK来编译应用程序. 另一种解决方案是使用<code>Java</code>反射API来动态查找要调用的类和方法. 两种方法都可以利弊.</p>
<h3 id="从设备中提取隐藏API"><a href="#从设备中提取隐藏API" class="headerlink" title="从设备中提取隐藏API"></a>从设备中提取隐藏API</h3><p>要做到编译时链接隐藏API, 开发者首先要提取和处理设备中的库文件. 即可以从模拟器提取库文件, 也可以从设备中提取这些文件, 因为它们只是用来编译代码. 由于这个过程需要提取出大量文件, 建议单独创建一个空的工作目录. 另外可能要提取多个版本的库文件, 所以开发者还应为每个API级别创建一个工作目录.</p>
<p><img src="http://szysky.com/2016/10/04/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B10-%E9%9A%90%E8%97%8F%E7%9A%84Android-API/devicespull.png" alt="img"></p>
<p>这里会把设备的<code>/system/framework</code>目录全部拉取出来, 这些文件都是Android设备上基于Java的系统库, 他们是由<code>Dalvik</code>虚拟机加载的Dex优化文件. 下一步决定哪些文件包含隐藏API, 以便把它们转成可以在编译时使用的Java类文件. 大部分隐藏API都位于<code>framework.odex</code>文件, <code>bouncycastle.odex</code>文件包含了加密的库.</p>
<blockquote>
<p>从Android 4.2开始, 原来位于<code>framework.odex</code>的几个隐藏API都放在了其他文件中. 例如<code>Telephony</code>类现在是可选的了(因为并不是所有的Android设备都支持电话), 可以在<code>telephony-common.odex</code>文件中找到它.</p>
</blockquote>
<p>一旦知道需要转换的文件, 就可以下载<code>Smali</code>工具, 它能把优化后的Dex文件(.odex)转换为中间格式(.smali). 接下来使用<code>dex2Jar</code>工具再把这种中间格式转换回Java类文件.</p>
<hr>
<p><strong>修改SDK的错误处理</strong></p>
<p>当使用前面介绍的隐藏API方法时, 很难确定抽取类的方法签名是否和用户设备中相应的方法签名匹配. 虽然修改后的SDK可能在开发用的设备上正常工作, 但是用户的设备制造商可能修改了这些隐藏API. 当这种情况发生时, 应用程序会抛出<code>NoSuchMethodException</code>或者<code>ClassNotFoundException</code>异常.</p>
<p>有几种方法可以处理种种情况. 可以结合使用反射来检测是否存在隐藏API. 推荐使用这种方式, 因为它结合了两种方法的优点. 另一种方法是简单地捕获异常, 防止应用程序崩溃.</p>
<p>不管使用哪一种方法, 都是要确保调用隐藏API的时候发生错误的处理. 最起码可以确保应用程序在测试过的设备上能正常工作.</p>
<h3 id="使用反射调用隐藏API"><a href="#使用反射调用隐藏API" class="headerlink" title="使用反射调用隐藏API"></a>使用反射调用隐藏API</h3><p>使用Java中的反射API比修改<code>Android SDK</code>更安全, 因为它可以在调用<code>隐藏API</code>前检测它们是否存在. 但是, 由于所有隐藏API的绑定和调用都发生在运行时, 反射会比前面介绍的方法更慢.</p>
<p>使用反射调用隐藏API需要两步. 首先, 需要查找要调用的类和方法, 并把他们的引用存到<code>Method</code>对象中. 当持有了引用后, 接下来就可以调用对象的方法.</p>
<p>后面会演示了查找Wi-Fi网络共享的例子.</p>
<h2 id="隐藏API的使用"><a href="#隐藏API的使用" class="headerlink" title="隐藏API的使用"></a>隐藏API的使用</h2><h3 id="接收和阅读SMS"><a href="#接收和阅读SMS" class="headerlink" title="接收和阅读SMS"></a>接收和阅读SMS</h3><p><code>Android</code>中使用隐藏API最常见的例子是接收和阅读<code>SMS</code>, 虽然官方API包含了<code>RECEIVE_SMS</code>和<code>READ_SMS</code>这两个权限, 但实际执行的API却是隐藏的.</p>
<p>应用程序要想接收<code>SMS</code>必须声明使用<code>RECEIVE_SMS</code>权限, 并且实现<code>BroadcastReceiver</code>, 已处理收到的短信.</p>
<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 清单文件</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;</div><div class="line"></div><div class="line">&lt;receiver android:name=&quot;.hideapi.SmsReceiver&quot;&gt;</div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class SmsReceiver extends BroadcastReceiver &#123;</div><div class="line">    // Telephony.java 中隐藏的常量</div><div class="line">    public static final String SMS_RECEIVED_ACTION</div><div class="line">            = &quot;android.provider.Telephony.SMS_RECEIVED&quot;;</div><div class="line"></div><div class="line">    public static final String MESSAGE_SERVICE_NUMBER = &quot;+461234567890&quot;;</div><div class="line">    private static final String MESSAGE_SERVICE_PREFIX = &quot;MYSERVICE&quot;;</div><div class="line"></div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line">        if (SMS_RECEIVED_ACTION.equals(action)) &#123;</div><div class="line">            // 通过 pdus 获取SMS数据的隐藏键</div><div class="line">            Object[] messages =</div><div class="line">                    (Object[]) intent.getSerializableExtra(&quot;pdus&quot;);</div><div class="line">            for (Object message : messages) &#123;</div><div class="line">                byte[] messageData = (byte[]) message;</div><div class="line">                SmsMessage smsMessage =</div><div class="line">                        SmsMessage.createFromPdu(messageData);</div><div class="line">                Log.e(&quot;haha&quot;, &quot;收到消息来自: &quot;+smsMessage.getOriginatingAddress()+ &quot;   内容:&quot;+smsMessage.getMessageBody());</div><div class="line"></div><div class="line">                processSms(smsMessage);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只关心指定的电话号码</div><div class="line">    private void processSms(SmsMessage smsMessage) &#123;</div><div class="line">        String from = smsMessage.getOriginatingAddress();</div><div class="line">        if (MESSAGE_SERVICE_NUMBER.equals(from)) &#123;</div><div class="line">            String messageBody = smsMessage.getMessageBody();</div><div class="line">            if (messageBody.startsWith(MESSAGE_SERVICE_PREFIX)) &#123;</div><div class="line">                // TODO: 数据验证通过开始处理</div><div class="line">                Log.e(&quot;haha&quot;, &quot;processSms: &quot;+messageBody);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面利用广播监听<code>Intent</code>操作<code>android.provider.Telephony.SMS_RECEIVED</code>. 这个例子中唯一隐藏的部分就是<code>Intent</code>的action. 以及用来从<code>Intent(&quot;pdus&quot;)</code>检索SMS数据的字符串.</p>
<p>要读取已经收到的<code>SMS</code>, 需要查询一个隐藏的<code>ContentProvider</code>, 并声明使用<code>READ_SMS</code>权限. <code>android.provider</code>包中的<code>Telephony</code>类提供了所有需要的信息. 使用该类最佳的方式是把它复制到自己的项目中, 并修改类的包结构. 由于<code>Telephony</code>类还包含其他隐藏类和方法的调用, 所以还必须删除或者重构这些调用, 以便能够编译代码. 取决于使用<code>隐藏API</code>的数量, 有时候简单复制一些常量声明而不是整个类就足够了.</p>
<p>阅读的部分就省略了, 除了某些特定方向的应用, 基本上应用是不会去读入用户的短信.</p>
<h3 id="隐藏设置"><a href="#隐藏设置" class="headerlink" title="隐藏设置"></a>隐藏设置</h3><p><code>Android</code>设备有数百种不同的设置, 都可以通过<code>Settings</code>类访问, 除了为每个设置提供访问的值, <code>Android</code>还提供给了一些类<code>Intent</code>操作, 使他们可以打开特定的设置UI. 例如, 要启动飞行模式设置, 在创建Intent时可以使用<code>Settings.ACTION_AIRPLANE_MODE_SETTINGS</code></p>
<p><code>Settings</code>类包含了一些隐藏的设置键和Intent操作, 当应用程序需要弄清楚设备的细节或者呈现一个特定系统设置的快捷方式时, 启动的一些常量值是非常方便的.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/" data-id="cj7hnifdn000z6opjbxygt8n1" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap9_Android应用安全问题" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/">《Android 编程实战》Chap9_Android应用安全问题</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/">
            <time datetime="2017-09-11T23:57:47.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android安全的概念"><a href="#Android安全的概念" class="headerlink" title="Android安全的概念"></a>Android安全的概念</h2><p><code>Android</code>具备一个先进的安全模型来保护应用数据和服务不被其他应用访问. 每个应用都有自己的唯一<code>ID</code>来提供最基本的保护. 每个应用都经过它唯一的密钥签名, 这种机制是<code>Android</code>框架中的安全模型基础. 此外只有当其他应用在清单文件中显式声明了正确权限后, <code>Android</code>的权限系统才会和他们共享特定的组件. 应用也可以定义权限, 比如只有使用同一个密钥签名的应用才能使用它们. 最后<code>Android</code>的API提供了各种方法来验证签名, 验证调用进程的用户ID和使用强加密方案.</p>
<h3 id="签名和密钥"><a href="#签名和密钥" class="headerlink" title="签名和密钥"></a>签名和密钥</h3><p><code>Android</code>系统中运行的所有应用都要用密钥来签名, 包括<code>Android</code>系统本身.</p>
<p>可以用同一个密钥来对发布的所有应用进行签名, 但建议为各个应用单独创建一个密钥. 多个应用共享一个密钥通常是因为这些应用要直接访问彼此的数据, 或者设定权限时将保护等级改为<code>signature</code></p>
<p>下面是一种为应用生成密钥的一个方式, 有一种比较好的方式是使用应用的包名作为别名传给<code>-alias</code>.</p>
<p><code>$ keytool -genkey -v -keystore &lt;keystore filename&gt; -alias &lt;alias for key&gt; keyalg RSA -keysize 2048 -validity 10000</code></p>
<p>在生成新密钥时, <code>keytool</code>会让你输入一个密码.</p>
<h3 id="Android权限"><a href="#Android权限" class="headerlink" title="Android权限"></a>Android权限</h3><p>要在<code>Android</code>中使用特殊权限功能, 只要在清单文件中加入一个<code>uses-permission</code>标记即可. 它会告诉系统你的应用需要该项权限, 并在安装时通知用户这项需求.</p>
<p><code>Android</code>中定义了五个保护等级: <code>常规normal</code>, <code>危险dangerous</code>, <code>同一签名signature</code>, <code>同一签名或系统signatureOrSystem</code>, <code>系统system</code>. 除非特殊指定, 默认等级一般为常规. 用来告知系统有应用要用到这个权限的函数. 只有将权限设为危险时, 它才会在用户安装(通常是通过Google Play Store)前提醒用户.</p>
<ul>
<li><code>同一签名</code>保护等级要求应用使用跟定义该权限的应用相同的同一证书来签名. 这对设备制造商来说非常有用, 因为他们可以定义只有跟系统使用同一证书签名的应用才能使用的权限. 这样, 设备制造商就可以像他们使用受保护的系统服务的设备发布新应用.</li>
<li><code>同一签名或系统 以及 系统</code>这两个等级会告诉<code>Android</code>系统, 应用必须驻存在设备的系统分区上, 这样才能使用该权限. 这个功能最常见的例子是预装在系统分区上的Google应用. 这些应用可以使用许多常规应用无法企及的权限, 即使他们用的是Google的签名而不是设备制造商的.</li>
</ul>
<blockquote>
<p>也可以添加属性<code>android:permissionFlags=&quot;costsMoney&quot;</code>它会告诉用户使用此权限的应用会产生费用, 例如要用到发短信的功能的应用. 只要应用提供了可能会给用户带来费用的API, 那就应该用带有此标记的权限来保护该API.</p>
</blockquote>
<h3 id="保护用户数据"><a href="#保护用户数据" class="headerlink" title="保护用户数据"></a>保护用户数据</h3><p>如果要创建安全的数据文件, 不被其他应用访问, 可以在应用数据目录中存储文件. 而不是外部存储中.</p>
<p>如下:演示在应用的数据目录中对一个文件进行数据追加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void appendStringToPrivateFile(Context context, String data, String fileName)&#123;</div><div class="line">    FileOutputStream out = context.openFileOutput(fileName, Context.MODE_APPEND | Context.MODE_PRIVATE);</div><div class="line">    out.write(data.getBytes(&quot;UTF-8&quot;));</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了两个标志位:</p>
<ul>
<li><code>MODE_APPEND</code> 要写入的数据都被追加到文件的末尾,</li>
<li><code>MODE_PRIVATE</code> 该文件只允许你的应用访问, 这个标识位也是默认标志位.</li>
</ul>
<p>当然这只是一种比较安全的方式, 但是如果存储非常敏感的信息, 最好再对文件进行一些加密处理.</p>
<h2 id="客户端数据加密"><a href="#客户端数据加密" class="headerlink" title="客户端数据加密"></a>客户端数据加密</h2><h3 id="Android的加密API"><a href="#Android的加密API" class="headerlink" title="Android的加密API"></a>Android的加密API</h3><p><code>Android</code>中的数据加密和解密API是基于Java SE的<code>javax.crypto</code>包中的API开始的. 实际的实现基于开源的<code>Bouncy Castle</code>加密API. 因此, 在开发<code>Android</code>应用时, 大多是使用Java SE的<code>javax.crypto</code>API就可以.</p>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>使用加密和解密函数时, 需要生成一个可根据用户输入(密码或其他安全方法)重新生成的安全且唯一的密钥.</p>
<p>下面的代码演示了如何为<code>AES算法</code>生成一个<code>SecretKey</code> <code>salt</code>是用于生成密钥的输入部分, 你需要记录下来. 在密码学中, <code>盐salt</code>是用做加密算法中单向函数输入的一段随机数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static SecretKey generateKey(char[] password , byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</div><div class="line">   int iterations = 1000;</div><div class="line">   int outputKeyLength = 128;</div><div class="line"></div><div class="line">   SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);</div><div class="line"></div><div class="line">   PBEKeySpec pbeKeySpec = new PBEKeySpec(password, salt, iterations, outputKeyLength);</div><div class="line"></div><div class="line">   byte[] keyBytes = secretKeyFactory.generateSecret(pbeKeySpec).getEncoded();</div><div class="line">   return new SecretKeySpec(keyBytes, &quot;AES&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个密钥在后面会使用</p>
<h3 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h3><p>要加密数据, 必须先生成用于加密的作为<code>Cipher</code>输入的盐和初始化向量. 下面的代码会通过<code>SecureRandom</code>类生成一个长度为8字节的盐. 注意: 不需要人工给<code>SecureRandom</code>喂种子, 系统会自动帮你处理. 创建一个初始化向量, 初始化<code>Cipher</code>, 然后将明文加密成字节队列. 有了密文数据之后, 可以使用<code>Base64</code>工具类从这些字节生成一个普通的String对象. 并把初始化向量和盐用同样的方式追加上去, 并通过一个<code>非Base64</code>字符来分开.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static String encryptClearText(char[] password, String plainText)</div><div class="line">       throws Exception &#123;</div><div class="line">   SecureRandom secureRandom = new SecureRandom();</div><div class="line">   int saltLength = 8;</div><div class="line">   byte[] salt = new byte[saltLength];</div><div class="line">   secureRandom.nextBytes(salt);</div><div class="line">   SecretKey secretKey = generateKey(password, salt);</div><div class="line"></div><div class="line">   Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</div><div class="line">   byte[] initVector = new byte[cipher.getBlockSize()];</div><div class="line">   secureRandom.nextBytes(initVector);</div><div class="line">   IvParameterSpec ivParameterSpec = new IvParameterSpec(initVector);</div><div class="line">   cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);</div><div class="line">   byte[] cipherData = cipher.doFinal(plainText.getBytes(&quot;UTF-8&quot;));</div><div class="line">   return Base64.encodeToString(cipherData,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING)</div><div class="line">           + &quot;]&quot; + Base64.encodeToString(initVector,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING)</div><div class="line">           + &quot;]&quot; + Base64.encodeToString(salt,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法返回的结果就是加密后的密文字符串. 解密的时候使用同样的规则解密即可</p>
<h3 id="解密数据"><a href="#解密数据" class="headerlink" title="解密数据"></a>解密数据</h3><p>和加密基本相似, 取出加密的的数据部分. 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static String decryptData(char[] password, String encodedData)</div><div class="line">       throws Exception &#123;</div><div class="line">   String[] parts = encodedData.split(&quot;]&quot;);</div><div class="line">   byte[] cipherData = Base64.decode(parts[0], Base64.DEFAULT);</div><div class="line">   byte[] initVector = Base64.decode(parts[1], Base64.DEFAULT);</div><div class="line">   byte[] salt = Base64.decode(parts[2], Base64.DEFAULT);</div><div class="line"></div><div class="line">   Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</div><div class="line">   IvParameterSpec ivParams = new IvParameterSpec(initVector);</div><div class="line">   SecretKey secretKey = generateKey(password, salt);</div><div class="line">   cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParams);</div><div class="line">   return new String(cipher.doFinal(cipherData), &quot;UTF-8&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面方法可以了解到<code>Cipher</code>,<code>初始化向量</code>,<code>SecretKey</code>是如何通过输入的字符串重新生成的. 只要密码匹配, 就能够对数据进行解码和编码.</p>
<h2 id="设备管理API"><a href="#设备管理API" class="headerlink" title="设备管理API"></a>设备管理API</h2><p>关于这部分, 更多偏向于系统级别的开发. 例如对远程安全加固功能, 当丢失设备通过短信,锁定设备等. 所以此处不做记录. 如果有兴趣可以查看API文档<a href="https://developer.android.com/guide/topics/admin/device-admin.html" target="_blank" rel="external">Device Administration API</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/" data-id="cj7hnife3001g6opjy9mtaxk6" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/">《Android 编程实战》Chap8_高级音频,视频及相机应用</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/">
            <time datetime="2017-09-11T23:57:02.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="高级音频应用"><a href="#高级音频应用" class="headerlink" title="高级音频应用"></a>高级音频应用</h2><p><code>Android</code>音频API提供了一些高级功能, 开发者可以把他们集成到自己的应用中. 有了这些API, 就可以很容易的实现<strong>VoIP网络电话</strong>, 构建定制的流媒体音乐客户端, 实现低延迟的游戏音效. 此外, 还有提供文本到语音转换以及语音识别API, 用户可以直接使用音频和用户交互, 而不需要使用用户界面或者触控技术.</p>
<h3 id="低延迟音频"><a href="#低延迟音频" class="headerlink" title="低延迟音频"></a>低延迟音频</h3><p><code>Android</code>有四个用来播放音频的API(算上MIDI那么就是5个)和三个用来录音的API. 接下里会简要介绍这些API.</p>
<hr>
<p><strong>音频播放API</strong></p>
<ul>
<li>音频播放默认使用<code>MediaPlayer</code>. 该类适合播放音乐或者视频, 既能播放流式资源(比如在线网络收音机), 也可以播放本地文件. 每个<code>MediaPlayer</code>都有一个关联的状态机, 需要在应用程序中跟踪这些状态. 开发者可以使用<code>MediaPlayer</code>类的API在自己的应用中嵌入音乐或者视频播放功能, 而无需额外处理或者考虑延迟问题.</li>
<li>第二种是<code>SoundPool</code>类, 它提供了低延迟的支持, 适合播放音效和其他比较短的音频, 比如可以使用<code>SoundPool</code>播放游戏声音. 但是, 它不支持音频流, 所以不适合那些需要实时音频流处理的应用如<code>VoIP</code>.</li>
<li>第三种是<code>AudioTrack</code>类, 它允许把音频流缓冲到硬件中, 支持低延迟播放, 甚至适合流媒体场景. <code>AudioTrack</code>通常能提供足够低的延迟, 可在<code>VoIP</code>或类似应用中使用.</li>
</ul>
<p>下面代码展示如何在<code>VoIP</code>应用中使用<code>AudioTrack</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class AudioTrackDemo &#123;</div><div class="line"></div><div class="line">    private final AudioTrack mAudioTrack;</div><div class="line">    private final int mMinBufferSize;</div><div class="line"></div><div class="line">    public AudioTrackDemo() &#123;</div><div class="line"></div><div class="line">        // 确定音频流的最小缓冲区和大小</div><div class="line">        mMinBufferSize = AudioTrack.getMinBufferSize(16000, AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT);</div><div class="line"></div><div class="line">        mAudioTrack = new AudioTrack(AudioManager.STREAM_VOICE_CALL,</div><div class="line">                16000,</div><div class="line">                AudioFormat.CHANNEL_OUT_MONO,</div><div class="line">                AudioFormat.ENCODING_PCM_16BIT,</div><div class="line">                mMinBufferSize * 2,</div><div class="line">                AudioTrack.MODE_STREAM);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void playPcmPacket(byte[] pcmData)&#123;</div><div class="line">        if (mAudioTrack != null &amp;&amp; mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)&#123;</div><div class="line"></div><div class="line">            // 判断是否处在播放状态</div><div class="line">            if (mAudioTrack.getPlaybackRate() != AudioTrack.PLAYSTATE_PLAYING)&#123;</div><div class="line">                mAudioTrack.play();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mAudioTrack.write(pcmData, 0, pcmData.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //  设置停止</div><div class="line">    public void stopPlayback()&#123;</div><div class="line">        if (mAudioTrack != null)&#123;</div><div class="line">            mAudioTrack.stop();</div><div class="line">            mAudioTrack.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对这个类进行一下整理, 首先从构造函数开始. 最开始需要确定音频流的最小缓冲区大小. 要做到这一点, 需要知道采样率, 数据是单声道还是立体声, 以及是否使用8位或者16位<code>PCM</code>编码. 然后以采样率和采样大小作为参数调用<code>AudioTrack.getMinBufferSize()</code>, 该方法会以字节形式返回<code>AudioTrack</code>实例的最小缓冲区大小</p>
<p>接下来, 根据使用正确的参数创建<code>AudioTrack</code>实例, 第一个参数为音频的类型, 不同的应用使用不同的值. 对于<code>VoIP</code>这种应用来说使用<code>STREAM_VOICE_CALL</code>, 而对流媒体音乐应用则使用<code>STREAM_MUSIC</code>.</p>
<p>对于参数2,3,4会根据使用场景而有所不同. 这些参数跟别表示<code>采样率</code>, <code>立体声/单声道</code>, <code>采样大小</code>. 一般而言, 一个<code>VoIP</code>会使用<code>16kHz</code>的16位单声道, 而常规的音乐CD可能采用<code>44.1kHz</code>的16位立体声. 16位立体声采样率需要更大的缓冲区以及更多的数据传输, 但是音质会更好. 所有的<code>Android</code>设备都支持<code>PCM</code>以<code>8kHz</code>,<code>16kHz</code>,<code>44.1kHz</code>的采样率播放8位或者16位的立体声.</p>
<p>缓冲区大小参数应该是最小缓冲区大小的倍数, 实际取决于具体的需求, 有时网络延迟等因素也会影响缓冲区大小. <strong>注意: 任何时候都应该避免使用空的缓冲区, 因为可能导致播放出现故障</strong></p>
<p>最后一个参数决定只发送一次音频数据<code>MODE_STATIC</code>还是连续发送数据流<code>MODE_STREAM</code>. 第一种情况需要一次发送整个音频剪辑. 对于持续发送音频流的情况, 可以发送任意大小块的<code>PCM数据</code>, 处理流媒体音乐或者VoIP通话时可能会使用这种方式.</p>
<hr>
<p><strong>2. 录音API</strong></p>
<p>说道录制音频(也可能是视频), 首先要考虑的API是<code>MediaRecorder</code>. 和<code>MediaPlayer</code>类似, 需要在应用代码中跟踪<code>MediaRecorder</code>类的内部状况. 由于<code>MediaRecorder</code>只能把录音保存在文件中, 所以他不适合录制流媒体.</p>
<p>如果需要录制流媒体, 可以使用<code>AudioRecorder</code>, 它和之前描述的<code>AudioTrack</code>非常相似.</p>
<p><a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/0109285e016f34c5403195344987cee5a7b791e0" target="_blank" rel="external">链接代码演示了如何创建<code>AudioRecorder</code>实例录制16位单声道16kHz的音频采样</a></p>
<p>其实和<code>AudioTrack</code>的创建过程非常给你相似, 在使用<code>VoIP</code>或者类似应用时可以很方便地把他们结合起来.</p>
<h3 id="OpenSL-ES"><a href="#OpenSL-ES" class="headerlink" title="OpenSL ES"></a>OpenSL ES</h3><p>前面说了3播放API和2个录制API. 还有最后一个API <code>OpenSL ES</code>, 它同时支持播放和录制. 该API是科纳斯组织(Khronos Group)的一个标准, 这个组织还负责<code>OpenGL API</code></p>
<p><code>OpenSL ES</code>提供了低级别的音频硬件访问和低延迟特性来处理音频播放和录制. 虽然<code>Android</code>中其他音频API都有方便的Java API, 但是<code>OpenSL ES</code>目前仅支持在<code>Android NDK</code>中使用本地C代码访问.</p>
<blockquote>
<p><code>= =!!! 到这里能力受限, 无法实现出效果...所以此章抄书就此太监. 后续包括OpenGL 串联Surface用于视频MediaPlayer的渲染层或者相机处理把预览画面的流连接到纹理流, 并实施处理画面实现现实AR应用等.</code></p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/" data-id="cj7hnifdy001a6opjtajn6b8f" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap7_序列化说明" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/">《Android 编程实战》Chap7_序列化说明</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/">
            <time datetime="2017-09-11T23:56:25.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="数据存储的介绍"><a href="#数据存储的介绍" class="headerlink" title="数据存储的介绍"></a>数据存储的介绍</h2><p>谈到数据数据存储通常会使用<code>持久化</code>, 而用<code>序列化</code>描述数据是如何表现其存储状态的. 如果没有数据的<code>持久化</code>, 那么数据还能在<code>RAM</code>中保持其状态, 一旦相关进程结束数据就会消失. 实现数据的持久化通常涉及性能, 延迟, 数据大小和复杂度等因素的这种. 例如, 快速的数据读取往往会导致较慢的写入. 序列化就是关于数据如何组织的, 同时包括在持久化状态和内存中.</p>
<h2 id="Android持久化选项"><a href="#Android持久化选项" class="headerlink" title="Android持久化选项"></a>Android持久化选项</h2><p><code>Android</code>中提供了两种现成的方法, 分别是:</p>
<ul>
<li><code>偏好文件(preference files)</code>: 使用<code>XML</code>格式, 通过<code>SharePreferences</code>类提供接口</li>
<li><code>数据库(sqlite)</code>: 通常被包装成<code>ContentProider</code>组件.</li>
</ul>
<p>通常选项, 应用配置属性用<code>preferences files</code>来存储; 数组表格,或者Java表示的一些数据用数据库进行存储; 而一些二进制数据, 例如图片通常当做常规文件来存储在本地.</p>
<h2 id="Preferences-file"><a href="#Preferences-file" class="headerlink" title="Preferences file"></a>Preferences file</h2><p>这些文件存储在应用程序的内部目录中, 其结构只允许存储键值对.</p>
<p>创建<code>SharePreferences</code>对象最简单的方式是使用<code>PreferenceManager.getDefaultSharedPreferences()</code>方法, 它会返回应用程序默认的偏好对象. 这种方式的便利是系统会自动管理<strong>偏好文件名</strong>. 如果需要多个偏好文件那么要使用<code>Context.getSharedPreferences()</code>方法, 它允许开发者自由命名文件. 如果只是创建<code>Activity</code>相关的偏好文件, 可以使用<code>Activity.getPreference()</code>方法, 他会在调用时得到<code>Activity</code>的名字.</p>
<blockquote>
<p><code>getDefaultSharePreferences()</code>创建的偏好文件名是由包名+<code>_preferences</code>组成的.</p>
</blockquote>
<p>其内部支持的存储值类型有<code>int</code>, <code>float</code>, <code>long</code>, <code>boolean</code>, <code>String</code>以及<code>Set&lt;String&gt;</code>对象. 键名必须是一个有效的字符串.</p>
<hr>
<p><strong>如果需要文件修改并提交存储</strong></p>
<p>首先需要获得<code>Editor</code>实例, 他提供了相应的<code>PUT</code>方法, 以及用于提交修改的方法. 在<code>Android 2.3</code>之前, 通过使用<code>commit()</code>方法把修改<strong>同步</strong>提交到存储设备中. 但在2.3之后, <code>Editor</code>类提供了用于<strong>异步</strong>执行写操作的<code>apply()</code>方法. 因为要尽可能地避免主线程执行阻塞操作, 所以<code>apply()</code>相对来说比<code>commit()</code>更好.</p>
<hr>
<p><strong>如果需要对偏好值被修改的时候可以收到通知</strong></p>
<p>那么可以通过注册一个回调函数, 每当<code>apply()</code>和<code>commit()</code>方法时都会触发该监听器. 通过对<code>SharedPreferences</code>的实例调用<code>registerOrSharedPreferenceChangeListener()</code>方法来添加内容改变回调.</p>
<h3 id="用户选项和设置用户界面"><a href="#用户选项和设置用户界面" class="headerlink" title="用户选项和设置用户界面"></a>用户选项和设置用户界面</h3><p>Android提供一套现成的<code>Activity</code>和<code>Fragment</code>类针对用户更改应用程序的选项和设置, 使得创建这类用户界面非常简单容易<code>PreferenceActivity</code>和<code>PreferenceFragment</code>.</p>
<p>但! 是! 感觉没啥用处, 基本应用都会按照自己的ui风格进行设计. 知道一下就行</p>
<h2 id="ContentProvider注意事项"><a href="#ContentProvider注意事项" class="headerlink" title="ContentProvider注意事项"></a>ContentProvider注意事项</h2><h3 id="Android数据库设计"><a href="#Android数据库设计" class="headerlink" title="Android数据库设计"></a>Android数据库设计</h3><p>关系数据库的设计通常通过<code>数据库规范化</code>完成. 该过程使用一些<code>范式</code>规则来减少数据库中的依赖和冗余. 有许多数据库范式, 但在大多数情况下, 只有前三个是相关的. 如果一个数据库设计满足了前三个范式, 可以认为它是<code>规范化</code>的.</p>
<p>由于面向的对象为<code>android</code>应用. 有可能不一定在表中尽可能多的使用外键, 虽然使用外键可以更好的减少空间的占用, 但是相对于开发中操作多表的困难度也就相应的提高. 所以需要权衡一下.</p>
<h3 id="创建和升级数据库"><a href="#创建和升级数据库" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h3><p>建议总是使用<code>ContentProvider</code>组件包装<code>SQLite</code>数据库. 通过这种方式, 可以只在一个地方管理的数据库调用, 还可以使用一些现成的数据库工具类.</p>
<h3 id="查询方法说明"><a href="#查询方法说明" class="headerlink" title="查询方法说明"></a>查询方法说明</h3><p>查询数据库(通常会调用<code>ContentResolver.query()</code>)会调用<code>ContentProvider.query()</code>方法. 在实现查询方式时必须解析传入的<code>Uri</code>以决定执行哪个查询, 并且还要检查所有传入的参数是否正确.</p>
<blockquote>
<p>编写数据库查询要把<code>WHERE</code>语句中较简单的比较放在前面. 这样会加快查询, 因为其可以尽早决定要包含的信息.</p>
</blockquote>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>每次在<code>SQLite</code>数据库执行一条<code>SQL</code>语句都会执行一次数据库事务操作. 除非是自己专门管理事务, 否则每条语句都会自动创建一个事务. 因为大多数<code>ContentProvider</code>调用最终都只会生成一条<code>SQL</code>语句, 这种情况下几乎没有必要手动处理事务. 但是如果应用程序将执行多条<code>SQL</code>语句, 比如一次插入很多条记录, 记得总是自己管理事务.</p>
<p><code>ContentProvider</code>类提供了两个事务管理的方法: <code>ContentProvider.bulkInsert()</code>和<code>ContentProvider.applyBatch()</code> 相比与普通的<code>insert()</code>快了很多.</p>
<p>事务的语义很简单. 首先调用<code>SQLiteDatabase.beginTransaction()</code>开始一个新的事务. 当成功插入所有记录之后调用<code>SQLiteDatabase.setTransactionSuccessful()</code>, 然后使用<code>SQLiteDatabase.endTransaction()</code>结束本次事务. 如果某条数据插入失败, 会抛出<code>SQLiteException</code>, 而之前的所有插入都会回滚, 因为在成功之前没有调用过<code>setTransactionSuccessful()</code></p>
<p><strong>bulkInsert()虽然会提高数据插入性能, 但是此方法只使用插入操作</strong></p>
<p>如果要在一次事务中执行多次<code>update()</code>或者<code>delete()</code>语句, 必须实现<code>ContentProvider.applyBatch()</code>方法. 接收一个<code>ContentProviderOperation集合</code>.内部循环集合通过调用<code>apply()</code>在事务内部实现操作.</p>
<p>该API是为<code>ContactsProvider</code>等较复杂的<code>ContentProvider</code>设计的, 他们有许多连接的表, 每个都有自己的<code>Uri</code>. 另外如果要批量插入多个表, 该API也可以使用.</p>
<h2 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h2><p>如果要在<code>Intent</code>上传输数据或者和另外一台设备共享数据, 需要把数据转化成接收端能识别的格式, 并且还要适于在网络上传输. 这种技术称为<code>序列化(serialization)</code></p>
<p>序列化是从内存中取出数据并把其写到文件(或者其他输出)中, 是的以后能读取完全相同的数据称为<code>反序列化</code>. android内部使用了<code>Parcelable</code>接口来处理序列化工作, 但它不适合在文件上持久存储或者在网络上传输数据.</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p><code>JSON</code>是<code>JavaScript Object Notation</code>的缩写, 是<code>JavaScript</code>标准的一个子集. 这种格式很适合表示非二进制数据的.</p>
<p>例如一下JSON数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;name&quot;:&quot;张三&quot;</div><div class="line">        &quot;id&quot;  :&quot;1&quot;</div><div class="line">        &quot;sex&quot; :&quot;男&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;name&quot;:&quot;张三&quot;</div><div class="line">        &quot;id&quot;  :&quot;1&quot;</div><div class="line">        &quot;sex&quot; :&quot;男&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;name&quot;:&quot;张三&quot;</div><div class="line">        &quot;id&quot;  :&quot;1&quot;</div><div class="line">        &quot;sex&quot; :&quot;男&quot;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这里说一下另一个<code>API</code>作为了解, 通过获得输入输出流利用<code>JsonReader</code>和<code>JsonWriter</code>API进行. 相比较直接把一个流中的全部内容读取为一个<code>String</code>中, 然后传给<code>JSONArray</code>的构造函数, 使用<code>JsonReader</code>会消耗更少的内存, 并且相对来说会更快.</p>
<p>直接使用JSON API 现在也不常用, 想了解看一下<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/blob/master/StoreOrTest/app/src/main/java/com/szysky/note/storeortest/serialization/JSONDemo.java" target="_blank" rel="external">实例代码</a></p>
<h3 id="Gson介绍"><a href="#Gson介绍" class="headerlink" title="Gson介绍"></a>Gson介绍</h3><p><code>JSONObject</code>和<code>JSONArray</code>类使用起来虽然很方便, 但是他们也有一定的局限性, 并且通常会消耗更多不必要的内存. 同样, 如果有多个不同类型的对象, 使用<code>JsonReader</code>和<code>JsonWriter</code>需要编写比较多的代码. 所以如果需要更高级的JSON数据序列化和反序列化方法, 可是使用<code>Gson</code></p>
<p><code>Gson</code>允许把简单的Java对象转换成<code>JSON</code>, 反之亦然. 所以常做的就是生成一个<code>JavaBean</code>对象, 提供set/get并转换成json对象.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/" data-id="cj7hnifdq00106opjay74moqq" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap6_重识BroadcastReceiver" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/">《Android 编程实战》Chap6_重识BroadcastReceiver</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/">
            <time datetime="2017-09-11T23:55:35.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p><code>Android</code>中发送广播事件最常用的方式是通过<code>Content.sendBroadcast()</code>方法给<code>BroadcastReceiver</code>发送<code>Intent</code>对象. 许多标准系统事件都被定义成操作字符串, 并可以在<code>Intent</code>类的API文档中查看. 例如, 如果需要在用户连接或者断开充电器的时候收到通知, 可以使用<code>Intent</code>中定义的两个广播操作: <code>ACTION_POWER_DISCONNECTED</code>和<code>ACTION_POWER_CONNECTED</code>.</p>
<hr>
<p><strong>举例: 例如监听手机充电状态改变的广播</strong></p>
<p>首先派生出一个<code>BroadcastReceiver</code>的子类.复写<code>onReceiver()</code>方法. 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ChargerConnectedReceiver extends BroadcastReceiver &#123;</div><div class="line">    public ChargerConnectedReceiver() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line"></div><div class="line">        if (Intent.ACTION_POWER_CONNECTED.equals(action))&#123;</div><div class="line">            Toast.makeText(context, &quot;手机充电啦&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;else if (Intent.ACTION_POWER_DISCONNECTED.equals(action))&#123;</div><div class="line">            Toast.makeText(context, &quot;手机不充电了&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后需要注册广播, 告诉系统在当哪一个<code>action</code>动作发生的时候需要回调我们自定的接收者的<code>onReceive()</code>方法. 这里有两种方法, <code>静态注册</code>和<code>动态注册</code>.</p>
<p><strong>静态注册</strong></p>
<p>在清单文件中声明这个广播组件, 并设置<code>intent-filter</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;receiver android:name=&quot;broadcast.ChargerConnectedReceiver&quot;&gt;</div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;action android:name=&quot;android.intent.action.ACTION_POWER_CONNECTED&quot;/&gt;</div><div class="line">      &lt;action android:name=&quot;android.intent.action.ACTION_POWER_DISCONNECTED&quot;/&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p><strong>动态注册</strong></p>
<p>一般情况动态注册都是在<code>Activity</code>中的<code>onCreate()</code>和<code>onResume()</code>同时出现的. 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ChargerConnectedActivity extends Activity &#123;</div><div class="line"></div><div class="line">    private ChargerConnectedReceiver chargerConnectedReceiver;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        // 生成对于广播的 intent过滤条件</div><div class="line">        IntentFilter intentFilter = new IntentFilter();</div><div class="line">        intentFilter.addAction(Intent.ACTION_POWER_CONNECTED);</div><div class="line">        intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED);</div><div class="line">        chargerConnectedReceiver = new ChargerConnectedReceiver();</div><div class="line">        registerReceiver(chargerConnectedReceiver, intentFilter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onPause() &#123;</div><div class="line">        super.onPause();</div><div class="line">        unregisterReceiver(chargerConnectedReceiver);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果只在应用程序处于运行或活动状态时才关心广播事件时, 可以选择在代码中注册广播. 这样可以让应用程序消耗更少的资源; 如果在清单文件中声明, 则每当有事件发生时, 广播接收器都会启动, 因此会消耗更多资源.</p>
<h3 id="本地BroadcastReceiver"><a href="#本地BroadcastReceiver" class="headerlink" title="本地BroadcastReceiver"></a>本地BroadcastReceiver</h3><p>如果只是在应用程序进程内发送和接收广播, 那么可以使用<code>LocalBroadcastManager</code>而不是更常用的<code>Context.sendBroadcast()</code>方法. 这种方法更高效, 因为不需要跨进程管理操作, 也不需要考虑广播通常涉及的安全问题. 标准IPA中没有包含<code>LocalBroadcastManager</code>类, 但是可以在支持包(support_V4)中找到. 下面演示如何使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static final String LOCAL_BROADCAST_ACTION = &quot;localBroadcast&quot;;</div><div class="line">private BroadcastReceiver mLocalReceiver;</div><div class="line"></div><div class="line">// 注册本地广播</div><div class="line">private void initLocalBroadcast() &#123;</div><div class="line">   LocalBroadcastManager instance = LocalBroadcastManager.getInstance(getApplicationContext());</div><div class="line">   IntentFilter intentFilter = new IntentFilter(LOCAL_BROADCAST_ACTION);</div><div class="line"></div><div class="line">   mLocalReceiver = new BroadcastReceiver() &#123;</div><div class="line">       @Override</div><div class="line">       public void onReceive(Context context, Intent intent) &#123;</div><div class="line">           Toast.makeText(getApplicationContext(), &quot;本地广播接收到&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   instance.registerReceiver(mLocalReceiver, intentFilter);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 发送本地广播</div><div class="line">findViewById(R.id.btn_send).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">  @Override</div><div class="line">  public void onClick(View v) &#123;</div><div class="line">      LocalBroadcastManager instance = LocalBroadcastManager.getInstance(getApplicationContext());</div><div class="line">      // 上面定义的通电状态action</div><div class="line">      Intent intent = new Intent(LOCAL_BROADCAST_ACTION);</div><div class="line">      instance.sendBroadcast(intent);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在应用程序内部使用本地广播来广播消息和状态也非常方便. 本地广播比标准的全局广播更高效和安全, 因为它不会把数据泄露给其他应用程序. 切记要和正常的接收器一样, 在对应的方法中要移除注册, 否则可能会有内存泄漏.</p>
<h3 id="普通广播和粘性广播"><a href="#普通广播和粘性广播" class="headerlink" title="普通广播和粘性广播"></a>普通广播和粘性广播</h3><p>广播分为两种类型: <strong>普通广播</strong>和<strong>有序广播</strong>.</p>
<ul>
<li><strong>普通广播</strong>会以异步方式发送给所有的接收者, 并且没有指定的接收顺序. 该方式更加高效, 但是缺少有序广播额一些高级功能, 比如不能发送结果反馈.</li>
<li><strong>有序广播</strong>按照特定的顺序分发, 每次只发给一个接收者, 开发者可以在清单文件中设置接收者的<code>intent-filter</code>标签的<code>android:priority</code>属性来控制广播的接收顺序. 有序广播还有另外一个特性: 通过使用<code>abortBroadcast()</code>, <code>setResultCode()</code>和<code>setResultData()</code>方法, 接收者可以把结果回传给广播, 或者终止广播的分发, 这样<code>Intent</code>就不会传递给下一个广播接收者.</li>
</ul>
<p>有序广播由<code>Context.sendOrderedBroadcast()</code>发起, 在接收者的<code>onReceive()</code>回调中, 通过<code>isOrderedBroadcast()</code>来判断该广播是否是有序广播. 如果是, 可以通过上面<code>setXxxx()</code>方法设置要传递下去的数据.</p>
<p>日常开发很少需要在自己的应用程序发送有序广播, 但如果要跟其他应用程序通信(比如插件), 有序广播就有用途. 在Android系统中, 有序广播最常见的场景就是监听传入的短信(隐藏API)的一部分. 后面篇幅会说.</p>
<h3 id="粘性广播"><a href="#粘性广播" class="headerlink" title="粘性广播"></a>粘性广播</h3><p><code>粘性广播(sticky broadcast)</code> 是一个普通广播的变体, 它和普通广播有细微的区别. 粘性广播在使用<code>Context.sendStickyBroadcast()</code>发送<code>Intent</code>之后, 该<code>Intent</code>还会”继续保留”, 允许之后匹配由该<code>Intent</code>新注册的广播接收者, 并发送<code>Intent</code>.(<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/ec42e2e44877f5b4b3c5363600646c4e808929e3" target="_blank" rel="external">查看验证代码</a>)</p>
<p>粘性广播的一个例子是<code>Intent.ACTION_BATTERY_CHANGED</code>, 它用来指示设备中电池电量的变化. 另一个列子是<code>Intent.ACTION_DOCK_EVENT</code>, 用来只是设备是否放在了底座. 更多的粘性广播请参考google文档. 下面的代码展示如何</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private void myRegisterBattery()&#123;</div><div class="line">   // 构建广播接收者要接收的action</div><div class="line">   IntentFilter intent = new IntentFilter();</div><div class="line">   intent.addAction(Intent.ACTION_BATTERY_CHANGED);</div><div class="line">   intent.addAction(Intent.ACTION_BATTERY_OKAY);</div><div class="line">   intent.addAction(Intent.ACTION_BATTERY_LOW);</div><div class="line">   </div><div class="line">   // 创建监听</div><div class="line">   BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123;</div><div class="line">       @Override</div><div class="line">       public void onReceive(Context context, Intent intent) &#123;</div><div class="line">           if (isInitialStickyBroadcast()) &#123;</div><div class="line">               Log.e(&quot;sususu&quot;, &quot;这是一个粘性广播&quot;);</div><div class="line">           &#125; else &#123;</div><div class="line">               Log.e(&quot;sususu&quot;, &quot;这是不是粘性广播&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   // 注册接收者</div><div class="line">   registerReceiver(broadcastReceiver, intent);</div><div class="line">&#125;</div><div class="line">​``` </div><div class="line"></div><div class="line">该方法在广播全系统的状态时特别有用, 如果你需要发送粘性广播, 那么**请添加权限**在清单文件中`&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt;`权限, 并使用`Context.sendStickyBroadcast()`发送粘性广播. </div><div class="line"></div><div class="line">&gt; 对于粘性广播一定要慎用, 因为它比普通广播更消耗资源.</div><div class="line"></div><div class="line"></div><div class="line">### 定向广播</div><div class="line"></div><div class="line">普通广播的另一个变体是`定向广播(directed broadcast)`. 定向广播使用过了`intent-filter`的一个特性, 通过在`Intent`设置`ComponentName`来显示指定接收者. 它把注册接收者的类名和包名结合在了一起. 如下:</div><div class="line"></div><div class="line"></div><div class="line">​```java</div><div class="line">Intent intent = new Intent();</div><div class="line">intent.setComponent(new Component(packName, className));</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<p>这个例子只会指定的class类的广播接收者才可以收到广播, 即便其他接收器也注册了相同的<code>Intent</code>操作. <strong>注意:使用定向广播需要同时知道接收者的包名和类名.</strong>. 使用场景很少.</p>
<h3 id="启动和禁用广播接收器"><a href="#启动和禁用广播接收器" class="headerlink" title="启动和禁用广播接收器"></a>启动和禁用广播接收器</h3><p>如果广播接收者在清单文件中注册的, 还有另外一种减少对系统负载的影响的方法. 通过<code>PackageManager</code>, 开发者可以启动和禁用应用程序的组件, 这在用户比如在应用设置更改后使用此方法即可. 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 设置组件</div><div class="line">* @param setClass 要设置改变的组件</div><div class="line">* @param isEnable true为启用, false为禁用</div><div class="line">*/</div><div class="line">public void setComponentEnable(boolean isEnable, Class setClass)&#123;</div><div class="line">   PackageManager pm = getPackageManager();</div><div class="line">   // 构建要改变组件的Component</div><div class="line">   ComponentName componentName = new ComponentName(getApplicationContext(), setClass);</div><div class="line">   pm.setComponentEnabledSetting(componentName,</div><div class="line">           isEnable ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</div><div class="line">           PackageManager.DONT_KILL_APP);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>记住, 这里仅适用静态注册就是清单文件上注册, 不支持动态注册的会抛出异常, 并且这里接收的class同样适用于Activity, Service, ContentProvider</code>. 其本质就是改变在清单文件中组件标签的<code>&lt;android:enable=&#39;true/false&#39;&gt;</code>.</p>
<p>关于<code>setComponentEnabledSetting()</code>方法的最后一个参数<code>PackageManager.DONT_KILL_APP</code>的使用. 这回防止平台杀死应用, 如果不设置该值平台默认会杀死应用.</p>
<blockquote>
<p>可以用在应用程序启动图标的切换, 比如,开发者可以在安装应用程序后只显示设置Activity界面, 在设置完成之后使用该方法把启动图标隐藏</p>
</blockquote>
<h3 id="系统广播Intent"><a href="#系统广播Intent" class="headerlink" title="系统广播Intent"></a>系统广播Intent</h3><p><code>Android API</code>定义了许多不同的系统广播事件. 例如电池电量变化, 是否连接了设备电源. 并且还有一些可能会用到的广播, 但是action并没有在API中公开, 所以后面的篇幅也会对一些隐藏的API进行一定记录.这里说一下常用的系统事件</p>
<hr>
<p><strong>自动启动应用程序</strong></p>
<p>关于自启动这个问题在国内比较蛋疼, 由于各种厂商对<code>ROM</code>的修改, 各式各样. 目前为我自己的实验是只有<code>Google Nexus4</code>可以直接声明<code>BOOT_complete</code>重启的广播, <code>魅族4</code>,<code>三星S6</code>都无法做到重启可以监听到重启广播. 需要对应用通过手机提供的应用管理, 把<code>自启动开启才可以达到预期的效果</code>. 这里尝试的做法是<code>注册监听重启广播的接收</code>, <code>添加权限&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;</code>, <code>添加&lt;manifest&gt;标签的内属性android:installLocation=&quot;internalOnly&quot;</code>确保应用正确安装到内存储位置.</p>
<p>广播的监听的对应action:<code>android.intent.action.BOOT_COMPLETED</code></p>
<p>还有一个应用程序包替换的时候的广播, 例如升级<code>android.intent.action.MY_PACKAGE_REPLACED</code></p>
<hr>
<p><strong>用户状态和屏幕状态</strong></p>
<p>虽然当按下关机键和锁屏键会触发屏幕熄灭, <code>Activity</code>会调用对应的焦点失去或者获取的回调. 但是如果服务<code>Service</code>需要注意此动作的时候, 我们通过屏幕的状态广播来监听这是很方便的.</p>
<p>相关广播<code>action</code></p>
<ul>
<li><code>action.intent.action.SCREEN_OFF</code></li>
<li><code>action.intent.action.SCREEN_ON</code></li>
<li><code>action.intent.action.SCREEN_PRESENT</code></li>
</ul>
<p>开启和关闭设备屏幕时, 系统会分别发送<code>Intent.ACTION_SCREEN_ON</code>和<code>Intent.ACTION_OFF</code>广播事件. 当用户解锁屏幕时系统会发送<code>Intent.ACTION_USER_PRESENT</code>广播事件.</p>
<hr>
<p><strong>网络和连接变化</strong></p>
<p>大多数<code>Android</code>设备都支持两种类型的网络: <strong>蜂窝网络</strong>和<strong>Wi-Fi网络</strong>. 如果应用程序过度依赖网络操作, 开发者可能要在蜂窝网络中推迟数据的传输, 知道设备连接到<code>Wi-Fi网络</code>; 否则, 如果使用<code>3G</code>, <code>LTE</code>之类的移动网络传输可能会产生相当可观的流量.</p>
<p>连接的相关广播和网络相关的广播分别由不同的API负责. 每当有通用的网络连接变化发生时, 比如从<code>Wi-Fi</code>切换到移动数据, 系统就会发送<code>ConnectivityManager.CONNECTIVITY_ACTION</code>广播, 接下来可以使用<code>Context.getService()</code>方法来检索<code>ConnectivityManager</code>服务, 它允许开发者获取当前网络的更多信息.</p>
<p>然而, 要获取当前网络更细粒度的信息, 开发者还需要监听来自<code>TelephonyManager</code>和<code>WifiManager</code>的广播事件. <code>TelephonyManager</code>允许查询移动数据连接的类型, <code>WiFiManager</code>允许检索<code>WiFi</code>连接状态并访问和<code>WiFi</code>相关的不同<code>ID(SSID是wifi名称和BSSID对应mac地址)</code></p>
<p>以下代码会检测设备是否连接到了预先设置的某一个<code>WiFi</code>. 使用此方法可以有效地和服务器或者只是支持特定的<code>Wi-Fi</code>的媒体进行通信.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 检查wifi广播--&gt;</div><div class="line">&lt;receiver</div><div class="line">  android:name=&quot;broadcast.CheckForHomeWifi&quot;&gt;</div><div class="line"></div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;!--监听wifi的连接状态是否连接上一个有效无线路由--&gt;</div><div class="line">      &lt;action android:name=&quot;android.net.wifi.WIFI_STATE_CHANGED&quot; /&gt;</div><div class="line">      &lt;!--监听wifi的打开和关闭, 和wifi具体的连接不关心--&gt;</div><div class="line">      &lt;action android:name=&quot;android.net.wifi.STATE_CHANGE&quot; /&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line"></div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p>如果只需要关心wifi的开启, 和wifi连接到某一个路由, 那么这两个广播监听足够了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onReceive(Context context, Intent intent) &#123;</div><div class="line"></div><div class="line">   // 需要判断的路由名字 对应ssid </div><div class="line">   String name = &quot;\&quot;ziroom502\&quot;&quot;;</div><div class="line"></div><div class="line">   // 1.首先判断wifi是否开启, 并连接</div><div class="line">   NetworkInfo networkInfo = intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);</div><div class="line">   if (networkInfo != null &amp;&amp; networkInfo.getState().equals(NetworkInfo.State.CONNECTED)) &#123;</div><div class="line"></div><div class="line">       // 2.再判断连接的wifi的具体信息</div><div class="line">       WifiInfo WifiInfo = intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);</div><div class="line">       if (WifiInfo != null &amp;&amp; name.equals(WifiInfo.getSSID())) &#123;</div><div class="line">           Log.d(&quot;sususu&quot;, &quot;连接到指定wifi&quot;);</div><div class="line">       &#125; else &#123;</div><div class="line">           Log.d(&quot;sususu&quot;, &quot;连接到其他wifi&quot;);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个简单的初步判断, 如果需要结合手机连接判断, 结合下面的另一个监听, 整合起来就差不多了.</p>
<hr>
<p>这个监听来自<code>ConnectivityManager</code>的变化, 并确定当前连接的是否为移动数据网络. 如果收到移动数据, 接下来在使用<code>TelephonyManager</code>检查是否在使用<code>3G</code>或者<code>LTE</code>网络.</p>
<p>监听广播的清单文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> &lt;!--判断手机连接--&gt;</div><div class="line">&lt;receiver</div><div class="line">  android:name=&quot;broadcast.WhenOn3GorLTE&quot;&gt;</div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;!--此广播监听, 网络连接的设置包括wifi和数据的打开和关闭--&gt;</div><div class="line">      &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class WhenOn3GorLTE extends BroadcastReceiver &#123;</div><div class="line">    private static final String TAG = WhenOn3GorLTE.class.getSimpleName();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line">        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action))&#123;</div><div class="line">            boolean noConnectivity = intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);</div><div class="line">            </div><div class="line">            if (noConnectivity)&#123;</div><div class="line">                Log.e(TAG, &quot;没有连接&quot; );</div><div class="line">            &#125;else&#123;</div><div class="line">                int networkType = intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_DUMMY);</div><div class="line">                </div><div class="line">                if (networkType == ConnectivityManager.TYPE_MOBILE)&#123;</div><div class="line">                    checkfor3GorLte(context);</div><div class="line">                &#125;else&#123;</div><div class="line">                    Log.i(TAG, &quot;不是移动连接&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     *  当前如果移动数据开启, 那么显示出移动数据的连接类型</div><div class="line">     */</div><div class="line">    private void checkfor3GorLte(Context context)&#123;</div><div class="line"></div><div class="line">        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</div><div class="line"></div><div class="line">        switch (telephonyManager.getNetworkType())&#123;</div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSDPA:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSDPA&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSPA:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSPA&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSPAP:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSPAP&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSUPA:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSUPA&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_LTE:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_LTE&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            default:</div><div class="line">                Log.d(TAG, &quot;连接类型: 未知类型, 可能传输速度会慢&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>此广播稍微有2秒左右延迟, 当wifi开关,和移动数据开关变化的时候不会立即响应</strong></p>
<p>一下记录一下测试的结果广播接收情况,以上判断条件是获取的<code>intent中的ConnectivityManager.EXTRA_NO_CONNECTIVITY</code>(测试手机三星S6), 可能会因为不同的条件产生不同的结果. 这里只说明代码中的条件说明:</p>
<ul>
<li><code>当wifi连接开启</code>: 这时打开或者关闭移动数据, 不会发送广播.</li>
<li><code>当移动数据开启</code>: 这时操作wifi开关会接收到两个广播.</li>
<li><ul>
<li>如果从<code>wifi关闭</code>-&gt;<code>wifi开启</code>那么首先会发送一个<code>移动数据的状态info广播</code>,紧接着会发送一个<code>wifi连接</code>相关的广播(总共两个有效连接)</li>
</ul>
</li>
<li><ul>
<li>如果<code>wifi开启</code> -&gt; <code>wifi关闭</code>那么首先会收到一个<code>无连接</code>的广播, 然后会接收到一个<code>移动数据</code>连接类型的广播.</li>
</ul>
</li>
<li><code>如果当都关闭的时候</code>: 开启任意一个只能接收到一个广播.</li>
</ul>
<p>这种方式也可以获取<code>wifi</code>连接的信息, 但是<strong>延迟性</strong>是这个方式的特点.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/" data-id="cj7hnifdw00176opj1wh47t2d" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap5_重识IPC" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/">《Android 编程实战》Chap5_重识IPC</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/">
            <time datetime="2017-09-11T23:54:53.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Binder简介"><a href="#Binder简介" class="headerlink" title="Binder简介"></a>Binder简介</h2><p><code>Android</code>有一个强大的功能, 就是能够在不同应用程序之间进行通信. 绝大部分的实现都是由<code>Binder IPC(Inter-Process Communication)</code>进行处理的.</p>
<p><code>Android</code>中的<code>Binder</code>有着悠久的历史. 最终它的名字叫做<code>OpenBinder</code>, 是Be公司开发的Be操作系统(BeOS). 后来被移植到<code>Android</code>平台, 并且进行了重写以支持应用程序间的IPC. 基本上<code>Binder</code>提供了在不同执行环境间绑定功能和数据的特性. <code>Binder</code>非常适合在<code>Android</code>应用程序间进行通信, 因为每个<code>Android</code>应用程序都运行在自己的<code>Dalvik</code>虚拟机里, 而每个虚拟机又是独立的运行环境.</p>
<blockquote>
<p>在2009年, <code>Linux</code>社区就谷歌选择<code>Binder</code>而非选择<code>dbus</code>的原因有过很长时间的争论, 因为在此之前<code>Linux</code>内核一直使用<code>dbus</code>来实现IPC机制. 最开始开发<code>Android</code>时, <code>Binder</code>成了IPC的最佳选择, 如今它已成为<code>Android</code>系统的一个组成成分. <code>Linux</code>中的<code>dbus</code>机制也用在许多的<code>Android</code>设备上, 特别是为无线接口层(Radio Interface Layer, RIL)通信以及<code>Android 4.3</code>以后的蓝牙通信. 但大部分IPC还是<code>Binder</code>.</p>
</blockquote>
<p>使用<code>Binder IPC</code>进行通信时, 两个应用程序使用内核驱动来传递消息(如下图), 除了发送消息, <code>Binder</code>还提供了其他功能, 比如识别远程调用者(进程ID和用户ID), 以及当远程进程被烧死(<code>link-to-death</code>)时发送通知.</p>
<p><img src="http://szysky.com/2016/09/28/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B05-%E9%87%8D%E8%AF%86-IPC/BinderIPC.png" alt="img"></p>
<p>例如, 当<code>系统Service</code>(通过WindowManager管理Android所有窗口)为每个应用保持一个<code>Binder</code>引用时会调用这些附加函数, 当应用窗口关闭时会收到link-to-death通知.</p>
<p><code>Binder</code>通信遵循<strong>客户端-服务端模式</strong>, 客户端使用客户端代理来处理与内核驱动程序的通信. 在服务器端, <code>Binder</code>框架维护了一系列<code>Binder线程</code>. 内核驱动会使用服务端的<code>Binder</code>线程把消息从客户端代理分发个接收对象. 这一点需要特别注意, 因为当通过Binder接收<code>Service</code>调用时, 他们并不会运行在应用程序的主线程上, 这样一来, 客户端连接远程Service的连接就不会阻塞应用的主线程.</p>
<h3 id="Binder地址"><a href="#Binder地址" class="headerlink" title="Binder地址"></a>Binder地址</h3><p>使用<code>Binder</code>通信时, 客户端需要知道远程<code>Binder</code>对象的地址. 然而, <code>Binder</code>的设计要求只有实现类(比如要调用的Service)才知道该地址. 开发者使用<code>Intent</code>解析来进行寻址. 客户端使用<code>action</code><br>字符串或者组件名(componentName)来构造<code>Intent</code>对象, 然后使用它初始化于远程应用程序的通信. <code>Intent</code>只是实际<code>Binder</code>地址的抽象描述, 为了能够建立通信, 还需要翻译成实际的地址.</p>
<p><code>ServiceManager</code>是一个特殊的<code>Binder</code>节点, 它运行在<code>Android</code>系统服务内, 管理所有的地址解析, 是唯一一个有全局地址的<code>Binder</code>节点. 因为所有的<code>Android组件</code>都是用<code>Binder</code>进行通信, 所以它们需要使用<code>ServiceManager</code>进行注册.</p>
<p>客户端要想和<code>Service</code>或者其他组件进行通信, 需隐式地通过<code>Intent</code>查询<code>ServiceManager</code>来接收<code>Binder</code>地址.</p>
<h3 id="Binder事务"><a href="#Binder事务" class="headerlink" title="Binder事务"></a>Binder事务</h3><p>在<code>Android</code>中, <strong>事务(transaction)</strong>是指一个进程发送数据到另一个进程. 在<code>Binder</code>上开启事务首先会在客户端调用<code>IBinder,transact()</code>, 然后<code>Service</code>收到<code>Binder.onTranscat()</code>方法回调.</p>
<p>如下演示了在客户端如何使用<code>IBinder</code>引用向服务端执行自定义的<code>Binder</code>事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public String performCustomBinderTransaction(IBinder binder, String arg0, int arg1) throws RemoteException &#123;</div><div class="line"></div><div class="line">   Parcel request = Parcel.obtain();</div><div class="line">   Parcel response = Parcel.obtain();</div><div class="line"></div><div class="line">   // 组装请求数据, 要发送到服务端的</div><div class="line">   request.writeString(arg0);</div><div class="line">   request.writeInt(arg1);</div><div class="line"></div><div class="line">   // 执行事务</div><div class="line">   binder.transact(IBinder.FIRST_CALL_TRANSACTION, request, response, 0);</div><div class="line"></div><div class="line">   // 从响应中读取结果</div><div class="line">   String result = response.readString();</div><div class="line"></div><div class="line">   // 释放资源, 以便循环利用</div><div class="line">   request.recycle();</div><div class="line">   response.recycle();</div><div class="line"></div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而服务端会实现一个继承<code>Binder</code>类, 通过<code>onTransact()</code>来接收客户端的数据, 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class ServerBinder extends Binder &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</div><div class="line">//        return super.onTransact(code, data, reply, flags);</div><div class="line"></div><div class="line">        // 开始读取客户端发送的请求数据</div><div class="line">        String arg0 = data.readString();</div><div class="line">        int arg1 = data.readInt();</div><div class="line"></div><div class="line">        // 处理接收结果, 并生成返回的数据</div><div class="line">        String result = buildResult(arg0, arg1);</div><div class="line"></div><div class="line">        // 把结果写入想用Parcel</div><div class="line">        reply.writeString(result);</div><div class="line"></div><div class="line">        // 成功后返回true</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String buildResult(String arg0, int arg1)&#123;</div><div class="line">        String result = null;</div><div class="line"></div><div class="line">        // ...这里省略业务逻辑, 以后可自行添加</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上, 因为属于作为远程服务端中实现自定义的<code>Binder</code>对象时没有使用<code>AIDL</code>. 所以这里需要自己处理<code>onTransact()</code>方法.</p>
<p>上面两个代码通过<code>Binder IPC</code>进行的同步双向调用. 也可在客户端执行单项的调用, 只需在客户端发送事务的方法进行相应更改即可, 如<code>IBinder.transact()</code>方法调用中把标识位设置为<code>FLAG_ONEWAY</code>, 这样就可以把第二个<code>Parcel</code>参数设置为null. 单项调用会提供更好的性能, 因为只需对一个<code>Parcel</code>对象进行编解码操作.</p>
<p>当然这里只是让其了解一下流程, 当真正实现进程间通信, 或者提供其他应用调用的API的时候不会直接操作这种底层的方式在两个程序之间执行事务, 而是使用对这种事务进行进一步封装的<code>AIDL</code>或者<code>Messenger</code>等.<br>而对于更细粒度地控制数据如何应用间发送, 使用底层binder操作事务这是正确的.</p>
<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p><code>Binder</code>事务通常会传递事务数据, 这种数据被称为<code>Parcel</code>(包裹).</p>
<p><code>Android</code>中的<code>Parcel</code>和<code>Java SE</code>中序列化对象类似, 不同之处在于, 开发者需要使用<code>Parcelable</code>接口实现对象的编解码工作. 该接口定义了两个编写<code>Parcel</code>对象的方法, 以及一个静态的不可被复写的<code>Creator</code>对象, 该对象用来从<code>Parcel</code>中读取相应的对象.</p>
<h3 id="link-to-death"><a href="#link-to-death" class="headerlink" title="link to death"></a>link to death</h3><p><code>Binder</code>的另一个特点, 允许客户端在<code>Service</code>终止的时候收到通知. 这就被称为<code>link to death</code>.</p>
<p><code>Binder</code>的<code>IBinder.linkToDeath()</code>方法实现了该机制. 当客户端在<code>onServiceConnected()</code>方法中收到<code>IBinder</code>对象, 它可以用实现了<code>IBinder.DeathRecipient</code>接口的参数调用<code>linkToDeath()</code>方法. 因为<code>Android</code>可能在资源不足的(RAM)时被系统杀死, 在客户端注册远程被终止的监听通知会很有用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> /*</div><div class="line">  * ClassDescription: 无实际意义, 只为演示如何使用IBinder注册link-to-death</div><div class="line">  */</div><div class="line">public class LinkToDeathSample extends Service &#123;</div><div class="line"></div><div class="line">    private static final String TAG = LinkToDeathSample.class.getSimpleName();</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     *  对客户端提供注册方法</div><div class="line">     */</div><div class="line">    private void notifyRemoteServiceDeath(IBinder iBinder )&#123;</div><div class="line">        try &#123;</div><div class="line">            iBinder.linkToDeath(new MyLinkToDeath(), 0);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class MyLinkToDeath implements IBinder.DeathRecipient&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void binderDied() &#123;</div><div class="line">            // 处理远端binder被杀死的情况</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以调用<code>IBinder.pingBinder()</code>检查远端的<code>Binder</code>进程是否处于活动状态. 如果结果为true, 表明远端的进程处于活跃可用的状态.</p>
<p>如果绑定到的是<code>Service</code>那么就不需要监听了, 因为断开连接时总会是伴随着<code>ServiceConnection.onServiceDisconnected()</code>函数被回调. 但是, 如果使用其他方式接受<code>Binder</code>对象, 该方法可能就有用处了.</p>
<h2 id="设计API"><a href="#设计API" class="headerlink" title="设计API"></a>设计API</h2><p>虽然大多数的应用都不需要为第三方应用提供API, 但是说不定哪一天领导就突发奇想的想要这个结果.</p>
<p>可以使用<code>Service</code>或者<code>ContentProvider</code>为第三方应用开发API. 这里先介绍使用<code>Service</code>提供API. 在后续的篇幅会展示如何使用<code>ContentProvider</code>. 当实现API是, 开发者还需要考虑的因素: 是否需要处理并发请求? 每次只处理一个客户端请求是否足够? API是否只包含一个或是很少的操作? 或者是一组更加复杂的方法? 这些问题的答案将决定实现远程API最合适的方法.</p>
<p>另一个问题考虑的细节是否与其他开发者分享该API? 或者只是用于自己的应用? 如果是第一种情况 , 可以考虑构建一个库工程, 使用易于使用的Java API包装客户端的实现. 如果只是自己使用API, 那么可以使用<code>Messenger</code>或者<code>AIDL</code>, 下面我们将针对这两个使用展开.</p>
<h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>在软件工程中, <strong>接口定义语言</strong>(Interface Definition Language,IDL)已经成为通用的术语. 是用来描述软件组件接口的特定语言. 在<code>Android</code>中, 该<code>IDL</code>被称为<code>Android接口定义语言(AIDL)</code>. 它是纯文本文件, 使用Java类似语法编写. 但是, 编写Java接口和编写AIDL文件还有所有不同:</p>
<ul>
<li>首先, 对所有的非原始数据类型参数, 需要指定如下三种类型方向指示符之一:<code>in</code>, <code>out</code>, <code>inout</code>.<code>in</code>类型方向指示符只用于输入, 客户端不会看到<code>Service</code>对对象的修改. <code>out</code>类型表明输入对象不包含相关的数据, 但会由<code>Service</code>生成相关的数据. <code>inout</code>类型是上面两种类型的结合. 切记只使用需要的类型, 因为每种类型都有相应的消耗.</li>
<li>所有用于通信的自定义都需要创建一个<code>AIDL</code>文件, 用来声明该类实现了<code>Parcelable</code>接口.</li>
</ul>
<p>整理一下步骤:</p>
<ol>
<li>首先创建<code>AIDL</code>文件, 为了客户端和服务端后续的使用. <a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/592cd9ef1db38fc768e5defe87be6bc7c50f1801" target="_blank" rel="external">参考链接</a> 注意: 在<code>IMyApiInterfaceV1.aidl</code>文件中对<code>CustomData</code>进行了手动的<code>import</code>导入, 并且当作为参数传递的时候使用了<strong>方向指示符</strong>,因为只有原始数据类型才不需要<strong>方向指示符</strong>,因只调用其值.(有一个<code>CustomData</code>在下次参考链接中可以看到, 应该属于这一个步骤的)</li>
<li>然后对客户端服务端进行代码实现. <a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/2aa6da78376f33ac4aa3ad2f386c388ade0d6e0c" target="_blank" rel="external">参考链接</a>. 现在客户端就可以利用<code>Binder</code>调用远程的服务实现的<code>IBinder</code>方法. <strong>注意:</strong>一旦客户端实现了代码, 那么就不要在修改或者移除AIDL文件中的方法. 可以在文件末尾添加新的方法, 因为AIDL编译器会为每一个方法生成标识符, 所以不能修改现存的方法, 否则不能向后兼容老版本. 这个方法使用AIDL的缺点就是如上. 解决方案中的一种方法就是提供Java包装类, 并以库工程或者.jar文件的形式发布一遍使用. 后续会说道.</li>
<li>现在可以考虑是否需要对客户端进行回调. 如果需要,那么相同的步骤创建<code>AIDL</code>接口文件. 并在客户端实现接口文件. 在服务端使用的<code>AIDL</code>文件中添加新的方法, 这个方法用来在服务端注册一个客户端回调. 客户端的回调通过方法的参数传入, 并在客户端获取远程服务端的<code>Binder</code>对象进行注册方法调用.<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/7e75d4d7b8aa27521952dac87b5fe3d951b5e5b1" target="_blank" rel="external">参考链接</a></li>
</ol>
<p>关于客户端实现AIDL文件的时候, 在使用了<code>oneway</code>关键字, 这会告诉AIDL编译器该接口只是单向通信. 对调用者(本类中的Service)的响应不是必须的. 这样做会轻微的性能提升. 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.szysky.note.ipc.aidl;</div><div class="line"></div><div class="line">import com.szysky.note.ipc.aidl.CustomData;</div><div class="line"></div><div class="line">oneway interface IMyAidlCallback &#123;</div><div class="line">  void onDataUpdated(in CustomData[] data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里, 说明了两个应用之间传输Binder对象, 而不需要使用<code>ServiceManager</code>注册它. 由于只有客户端和<code>Service</code>知道<code>Binder</code>的地址, 因此它可以作为一种高效的IPC安全机制.</p>
<h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>使用<code>Messenger</code>进行远程通信, 有时会更简单, 当然使用场景是<strong>Service不需要支持并发操作时就可以选择使用Messenger信使来跨进程通信</strong>. <code>Messenger</code>使用<code>Handler</code>执行每个传入的消息, 所有的客户端的调用按顺序运行在同一个线程上.</p>
<ul>
<li><strong>服务端的实现</strong>: 在<code>onCreate()</code>中构建<code>Messenger</code>, 然后在<code>onBind()</code>中返回<code>Binder</code>对象. 当<code>Messenger</code>接收到消息的时候, 它可以使用在<code>replyTo</code>成员变量里的Messenger对象响应客户端都请求.<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/8833697273dc9bb0cda6850d76c82b1ffcc2d47b" target="_blank" rel="external">参考链接</a></li>
<li><strong>客户端的实现</strong>: 为了可以在服务端响应回来数据, 在<code>onCreate()</code>方法中, 同样构建一个<code>Messenger</code>作为客户端的信使. 然后在<code>onResume()</code>进行服务绑定, 在<code>ServiceConnection#onServiceConnected()</code>回调中通过获取的<code>IBinder</code>来还原出服务端的<code>Messenger</code>. 然后就可以调用其<code>send(Message)</code>方法向远程发送消息. 当然参数中的<code>Message</code>需要新建一个. 如果要做到回应客户端那么使用<code>Message.replyTo=本地Messenger实例</code>, 这样就可以在客户端构建的Messenger时传入的<code>Handler.callback()</code>接收处理.<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/4b0f94b6a39a09e0a67784f8476ac839c13d1ed7" target="_blank" rel="external">参考链接</a></li>
</ul>
<p>这种方法和<code>IntentServiec</code>很相似, 但本例没有使用<code>Intent</code>, 而是使用<code>Message</code>触发<code>Handler</code>的操作. 此外, <code>Messenger</code>实现异步通信很方便, 并且也不需要使用<code>BroadcastReceiver</code>.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/" data-id="cj7hnife1001d6opjiaoxcjhq" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/glide/">glide</a></p>
                            <p class="item-title"><a href="/2017/09/20/android/github/glide解析5_图片变换/" class="title">Glide解析5_图片变换</a></p>
                            <p class="item-date"><time datetime="2017-09-20T08:53:48.000Z" itemprop="datePublished">2017-09-20</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/glide/">glide</a></p>
                            <p class="item-title"><a href="/2017/09/20/android/github/glide解析4_回调监听/" class="title">Glide解析4_回调监听</a></p>
                            <p class="item-date"><time datetime="2017-09-20T08:46:52.000Z" itemprop="datePublished">2017-09-20</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/09/20/android/github/glide解析3_缓存流程/" class="title"></a></p>
                            <p class="item-date"><time datetime="2017-09-20T08:42:24.000Z" itemprop="datePublished">2017-09-20</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2017/09/20/android/github/glide解析2_执行流程/" class="title"></a></p>
                            <p class="item-date"><time datetime="2017-09-20T08:40:45.000Z" itemprop="datePublished">2017-09-20</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/glide/">glide</a></p>
                            <p class="item-title"><a href="/2017/09/20/android/github/glide解析1_基本用法/" class="title">Glide解析1_基本用法</a></p>
                            <p class="item-date"><time datetime="2017-09-20T08:38:10.000Z" itemprop="datePublished">2017-09-20</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">41</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/android/code/">code</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/github/">github</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/glide/">glide</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android开发艺术探索》/">《Android开发艺术探索》</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android编程权威指南》/">《Android编程权威指南》</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/设计模式/">设计模式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/面试/">面试</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/learn/">learn</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/learn/《如何高效学习》/">《如何高效学习》</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/node/7days/">7days</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">51</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/analysis/">analysis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">36</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anslysis/">anslysis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/autoLink/">autoLink</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/">code</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/indicator/">indicator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learn/">learn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/share/">share</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/textview/">textview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/analysis/" style="font-size: 10px;">analysis</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/anslysis/" style="font-size: 10px;">anslysis</a> <a href="/tags/autoLink/" style="font-size: 10px;">autoLink</a> <a href="/tags/code/" style="font-size: 14.29px;">code</a> <a href="/tags/git/" style="font-size: 11.43px;">git</a> <a href="/tags/github/" style="font-size: 17.14px;">github</a> <a href="/tags/glide/" style="font-size: 12.86px;">glide</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/indicator/" style="font-size: 10px;">indicator</a> <a href="/tags/java/" style="font-size: 12.86px;">java</a> <a href="/tags/learn/" style="font-size: 10px;">learn</a> <a href="/tags/markdown/" style="font-size: 11.43px;">markdown</a> <a href="/tags/mysql/" style="font-size: 15.71px;">mysql</a> <a href="/tags/node/" style="font-size: 18.57px;">node</a> <a href="/tags/share/" style="font-size: 10px;">share</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/textview/" style="font-size: 10px;">textview</a> <a href="/tags/vim/" style="font-size: 11.43px;">vim</a> <a href="/tags/设计模式/" style="font-size: 11.43px;">设计模式</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2017 Ernest Chang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2142274"></script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>