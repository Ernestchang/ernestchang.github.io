<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>The Old Man and the Sea</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="All any predator can do is to keep on trying.">
<meta property="og:type" content="website">
<meta property="og:title" content="The Old Man and the Sea">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="The Old Man and the Sea">
<meta property="og:description" content="All any predator can do is to keep on trying.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Old Man and the Sea">
<meta name="twitter:description" content="All any predator can do is to keep on trying.">
    

    
        <link rel="alternate" href="/" title="The Old Man and the Sea" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">The Old Man and the Sea</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="https://ernestchang.github.io/2017/08/23/other/about/">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/uploads/images/avert.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="https://ernestchang.github.io/2017/08/23/other/about/">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/uploads/images/avert.png" />
            <h2 id="name">Ernest Chang</h2>
            <h3 id="title">Developer &amp; Designer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Hangzhou, China</span>
            <a id="follow" target="_blank" href="https://github.com/Ernestchang/">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                80
                <span>posts</span>
            </div>
            <div class="article-info-block">
                23
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Ernestchang/" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="twitter" class=tooltip>
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-git/git操作再识 拥抱开始" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/git/git操作再识 拥抱开始/">Git操作再识 拥抱开始</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/git/git操作再识 拥抱开始/">
            <time datetime="2017-09-12T00:02:04.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/git/">git</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/git/">git</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p><strong>Linux</strong></p>
<p><code>$ sudo yum install git</code></p>
<p>或者</p>
<p><code>$ sudo apt-get install git</code></p>
<p><strong>Mac</strong></p>
<p>直接在<code>Terminal</code>执行<code>git</code>命令, 如果没有会提示安装方法.</p>
<p>如果喜欢安装程序的话, <a href="http://git-scm.com/download/mac" target="_blank" rel="external">点这里</a></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>第一次安装, 千万别要忘了配置你的git的使用者名字和邮箱. 这个道理很简单, 每一次的提交时需要记录提交者的, 如果没有提交者, 那么bug出现找谁来背锅??</p>
<h3 id="查看config"><a href="#查看config" class="headerlink" title="查看config"></a>查看config</h3><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。</p>
<p><strong>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。</strong></p>
<p><code>$ git config --system --list</code></p>
<hr>
<p><strong>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。</strong></p>
<p><code>$ git config --global --list</code></p>
<hr>
<p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：针对该仓库。</p>
<p>每一个级别覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p>
<hr>
<p><strong>当然, 也可以查看某一项配置信息.</strong></p>
<ul>
<li>形式:<code>git config [--global|--system] &lt;key&gt;</code></li>
</ul>
<p><em>查看最终的配置属性值</em><br><code>$ git config user.name</code></p>
<p><em>查看当前系统的属性值</em><br><code>$ git config --global user.name</code></p>
<hr>
<h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><p><code>$ git config --global user.name &quot;name&quot;</code></p>
<p><code>$ git config --global user.email xxx@163.com</code></p>
<p>使用<code>--global</code>选项, 当以后在该系统上做的任何操作都会使用此属性. 如果你需要在某一个特定的项目使用其他名字和邮箱, 那么可以通过设置<strong>项目中的config文件</strong>, 这样config中的属性会覆盖掉<strong>global的全局属性</strong>, 并且当在其他项目中并不会造成影响. 使用方式只需要去掉<code>--global</code>参数即可修改项目中的<code>.git/config</code>文件</p>
<p><code>$ git config user.name &quot;name&quot;</code></p>
<hr>
<p><strong>获取帮助手册</strong></p>
<p>形式: <code>git help &lt;verb&gt;</code> 或者 <code>git &lt;verb&gt; --help</code></p>
<p>比如查看config手册</p>
<p><code>$ git help config</code></p>
<h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>例如: 生成别名之后可以在日后用简短的表示来使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.br branch</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure>
<h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><p>对于自动生成的文件, 日志, 编译的临时文件等. 可以对其进行配置, 让git不追踪这些文件</p>
<p>规范如下:</p>
<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反</li>
</ul>
<p><code>glob模式</code>是指shell所使用的简化了的正则表达式.</p>
<ul>
<li><code>*</code> :匹配零个或多个任意字符</li>
<li><code>[abc]</code> :只匹配括号内的任意一个字符</li>
<li><code>[0-9]</code> :使用短划线表示范围, 可以匹配0到9之间的任何字符.</li>
<li><code>?</code> :匹配任意一个字符</li>
<li><code>**</code>:匹配任意的中间目录,例如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>,<code>a/b/c/z</code>等</li>
</ul>
<p>如下给出一个样板:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 忽略所有以 .c结尾的文件</div><div class="line">*.c</div><div class="line"></div><div class="line"># 但是 stream.c 会被git追踪</div><div class="line">!stream.c</div><div class="line"></div><div class="line"># 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO</div><div class="line">/TODO</div><div class="line"></div><div class="line"># 忽略所有在build文件夹下的文件</div><div class="line">build/</div><div class="line"></div><div class="line"># 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt</div><div class="line">doc/*.txt</div><div class="line"></div><div class="line"># 忽略所有在doc目录下的.pdf文件</div><div class="line">doc/**/*.pdf</div></pre></td></tr></table></figure>
<h2 id="仓库的基础操作"><a href="#仓库的基础操作" class="headerlink" title="仓库的基础操作"></a>仓库的基础操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure>
<h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 添加全部暂存区和历史区不存在的或者有更改的 `.c`结尾的文件</div><div class="line">$ git add *.c </div><div class="line">  </div><div class="line"># 添加全部暂存区和历史区不存在的或者有更改的文件</div><div class="line">$ git add .  </div><div class="line"></div><div class="line"># 指定文件添加</div><div class="line">$ git add test.c</div></pre></td></tr></table></figure>
<hr>
<h3 id="status仓库"><a href="#status仓库" class="headerlink" title="status仓库"></a>status仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"></div><div class="line"># 如果需要显示一种紧凑式格式</div><div class="line">$ git status --short      # 等价于 $ git status -s</div></pre></td></tr></table></figure>
<p>紧凑式中字母的表示含义如下:</p>
<ul>
<li><code>??</code> :表示新添加的未追踪的文件</li>
<li><code>M</code> :M出现在右边,表示该文件被修改但是还没有放入暂存区</li>
<li><code>M</code> :M出现在左边,表示文件被修改已经放入了暂存区</li>
<li><code>MM</code> :出现两个,代表此文件在工作区修改已经放入了暂存区, 但之后有进行了修改,没有添加到暂存区</li>
</ul>
<hr>
<h3 id="diff仓库"><a href="#diff仓库" class="headerlink" title="diff仓库"></a>diff仓库</h3><p>如果你想知道文件具体修改的内容, 那么<code>diff</code>会很有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 查看以追踪但尚未暂存的文件更新了哪些部分, 不添加额外参数</div><div class="line">$ git diff</div><div class="line"></div><div class="line"># 对使用了add添加到了暂存区的内容, 使用--staged参数或者--cached</div><div class="line">$ git diff --staged</div></pre></td></tr></table></figure>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 常规做法</div><div class="line">$ git commit -m &quot;commit message&quot;</div><div class="line"></div><div class="line"># 如果不使用-m参数添加提交信息, git会使用默认的编译器如vi进行提交描述编写.</div><div class="line"># 可通过$ git config --global core.edit 设定喜欢的编译器</div><div class="line"></div><div class="line"># 跳过暂存区操作, 直接从工作区提交到历史区</div><div class="line">$ git commit -a -m &quot;&quot;          #等价于: $ git commit -am &quot;&quot;</div></pre></td></tr></table></figure>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>如果在工作区间对一个文件进行删除, 需要先进行<code>add</code>,然后才可以提交. 使用<code>git rm</code>可以直接在工作区间删除文件, 并提交到暂存区.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git rm fileName</div><div class="line"></div><div class="line"># 如果文件修改,并添加了暂存区, 需要使用-f参数来强制删除(force)</div><div class="line">$ git rm -f fileName</div><div class="line"></div><div class="line"># 可以使用glob模式,如下</div><div class="line">$ git rm log/\*.log         # 删除log目录下所有名称是.log结尾文件</div><div class="line">$ git rm \*~                # 删除以~结尾的所有文件</div></pre></td></tr></table></figure>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>同样使用<code>git rm</code>会方便很多, 并且如果相对文件重命名也可以如此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git mv file_from file_to</div></pre></td></tr></table></figure>
<p>当执行了这条语句之后, 只需要在下一次<code>commit</code>即可, 不需要考虑额外操作. 等价于如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv file_from file_to</div><div class="line">$ git rm file_from</div><div class="line">$ git rm file_to</div></pre></td></tr></table></figure>
<h3 id="查看历史提交"><a href="#查看历史提交" class="headerlink" title="查看历史提交"></a>查看历史提交</h3><p>如果是最基本的<code>git log</code>, 那么会按提交时间列出所有更新, 包括提交的SHA-1校验和, 作者名称,邮箱,提交时间,提交说明. 下面说说常用选项.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -p:仅显示最近x次的提交  格式 $ git log -p -x</div><div class="line">$ git log -p -2             # 查看最近的两次提交内容</div><div class="line"></div><div class="line"></div><div class="line"># --stat:简略的显示每次提交的内容更改, 如哪些文件变更,多少删除,多少添加等</div><div class="line">$ git log --stat</div><div class="line"></div><div class="line"># --pretty: 指定默认不同格式展示信息</div><div class="line">$ git log --pretty=oneline              #每次提交用一行显示</div><div class="line"></div><div class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;  </div><div class="line"># 效果:1a99c42 - 苏, 19 hours ago : 无意义提交</div></pre></td></tr></table></figure>
<p><strong>关于format对应的常用占位符的写法和意义</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%H</td>
<td>提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td>%h</td>
<td>提交对象的简短哈希字串</td>
</tr>
<tr>
<td>%T</td>
<td>树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td>%t</td>
<td>树对象的简短哈希字串</td>
</tr>
<tr>
<td>%P</td>
<td>父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td>%p</td>
<td>父对象的简短哈希字串</td>
</tr>
<tr>
<td>%an</td>
<td>作者（author）的名字</td>
</tr>
<tr>
<td>%ae</td>
<td>作者的电子邮件地址</td>
</tr>
<tr>
<td>%ad</td>
<td>作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td>%ar</td>
<td>作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%cn</td>
<td>提交者(committer)的名字</td>
</tr>
<tr>
<td>%ce</td>
<td>提交者的电子邮件地址</td>
</tr>
<tr>
<td>%cd</td>
<td>提交日期</td>
</tr>
<tr>
<td>%cr</td>
<td>提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%s</td>
<td>提交说明</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>图形展示分支的合并历史</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --oneline   #oneline只是让输出看起来比较舒服</div></pre></td></tr></table></figure>
<hr>
<p><strong>git log的一些其他操作</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td>–stat</td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td>–shortstat</td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td>–name-only</td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td>–name-status</td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td>–abbrev-commit</td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td>–relative-date</td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td>–graph</td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td>–pretty</td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<p><strong>查找一个字符串的出现和删除的提交</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 使用限制符-S后面紧跟要查询的字符串</div><div class="line">$ git log -Smethod_name</div><div class="line"></div><div class="line"># 或者针对一个文件进行更改的提交查询, 只需要在后面追加文件名称即可</div><div class="line">$ git log fileName</div></pre></td></tr></table></figure>
<p>哈哈,即使如果你不小心写个隐藏bug不管几个月之后,如果老大要想找出问题是写引发的其实很简单.例如这样<br><code>$ git log -p fileName</code> 想甩锅?算了吧,还是认错以后多注意吧.</p>
<p><strong>还有一些限制log输出的选项</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-(n)</td>
<td>仅显示最近的 n 条提交</td>
</tr>
<tr>
<td>–since, –after</td>
<td>仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td>–until, –before</td>
<td>仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td>–author</td>
<td>仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td>–committer</td>
<td>仅显示指定提交者相关的提交。</td>
</tr>
<tr>
<td>–grep</td>
<td>仅显示含指定关键字的提交</td>
</tr>
<tr>
<td>-S</td>
<td>仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<p>一个实际的例子，如果要查看 Git 仓库中，2016 年 11 月1号到7号，作者叫苏的提交文件，可以用下面的查询命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log --pretty=&quot;%h - %s&quot; --author=苏 --since=&quot;2016-11-01&quot; \</div><div class="line">   --before=&quot;2016-11-07&quot;</div></pre></td></tr></table></figure>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p><strong>amend重新提交</strong></p>
<p>当我们<code>commit</code>之后突然发现漏掉了一个文件, 这个时候不可能对一个文件再进行<code>commit</code>一次, 这样做就显得很多余, 而如果版本回退之前再添加也比较麻烦. 这个时候就可以使用这个<code>amend</code>命令.如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;版本1.5开发代码&quot;</div><div class="line"></div><div class="line"># 正当你松了一口气的时候发现配置文件忘记修改了, 你赶紧修改,并适合用add到暂存区</div><div class="line">$ git add project.property</div><div class="line">$ git commit --amend         </div><div class="line"># 你会神奇的发现你没有增加任何多余的操作就把漏掉的文件补齐到最后一次提交中</div></pre></td></tr></table></figure>
<hr>
<p><strong>取消暂存的文件</strong></p>
<p>就是对文件进行了<code>git add</code>操作. 这个时候可以<code>reset</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 让暂存区的文件变成文件修改但是没有添加暂存区的状态</div><div class="line">$ git reset HEAD fileName</div></pre></td></tr></table></figure>
<p><strong>撤销对文件的修改</strong></p>
<p>场景: 当文件修改了, 但是还没有进行<code>git add</code>的时候还只是在工作区间, 还原成最后一次提交的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- filename</div></pre></td></tr></table></figure>
<p>要注意使用, 使用之前确定是否要抛弃已经添加的内容. 因为这个动作可能让你最新添加的内容彻底丢失. 因为没有进行<code>commit</code>, 一般来说进行了<code>commit</code>的内容都是可以恢复的.</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote>
<p>Git可以给历史中的某一个提交打上标签, 以示重要. 比如每次正式版本的上线等.</p>
</blockquote>
<p><strong>列出标签</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line"></div><div class="line"># 如果你只关心某一部分的标签, 例如只对v2.x的标签感兴趣,你可以这样做</div><div class="line">$ git tag -l &apos;v2.*&apos;</div></pre></td></tr></table></figure>
<hr>
<p><strong>创建标签</strong></p>
<p>标签分为两种一种是<code>附加标签</code>另一种是<code>轻量标签</code>.</p>
<ul>
<li>附加标签: 会保存打标签者的信息, 时间和附加信息. 最后更随打标签的提交</li>
<li>轻量标签: 只是在一个提交上做一个标记. 存储在一个专门保存标签的文件,指向提交的hash值</li>
</ul>
<p>先来看附加标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.0 -m &apos;附加信息&apos;</div></pre></td></tr></table></figure>
<p>轻量标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v1.0</div></pre></td></tr></table></figure>
<p>后期打标签, 就是对已经提交某次提交进行追加标签设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 可以先使用git log --oneline获取提交历史的hash值</div><div class="line">$ git log --oneline</div><div class="line"></div><div class="line"># 然后把hash值赋值到标签语句之后</div><div class="line">$ git tag -a v1.1 a6b4c97</div></pre></td></tr></table></figure>
<p><strong>共享标签</strong></p>
<p>默认情况下, <code>git push</code>不会把标签传递到远程服务器. 需要显示的推送标签共享到服务器<br>例如: <code>git push origin [tagname]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin v1.4</div><div class="line"></div><div class="line"># 如果想把本地上所有在远程服务器上的不存在标签删除掉,可以这样</div><div class="line">$ git push origin --tags</div></pre></td></tr></table></figure>
<hr>
<p><strong>检出标签</strong></p>
<p>git中不能真正的检出一个标签, 但是可以在标签处创建一个新的分支.如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b checkbranch2 v2.0</div></pre></td></tr></table></figure>
<hr>
<p><strong>查看标签对应的信息</strong></p>
<p>使用<code>git show &lt;标签名&gt;</code>可以查看对应标签的详细信息, 如果<code>git show</code>这样的命令只是显示上次提交的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v1.4</div></pre></td></tr></table></figure>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="分支的创建"><a href="#分支的创建" class="headerlink" title="分支的创建"></a>分支的创建</h3><p>分支的创建, 其实本质就是创建一个可以移动的指针,这个指针名就是新的分支名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line"></div><div class="line"># 上面的只是创建了一个分支. 并没有切换, 可以使用一条命令创建并且换到新分支</div><div class="line">$ git checkout -b dev</div><div class="line"></div><div class="line"># 可以通过`git log`命令查看各个分支所指向的对象</div><div class="line">$ git log --oneline --decorate</div><div class="line"></div><div class="line"># 如果你想查看图形式的分叉历史,可以这样:</div><div class="line">$ git log --oneline --decorate --graph --all</div></pre></td></tr></table></figure>
<h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>所谓的分支切换就是<code>HEAD</code>指针的指向的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div></pre></td></tr></table></figure>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>利用<code>git merge &lt;要合并到的目标分支&gt;</code>, 这条命令会把当前所在分支与目标分支的内容合并, 可以这样理解, 如果当你试图向目标分支合并时, 如果当前分支可以顺着一个分支走下去, 那么本质上其实只是当前指针的向前移动, 由于这种情况下的合并并没有需要解决的分期, 所以git会称这个是<code>fast-forward</code>快速前进.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge dev</div></pre></td></tr></table></figure>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当一个功能分支开发完毕之后, 并进行了合并, 通常这个分支也就被删除,以保证仓库中的干净.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 删除dev分支</div><div class="line">$ git branch -d dev</div><div class="line"></div><div class="line"># 如果dev分支还有未提交的内容,为了保证你的数据安全git默认是不允许删除,可以使用`-D`强制删除</div><div class="line">$ git branch -D dev</div></pre></td></tr></table></figure>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>git branch</code>命令不只是可以创建于删除分支. 如果不添加任何参数, 那么会得到所有分支的一个列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git branch        # 其中一个分支前面的*代表,目前检出的分支就是HEAD指针所指向的分支</div><div class="line"></div><div class="line"># 追加-v参数 可以展示每一个分支最后一次提交</div><div class="line">$ git branch -v</div><div class="line"></div><div class="line"># --merged:查看那些分支已经合并到当前分支</div><div class="line">$ git branch --merged        # 一般这个列表展示的除了*号的其他分支, 都可以删除</div><div class="line"></div><div class="line"># --no-merged:查看所有包含未合并工作的分支</div><div class="line">$ git branch --no-merged</div></pre></td></tr></table></figure>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><blockquote>
<p>和合并<code>merge</code>相似的效果都是合并分支, 但是使用变基<code>rebase</code>可以让提交历史变得更简洁. 如下</p>
</blockquote>
<p><img src="http://szysky.com/2016/11/01/Git%E5%86%8D%E8%AF%86-%E4%B8%80-%E6%8B%A5%E6%8A%B1%E5%BC%80%E5%A7%8B/rebase_1.png" alt="img"></p>
<p><img src="http://szysky.com/2016/11/01/Git%E5%86%8D%E8%AF%86-%E4%B8%80-%E6%8B%A5%E6%8A%B1%E5%BC%80%E5%A7%8B/rebase_2.png" alt="img"></p>
<p>图片1是<code>merge</code>合并效果, 图片2是<code>rebase</code>合并效果. 明显变基会让提交历史看起来更加干净. 使用如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># rebase &lt;目标分支名&gt; [需要移动变基底的分支]</div><div class="line">$ git rebase master experiment </div><div class="line"> </div><div class="line"># 此时目标分支后面会追加另一个分支的提交. 此时只需要切换到master分支,合并分支即可.</div><div class="line">$ git checkout master</div><div class="line">$ git merge experiment</div></pre></td></tr></table></figure>
<p><code>rebase</code>原理就是, 从目标分支和要变基的分支向上查找出共同祖先节点就是<code>c2</code>, 然后把要变基的分支到<code>c2</code>节点的所有提交,提取出相应的修改生成一个副本, 并追加到目标分创建相对应的提交. 此时变基的分支指向<code>目标分支master</code>的后面某一次提交. 此时只要使用修改<code>master</code>指向指针使用<code>merge</code>即可.</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 获得远程的仓库列表</div><div class="line">$ git ls-remote origin</div><div class="line"></div><div class="line"># 如果想获得更多的信息</div><div class="line">$ git remote show origin</div><div class="line"></div><div class="line"># 查看远程分支和本地分支</div><div class="line">$ git branch -a</div></pre></td></tr></table></figure>
<hr>
<p><strong>拉取远程分支</strong></p>
<p>假设远程如果有一个<code>dev</code>分支, 你使用<code>fetch</code>进行抓取. 这个时候, 本地不会自动生成一个可编辑的副本, 换句话说就是这种情况下, 不会有一个新的<code>dev</code>本地分支, 只有一个不可以修改的<code>origin/dev</code>指针. 这个时候可以运行<code>git merge origin/dev</code>命令, 将这些远程dev分支的工作合并到当前分支. 如果想要在自己本地的dev分支上工作, 可以将其建立在远程分支之上.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>创建远程分支</strong></p>
<p>如果你的本地有一个新建的<code>dev</code>分支, 并且你进行了提交, 此时你想把这个分支也提交到远程的<code>dev</code>分支, 但是远程还没有创建<code>dev</code>, 这个时候可以使用如下命令: <code>git push &lt;远程仓库名&gt; &lt;要推送的本地分支&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>删除远程分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 删除远程dev分支</div><div class="line">$ git push origin --delete dev</div></pre></td></tr></table></figure>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 <code>跟踪分支</code>（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入<code>git pull</code>，<code>Git</code> 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 <code>master</code> 分支。 最简单的就是之前看到的例子，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/dev</div><div class="line"></div><div class="line"># 如果想要自定义本地分支名字</div><div class="line">$ git checkout -b 任意分支名字 origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支</strong>，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 设置HEAD指向的分支的上游为远程dev分支</div><div class="line">$ git branch -u origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>查看设置的所有跟踪分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -vv</div></pre></td></tr></table></figure>
<h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git clone &lt;url&gt;</div><div class="line"></div><div class="line"># 如果你想创建自己的仓库名, 就是本地根文件夹的名称, 那么可以如下追加名称</div><div class="line">$ git clone &lt;url&gt; [dirName]</div></pre></td></tr></table></figure>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 默认查看远程仓库的方式</div><div class="line">$ git remote </div><div class="line"></div><div class="line"># 查看远程仓库的读写权限. 如果可以看到(push)说明提交的推送</div><div class="line">$ git remote -v</div></pre></td></tr></table></figure>
<p>如果需要查看某一个仓库更多的信息时, 使用<code>git remote show ...</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote show origin</div></pre></td></tr></table></figure>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 格式: git remote add [shortName] &lt;url&gt;  同时可以指定一个仓库的引用名称,例如</div><div class="line">$ git remote add rp git@github.com:suzeyu1992/GitOperateDemo.git</div><div class="line"></div><div class="line"># 此时你想对新加的远程进行拉取动作, 只需要使用之前的引用名称就可以</div><div class="line">$ git fetch rp</div></pre></td></tr></table></figure>
<h3 id="远程仓库的拉取推送"><a href="#远程仓库的拉取推送" class="headerlink" title="远程仓库的拉取推送"></a>远程仓库的拉取推送</h3><p><strong>拉取</strong></p>
<p>大家常用的可能是<code>git pull</code>这个指令. 这个指令的通常会从服务器上抓取数据自动尝试合并到当前所在分支.</p>
<p>而我们可以也可以利用<code>git fetch</code>进行本地分支所追踪的远程分支没有提交. 然后我们可以手动的进行合并.</p>
<p><strong>推送</strong></p>
<p><code>git push [remote-name] [branch-name]</code> 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>只有当对服务器有写入权限, 并且之前没有人提交, 这条命令才会生效.</p>
<p>上面的这两个推送也好拉取也好. 如果所在分支设置了远程服务器分支的追踪, 那么可以省略掉后面的仓库名和分支名. 如果没有设置那么必须显示的指定.</p>
<h3 id="远程仓库移除重命名"><a href="#远程仓库移除重命名" class="headerlink" title="远程仓库移除重命名"></a>远程仓库移除重命名</h3><p>对远程仓库的名称进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rename oldName newName</div></pre></td></tr></table></figure>
<p>想要移除一个远程仓库,例如服务器搬走了,不再使用一个特定镜像,或者一个贡献者不再贡献</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rm 仓库名</div></pre></td></tr></table></figure>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/git/git操作再识 拥抱开始/" data-id="cj7sum2vn0000wapjx5pq2h2v" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/git/git操作再识 拥抱开始/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap12_远程设备其余通信方式" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/">《Android 编程实战》Chap12_远程设备其余通信方式</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/">
            <time datetime="2017-09-12T00:00:31.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android中的连接技术"><a href="#Android中的连接技术" class="headerlink" title="Android中的连接技术"></a>Android中的连接技术</h2><p>大多数<code>Android</code>设备都支持多种连接技术. 通常, 例如<code>USB</code>, <code>蓝牙</code>, <code>Wi-Fi</code>.</p>
<ul>
<li><code>USB</code> 使用API通过USB进行原始串行通信, 或者使用谷歌专门为访问Android设备硬件配件定义的Android开放配件协议(Android Open Accessory Protocol, AOAP). AOAP是通过配件开发套件(Accessory Development Kit, ADK)支持的.</li>
<li><code>Bluetooth</code> Android设备都支持经典蓝牙配置文件(Classic Bluetooth Protocol), 它适合更耗电的操作, 比如视频流. <code>Android 4.3</code>开始支持蓝牙低功耗以及蓝牙智能(Bluetooth Smart)技术, 它能够和支持GATT配置的设备进行通信(如心脏检测器,计步器以及其他低功率配件)</li>
<li><code>Wi-Fi</code> 比如需要更多数据密集型通信的场景, <code>Android</code>支持三种Wi-Fi操作模式: <code>infrastructure(连接到一个接入点的的标准wifi)</code>, <code>网络共享(android设备充当其他设备wifi的接入点)</code>, <code>WiFi-Direct</code>这个模式比较有趣, 在一些新的设备可以和<code>infrastructure</code>模式进行并行工作. 允许应用程序建立对等的wifi网络, 而不需要专门的访问点.</li>
</ul>
<h2 id="Android-USB"><a href="#Android-USB" class="headerlink" title="Android USB"></a>Android USB</h2><p>Android中<code>USB</code>相关的API位于<code>android.hardware.usb</code>包. 如果需要usb外设的了解可以查看官网文档的usb/accessory相关介绍.</p>
<p>在<code>USB</code>的设计中, 会有一个设备充当<strong>主机</strong>. 除了其他功能, 主机还可以给所连接的设备供电, 这就是不需要给USB鼠标添加额外的电池, 以及可以使用笔记本上的USB端口给智能手机充电的原因.</p>
<p><code>Android设备</code>也可以作为USB主机为外部设备充电, 这意味着可以把例如读卡器,指纹扫描,以及其他usb外设连接到手机设备上.</p>
<p>了解一下就好了如果需要更多, <a href="https://developer.android.com/guide/topics/connectivity/usb/index.html" target="_blank" rel="external">参考资料</a></p>
<h2 id="蓝牙低功耗"><a href="#蓝牙低功耗" class="headerlink" title="蓝牙低功耗"></a>蓝牙低功耗</h2><p>在<code>Android 4.3</code>开始支持蓝牙智能, 包括心率监视器, 活动跟踪器等蓝牙低功耗<code>BLE</code>设备的支持.</p>
<p>如果需要<code>蓝牙低功耗</code>比较感兴趣, 可以查看<a href="http://szysky.com/2016/10/08/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B12-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">博客的android蓝牙系列</a></p>
<h2 id="Android-Wi-Fi"><a href="#Android-Wi-Fi" class="headerlink" title="Android Wi-Fi"></a>Android Wi-Fi</h2><p><code>Wi-Fi</code>是Wi-Fi联盟管理的各种技术的统称. <code>Wi-Fi Direct</code>是运行在802.11n标准之上的额外技术. 使用该技术的设备不需要专门的连接点, 这点和蓝牙很相似, 不过<code>Wi-Fi Direct</code>使用高速的<code>Wi-Fi</code>进行通信.</p>
<p>但是, 即使设备都不再同一个<code>Wi-Fi</code>, 为了建立连接仍然需要发现它们. 发现意味着找到运行服务的设备的ip地址. Android已经内置了网络发现API, 支持标准的<code>Wi-Fi(infrastructure)和Wi-Fi Direct</code>, 可以让设备发现使用<code>DNS-SD</code>协议声明的服务.</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Android提供了标准的发现机制, 允许开发者宣布自己的服务以及发现本地网络上的服务. 该实现包括两个标准: <code>mDNS和DNS-SD</code>. <code>mDNS</code>是一个多播协议, 使用UDP组播协议宣布和发现主机. <code>DNS-SD</code>是一个服务发现协议, 用于宣布和发现运行在远程主机(通常限于本地网络)的服务. 可以通过<code>android.net.nsd</code>包以及<code>NsdManager</code>使用这些功能.</p>
<p>以下代码可以来声明一个设备中的服务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  声明设备中标准Wi-Fi的服务</div><div class="line">*/</div><div class="line">private void announceService()&#123;</div><div class="line">   NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">   NsdServiceInfo nsdServiceInfo = new NsdServiceInfo();</div><div class="line">   nsdServiceInfo.setPort(8081);</div><div class="line">   nsdServiceInfo.setServiceName(&quot;wifi服务哦&quot;);</div><div class="line">   nsdServiceInfo.setServiceType(&quot;_http._tcp.&quot;);</div><div class="line"></div><div class="line">   nsdManager.registerService(nsdServiceInfo, NsdManager.PROTOCOL_DNS_SD, new NsdManager.RegistrationListener() &#123;</div><div class="line">       @Override</div><div class="line">       public void onRegistrationFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line">           Log.e(TAG, &quot;onRegistrationFailed: &quot; );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onUnregistrationFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line">           Log.e(TAG, &quot;onUnregistrationFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceRegistered(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.e(TAG, &quot;onServiceRegistered: &quot; );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceUnregistered(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.e(TAG, &quot;onServiceUnregistered: &quot; );</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Note: 如果不给设置服务名, 那么会使用wifi网络中的设备IP地址. mDNS的服务类型必须是一个有效的类型. 再调用了注册方法后, <code>NsdManager</code>开始宣布在本地<code>Wi-Fi</code>上的服务, 当注册状态发生变化后会触发监听回调.</p>
<p>如果要发现一个服务, 使用同样的API实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  发现一个服务</div><div class="line">*/</div><div class="line">private void discoverService()&#123;</div><div class="line">   NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">   nsdManager.discoverServices(&quot;_http._tcp.&quot;, NsdManager.PROTOCOL_DNS_SD, new NsdManager.DiscoveryListener() &#123;</div><div class="line">       @Override</div><div class="line">       public void onStartDiscoveryFailed(String serviceType, int errorCode) &#123;</div><div class="line">           Log.d(TAG, &quot;onStartDiscoveryFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onStopDiscoveryFailed(String serviceType, int errorCode) &#123;</div><div class="line">           Log.d(TAG, &quot;onStopDiscoveryFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onDiscoveryStarted(String serviceType) &#123;</div><div class="line">           Log.d(TAG, &quot;onDiscoveryStarted: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onDiscoveryStopped(String serviceType) &#123;</div><div class="line">           Log.d(TAG, &quot;onDiscoveryStopped: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceFound(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.d(TAG, &quot;onServiceFound&quot;);</div><div class="line">           NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">           nsdManager.resolveService(serviceInfo, new NsdManager.ResolveListener() &#123;</div><div class="line">               @Override</div><div class="line">               public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">               @Override</div><div class="line">               public void onServiceResolved(NsdServiceInfo serviceInfo) &#123;</div><div class="line">                   Log.w(TAG, &quot;主机: &quot;+serviceInfo.getHost() +&quot;      端口:&quot;+serviceInfo.getPort() );</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceLost(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.d(TAG, &quot;onServiceLost: &quot;);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 需要使用服务类型来搜索服务, 一旦服务的状态发生变化(发现和丢失某些东西, 启动和停止发现服务)都会收到回调. 如果需要解析更详细的信息, 通过<code>NsdManager#resolverService()</code>方法来解析. 解析成功会回调函数.</p>
<p>通过<code>NsdManager</code>使用网络发现服务可以在不强制用户手动输入IP地址的情况下和本地设备进行通信. 当要创建共享数据的应用或者建立一个本地多人游戏时, 这是一个选择项.</p>
<h3 id="Wi-Fi-Direct"><a href="#Wi-Fi-Direct" class="headerlink" title="Wi-Fi Direct"></a>Wi-Fi Direct</h3><p><code>Wi-Fi Direct</code>是Wi-Fi联盟802.11标准的一部分, 允许在设备间进行高速的Wi-Fi通信, 而不需要专门的接入点. 它基本上是一个采用Wi-Fi技术的对等协议. 所有运行2.3及后续版本的设备都支持<code>Wi-Fi Direct</code>, 但是知道<code>Android 4.1</code>以及网络服务发现API的引入, 开发人员才真正对<code>Wi-Fi Direct</code>变得感兴趣.</p>
<p>在运行<code>Android 4.0</code>或更高的版本的设备上, 通常可以并行地运行<code>Wi-Fi Direct</code>, 这意味着设备可以同时支持<code>Wi-Fi Direct</code>以及普通的<code>Wi-Fi</code>.</p>
<p>主要API<code>WifiP2pManager</code> 来在一端设备创建并发布服务并监听变化, 另一端通过监听对等的设备并使用<code>WifiP2pServiceRequest</code>来搜索, 当搜索到可用符合的设备进行连接. 当两个设备建立连接, 服务端的注册的广播就会接收到通知. 并进行后续操作处理.</p>
<p>使用<code>WiFi Direct</code>最主要的原因是不需要现有的WIFI基础设施. 同时, 由于建立过程不需要额外的PIN码或者密码, 使用这种方式连接设备会很容易.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/" data-id="cj7hnifdv00146opje8f2zhjj" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap11_网络 Web服务" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/">《Android 编程实战》Chap11_网络 Web服务</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/">
            <time datetime="2017-09-11T23:59:43.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android上的网络调用"><a href="#Android上的网络调用" class="headerlink" title="Android上的网络调用"></a>Android上的网络调用</h2><p>虽然<code>Android</code>同时支持<code>TCP</code>和<code>UDP</code>通信, 但应用程序的大部分网络调用都是建立在<code>TCP</code>之上的<code>HTTP</code>请求完成的.</p>
<p>网络操作的两个比较重要的规则:</p>
<ol>
<li>永远不要在主线程做耗时操作</li>
<li>在<code>Service</code>而不是<code>Activity</code>中执行网络操作. 因为有很多情况下, 在<code>Activity</code>中执行网络操作, 很多时候需要考虑<code>Activity</code>快速切换的状态. 比如用户按了主屏幕键, 然后1秒后又回到了应用程序.</li>
</ol>
<h3 id="HttpUrlConnection"><a href="#HttpUrlConnection" class="headerlink" title="HttpUrlConnection"></a>HttpUrlConnection</h3><p><code>Android</code>提供了两个用于<code>HTTP</code>通信的API. <code>Apache</code>的<code>HttpClient</code>和<code>HttpUrlConnection</code>. 两者都能提供相同的功能. 但是推荐<code>HttpUrlConnection</code>, 因为谷歌一直在对其维护. 比如透明的响应压缩, 响应缓存.</p>
<p><code>Android 4.0(ICS)</code>提供响应缓存功能, 所以如果要支持早期的版本, 开发者需要使用手动实现通过反射来初始化缓存. 如果应用最低支持4.0, 那么使用以下代码开启.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpResponseCache httpResponseCache = HttpResponseCache.install(new File(getCacheDir, &quot;http&quot;), CACHE_SIZE);</div></pre></td></tr></table></figure>
<p>为应用选择一个合适的缓存大小. 如果只获取少量的数据, 可以选择几兆大小的缓存. 缓存对应用程序是私有的, 所以相对来说是比较安全的.</p>
<p>比如说<code>HTTP GET</code>请求, <a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/blob/0d16eb99528aa7ed7bfc238e881222879ab7d95f/Network/app/src/main/java/com/szysky/note/network/HTTPGet.java" target="_blank" rel="external">可以看事例代码</a></p>
<p><strong>或者说上传文件</strong></p>
<p>比如说传送图片或者其他文件到服务器, 由于Java API并没有提供一个可以直接上传文件的的方法. 使用HTTP发送数据涉及使用<code>HTTP POST</code>发送<code>body</code>中的数据. 而body需要设置一些特殊的格式, 并且还要正确地设置<code>header</code>字段. 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">private static final long MAX_FIXED_SIZE = 5 * 1024 * 1024;</div><div class="line">private static final String CRLF = &quot;\r\n&quot;;</div><div class="line">/**</div><div class="line">*  使用HTTP POST往服务器发送文件</div><div class="line">*/</div><div class="line">public int postFileToURL(File file, String mimeType, URL url) throws IOException &#123;</div><div class="line"></div><div class="line">   DataOutputStream requestData = null;</div><div class="line">   try &#123;</div><div class="line">       long fileSize = file.length();</div><div class="line">       String fileName = file.getName();</div><div class="line"></div><div class="line">       // 创建一个随机边界符字符串</div><div class="line">       Random random = new Random();</div><div class="line">       byte[] randomBytes = new byte[16];</div><div class="line">       random.nextBytes(randomBytes);</div><div class="line">       String boundary = Base64.encodeToString(randomBytes, Base64.NO_WRAP);</div><div class="line"></div><div class="line">       // 配置请求设置</div><div class="line">       HttpURLConnection uc = (HttpURLConnection) url.openConnection();</div><div class="line">       uc.setUseCaches(false);</div><div class="line">       uc.setDoOutput(true);           // 设置可以发送数据</div><div class="line">       uc.setRequestMethod(&quot;POST&quot;);</div><div class="line"></div><div class="line">       // 设置HTTP header</div><div class="line">       uc.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</div><div class="line">       uc.setRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</div><div class="line">       uc.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data;boundary=&quot;+boundary);</div><div class="line"></div><div class="line">       // 如果文件大于max_fixed_size, 使用分块流模式</div><div class="line">       if (fileSize &gt; MAX_FIXED_SIZE)&#123;</div><div class="line">           uc.setChunkedStreamingMode(0);</div><div class="line">       &#125;else&#123;</div><div class="line">           uc.setFixedLengthStreamingMode((int)fileSize);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // 打开文件方便读取</div><div class="line">       FileInputStream fileIn = new FileInputStream(file);</div><div class="line">       // 打开服务器连接</div><div class="line">       OutputStream out = uc.getOutputStream();</div><div class="line">       requestData = new DataOutputStream(out);</div><div class="line"></div><div class="line">       // 开始写数据</div><div class="line">       // 首先写入第一个边界符</div><div class="line">       requestData.writeBytes(&quot;--&quot; +boundary + CRLF);</div><div class="line">       // 让服务器知道文件名</div><div class="line">       requestData.writeBytes(&quot;Content-Disposition: form-data; name=\&quot;&quot;+ fileName + &quot;\&quot;; filename=\&quot;&quot;+fileName + CRLF);</div><div class="line">       // 文件的MIME类型</div><div class="line">       requestData.writeBytes(&quot;Content-Type: &quot;+mimeType + CRLF);</div><div class="line"></div><div class="line">       // 循环读取本地文件, 并写入服务器</div><div class="line">       int bytesRead;</div><div class="line">       byte[] buffer = new byte[8 * 1024];</div><div class="line">       while((bytesRead = fileIn.read(buffer)) != -1)&#123;</div><div class="line">           requestData.write(buffer, 0, bytesRead);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // 写入边界字符串, 表明已到文件结尾</div><div class="line">       requestData.writeBytes(CRLF);</div><div class="line">       requestData.writeBytes(&quot;--&quot; +boundary +&quot;--&quot;+ CRLF);</div><div class="line">       requestData.flush();</div><div class="line"></div><div class="line">       return uc.getResponseCode();</div><div class="line"></div><div class="line">   &#125; catch (IOException e) &#123;</div><div class="line">       e.printStackTrace();</div><div class="line">   &#125;finally &#123;</div><div class="line">       if (requestData != null)&#123;</div><div class="line">           requestData.close();</div><div class="line">       &#125;</div><div class="line">       return -1;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码, 需要要知道如何使用边界字符串告诉服务器文件的开始和结束位置. 另外上面还通过检查文件的大小而决定是<code>使用分块流模式(chunked streaming mode)</code>,还是<code>使用固定长度流模式</code> . 对于<code>分块流模式</code>参数0表示系统的默认大小, 这是大多数程序在该模式下的大小. 分块基本上意味着数据分部分发送数据, 每一部分都附有该块大小. 分块能更有效地使用内存, 并较少oom异常的分享, 然而, 使用固定长度的数据流模式通常更快, 但它需要更多的内存.</p>
<h3 id="OkHttp和SPDY"><a href="#OkHttp和SPDY" class="headerlink" title="OkHttp和SPDY"></a>OkHttp和SPDY</h3><p><code>HTTP</code>的一个大问题就是每个连接只允许一个请求和响应, 这迫使浏览器和其他客户端为了并行请求必须生成多个<code>套接字socket</code>连接. 虽然对于客户端连接问题就不那么大了, 但是如果是服务器端那么面临的状态就不同而语了. 在2009年, 谷歌开始着手更新<code>HTTP协议</code>来解决这些问题. 其结果就是<code>SPDY协议</code>, 它允许在一个套接字连接上发送多个<code>HTTP请求</code>. 该协议已成为下一代<code>HTTP</code>事实上的开放标准, 但它不会取代<code>HTTP</code>, 而是改良了如何通过网络请求和响应. 而<code>HTTP IETF</code>工作组日前已宣布即将开始<code>HTTP 2.0</code>的工作, 并使用<code>SPDY协议</code>作为起点.</p>
<p>如果同时开始客户端和服务端代码, 研究一下使用<code>SPDY</code>来代替常规的<code>HTTP/1.1</code>还是不错的, 因为<code>SPDY</code>能显著降低网络负载, 并能提高性能. 主流浏览器目前已经很好地支持<code>SPDY</code>, 并且已经有很多平台的实现版本, 启动就包括<code>Android</code>.</p>
<p>如果选择<code>SPDY</code>作为通信协议, 建议使用<code>OkHttp</code>, 它是<code>Square</code>公司开发的, 该库只是一个支持<code>SPDY</code>的新改进的<code>HTTP</code>客户端. 内部使用<code>HttpUrlConnection</code>接口.</p>
<p>当初始化<code>OkHttpClient</code>实例时, 它会初始化所有的东西, 比如连接池和响应缓存. 即使是普通的HTTP请求, 该实现也非常快, 使用OkHttp进行SPDY通信能显著提升网络调用的性能.</p>
<h3 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h3><p>运行标准的HTTP之上, 是HTTP的扩展. <code>Web Socket</code>允许在客户端和服务器端之前进行基于消息的异步通信. 首先客户端发送一个常规的<code>HTTP GET</code>请求, 该请求包含特殊的<code>HTTP请求头</code>, 表明客户端希望把连接升级为<code>Web Socket</code>连接.</p>
<p>如下当使用<code>Web Socket</code>时,客户端发送的请求示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /websocket HTTP/1.1</div><div class="line">Host: myserver.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: xxxxxxxxxxxxxxxxxx==</div><div class="line">Sec-WebSocket-Protocol: chat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://myserver.com</div></pre></td></tr></table></figure>
<p>如果接收客户端的请求, 下面是服务器对请求的响应:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: xxxxxxxxxxxxxxxxxxx=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<blockquote>
<p>客户端的请求头中的值并不是对每一种情况都有效, 而应根据Web Socket协议规范来计算. 通常情况下, 如果使用现成的<code>Web Socket</code>通信库, 开发者就不需要考虑这些情况.</p>
</blockquote>
<p>当<code>Web socket</code>连接建立后, 双方可以给对方发送异步消息. 通信的消息可以是文本, 或者二进制, 通常数据量是很小的. 如果需要传输大的文件, 最好还是使用标准的<code>Http</code>. <code>Web socket</code>用于发送符合相对较小的通知.</p>
<p>关于使用, 可以使用<code>Android</code>中标准的<code>Socket</code>类来实现自己的<code>Web Socket</code>客户端, 但也可以使用现有的第三方库. 比如由<code>Nathan Rajlich</code>为Java实现的WebSocket. 可以看<a href="http://java-websocket.org/" target="_blank" rel="external">介绍</a>. 另外, 这个库还包含了一个服务器的实现.</p>
<h2 id="网络和功耗"><a href="#网络和功耗" class="headerlink" title="网络和功耗"></a>网络和功耗</h2><p>手机功耗, 一般手机中消耗第一应该是屏幕, 然后第二往往和网络流量有关.</p>
<p>智能手机的无线硬件如WiFi和蜂窝网络芯片都有内置省电功能, 他们能在网络流量不活跃时自动关闭连接, 并能把功耗降到一个非常低的水平. 当应用程序要发送数据或者等待接收输入数据和包时, 网络硬件将禁用省电模式, 以便能尽可能快速和有效地发送数据.</p>
<h3 id="一般准则"><a href="#一般准则" class="headerlink" title="一般准则"></a>一般准则</h3><p>在请求网络前, 首先考虑用户目前是否确实需要这些数据. 其次考虑是否需要全部数据, 或者只是数据的前十条而已, 如果服务器也可以进行gzip压缩, 要记得打开透明压缩, 并选择数据的数据格式, 例如json.</p>
<h3 id="高效的网络轮询"><a href="#高效的网络轮询" class="headerlink" title="高效的网络轮询"></a>高效的网络轮询</h3><p>网络轮询有几个缺点, 但是有时只能使用轮询来完成在线服务器的新数据的检查. 这时就别忘了<code>AlarmManager</code>这个API可以方便的进行轮询.</p>
<h3 id="服务器端推送"><a href="#服务器端推送" class="headerlink" title="服务器端推送"></a>服务器端推送</h3><p>减少网络调用次数最好的解决办法就是使用服务器端推送. 这样可以让服务器主动通知客户端有新的数据需要检索. 服务器端推送可以有很多种方式, 它可以不直接连接互联网(比如监听短信), 也可以是长期保持获取的常规TCP套接字连接.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/" data-id="cj7hnifdt00126opj74bshbyk" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap10_隐藏的Android API" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/">《Android 编程实战》Chap10_隐藏的Android API</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/">
            <time datetime="2017-09-11T23:59:03.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="官方API和隐藏API"><a href="#官方API和隐藏API" class="headerlink" title="官方API和隐藏API"></a>官方API和隐藏API</h2><p>SDK文档中的所有类, 接口, 方法以及常量都属于官方API. 虽然这些API通常能满足大多数应用的需求, 但开发者有时候需要访问更多的东西, 但却不知道如何在官方API中找到它们.</p>
<p><code>Android SDK</code>中包含了一个<code>JAR</code>文件(android.jar), 在编译代码的时候会引用它, 该文件位于<code>&lt;sdk root&gt;/platforms/android-&lt;API Level&gt;/目录</code>. 不过这里面全是空类, 方法中所有的代码都被移除了, 只声明了<code>public</code>和<code>protected</code>的类. 构建Android平台时, SDK会包含该JAR文件.</p>
<p>通过检查每一个源文件, 并移除所有被<code>@hide</code>注解的域(常量), 方法和类, 在构建SDK时会生成方法体为空的<code>android.jar</code>文件. 这意味着仍然可以在运行的设备上方法这些符号, 但是在编译时却找不到.</p>
<p>Android会自动隐藏某些API, 而不需要使用<code>@hide</code>注解. 这些API位于<code>com.android.internal</code>包中, 不属于<code>android.jar</code>文件, 但却包含大量供android平台使用的内部代码. android系统应用还包含一些其他隐藏API, 这些API通常提供没有包含在官方SDK中的系统<code>ContentProvider</code>信息.</p>
<h2 id="发现隐藏API"><a href="#发现隐藏API" class="headerlink" title="发现隐藏API"></a>发现隐藏API</h2><p>寻找API最简单的方法是在<code>Android</code>源码中搜索他们. 但是<code>Android</code>源码非常多, 还好有几个在线网站已经对这些代码进行了索引, 并提供了搜索功能. <a href="http://androidxref.com/" target="_blank" rel="external">AndroidXRef</a>就是其中的一个.</p>
<p>大部分隐藏的API都位于<code>frameworks</code>项目, 所有<code>android</code>包中的API都可以在frameworks项目中找到, 该项目还包含大部分<code>com.android.internal</code>包中的API.</p>
<h2 id="安全地调用隐藏API"><a href="#安全地调用隐藏API" class="headerlink" title="安全地调用隐藏API"></a>安全地调用隐藏API</h2><p>对于需要编译时链接的API, 也就是接口, 类, 或者方法, 开发者有两个选择. 第一种修改SDK的JAR文件, 使之包含所有需要的类和接口, 并使用该SDK来编译应用程序. 另一种解决方案是使用<code>Java</code>反射API来动态查找要调用的类和方法. 两种方法都可以利弊.</p>
<h3 id="从设备中提取隐藏API"><a href="#从设备中提取隐藏API" class="headerlink" title="从设备中提取隐藏API"></a>从设备中提取隐藏API</h3><p>要做到编译时链接隐藏API, 开发者首先要提取和处理设备中的库文件. 即可以从模拟器提取库文件, 也可以从设备中提取这些文件, 因为它们只是用来编译代码. 由于这个过程需要提取出大量文件, 建议单独创建一个空的工作目录. 另外可能要提取多个版本的库文件, 所以开发者还应为每个API级别创建一个工作目录.</p>
<p><img src="http://szysky.com/2016/10/04/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B10-%E9%9A%90%E8%97%8F%E7%9A%84Android-API/devicespull.png" alt="img"></p>
<p>这里会把设备的<code>/system/framework</code>目录全部拉取出来, 这些文件都是Android设备上基于Java的系统库, 他们是由<code>Dalvik</code>虚拟机加载的Dex优化文件. 下一步决定哪些文件包含隐藏API, 以便把它们转成可以在编译时使用的Java类文件. 大部分隐藏API都位于<code>framework.odex</code>文件, <code>bouncycastle.odex</code>文件包含了加密的库.</p>
<blockquote>
<p>从Android 4.2开始, 原来位于<code>framework.odex</code>的几个隐藏API都放在了其他文件中. 例如<code>Telephony</code>类现在是可选的了(因为并不是所有的Android设备都支持电话), 可以在<code>telephony-common.odex</code>文件中找到它.</p>
</blockquote>
<p>一旦知道需要转换的文件, 就可以下载<code>Smali</code>工具, 它能把优化后的Dex文件(.odex)转换为中间格式(.smali). 接下来使用<code>dex2Jar</code>工具再把这种中间格式转换回Java类文件.</p>
<hr>
<p><strong>修改SDK的错误处理</strong></p>
<p>当使用前面介绍的隐藏API方法时, 很难确定抽取类的方法签名是否和用户设备中相应的方法签名匹配. 虽然修改后的SDK可能在开发用的设备上正常工作, 但是用户的设备制造商可能修改了这些隐藏API. 当这种情况发生时, 应用程序会抛出<code>NoSuchMethodException</code>或者<code>ClassNotFoundException</code>异常.</p>
<p>有几种方法可以处理种种情况. 可以结合使用反射来检测是否存在隐藏API. 推荐使用这种方式, 因为它结合了两种方法的优点. 另一种方法是简单地捕获异常, 防止应用程序崩溃.</p>
<p>不管使用哪一种方法, 都是要确保调用隐藏API的时候发生错误的处理. 最起码可以确保应用程序在测试过的设备上能正常工作.</p>
<h3 id="使用反射调用隐藏API"><a href="#使用反射调用隐藏API" class="headerlink" title="使用反射调用隐藏API"></a>使用反射调用隐藏API</h3><p>使用Java中的反射API比修改<code>Android SDK</code>更安全, 因为它可以在调用<code>隐藏API</code>前检测它们是否存在. 但是, 由于所有隐藏API的绑定和调用都发生在运行时, 反射会比前面介绍的方法更慢.</p>
<p>使用反射调用隐藏API需要两步. 首先, 需要查找要调用的类和方法, 并把他们的引用存到<code>Method</code>对象中. 当持有了引用后, 接下来就可以调用对象的方法.</p>
<p>后面会演示了查找Wi-Fi网络共享的例子.</p>
<h2 id="隐藏API的使用"><a href="#隐藏API的使用" class="headerlink" title="隐藏API的使用"></a>隐藏API的使用</h2><h3 id="接收和阅读SMS"><a href="#接收和阅读SMS" class="headerlink" title="接收和阅读SMS"></a>接收和阅读SMS</h3><p><code>Android</code>中使用隐藏API最常见的例子是接收和阅读<code>SMS</code>, 虽然官方API包含了<code>RECEIVE_SMS</code>和<code>READ_SMS</code>这两个权限, 但实际执行的API却是隐藏的.</p>
<p>应用程序要想接收<code>SMS</code>必须声明使用<code>RECEIVE_SMS</code>权限, 并且实现<code>BroadcastReceiver</code>, 已处理收到的短信.</p>
<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 清单文件</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;</div><div class="line"></div><div class="line">&lt;receiver android:name=&quot;.hideapi.SmsReceiver&quot;&gt;</div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class SmsReceiver extends BroadcastReceiver &#123;</div><div class="line">    // Telephony.java 中隐藏的常量</div><div class="line">    public static final String SMS_RECEIVED_ACTION</div><div class="line">            = &quot;android.provider.Telephony.SMS_RECEIVED&quot;;</div><div class="line"></div><div class="line">    public static final String MESSAGE_SERVICE_NUMBER = &quot;+461234567890&quot;;</div><div class="line">    private static final String MESSAGE_SERVICE_PREFIX = &quot;MYSERVICE&quot;;</div><div class="line"></div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line">        if (SMS_RECEIVED_ACTION.equals(action)) &#123;</div><div class="line">            // 通过 pdus 获取SMS数据的隐藏键</div><div class="line">            Object[] messages =</div><div class="line">                    (Object[]) intent.getSerializableExtra(&quot;pdus&quot;);</div><div class="line">            for (Object message : messages) &#123;</div><div class="line">                byte[] messageData = (byte[]) message;</div><div class="line">                SmsMessage smsMessage =</div><div class="line">                        SmsMessage.createFromPdu(messageData);</div><div class="line">                Log.e(&quot;haha&quot;, &quot;收到消息来自: &quot;+smsMessage.getOriginatingAddress()+ &quot;   内容:&quot;+smsMessage.getMessageBody());</div><div class="line"></div><div class="line">                processSms(smsMessage);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只关心指定的电话号码</div><div class="line">    private void processSms(SmsMessage smsMessage) &#123;</div><div class="line">        String from = smsMessage.getOriginatingAddress();</div><div class="line">        if (MESSAGE_SERVICE_NUMBER.equals(from)) &#123;</div><div class="line">            String messageBody = smsMessage.getMessageBody();</div><div class="line">            if (messageBody.startsWith(MESSAGE_SERVICE_PREFIX)) &#123;</div><div class="line">                // TODO: 数据验证通过开始处理</div><div class="line">                Log.e(&quot;haha&quot;, &quot;processSms: &quot;+messageBody);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面利用广播监听<code>Intent</code>操作<code>android.provider.Telephony.SMS_RECEIVED</code>. 这个例子中唯一隐藏的部分就是<code>Intent</code>的action. 以及用来从<code>Intent(&quot;pdus&quot;)</code>检索SMS数据的字符串.</p>
<p>要读取已经收到的<code>SMS</code>, 需要查询一个隐藏的<code>ContentProvider</code>, 并声明使用<code>READ_SMS</code>权限. <code>android.provider</code>包中的<code>Telephony</code>类提供了所有需要的信息. 使用该类最佳的方式是把它复制到自己的项目中, 并修改类的包结构. 由于<code>Telephony</code>类还包含其他隐藏类和方法的调用, 所以还必须删除或者重构这些调用, 以便能够编译代码. 取决于使用<code>隐藏API</code>的数量, 有时候简单复制一些常量声明而不是整个类就足够了.</p>
<p>阅读的部分就省略了, 除了某些特定方向的应用, 基本上应用是不会去读入用户的短信.</p>
<h3 id="隐藏设置"><a href="#隐藏设置" class="headerlink" title="隐藏设置"></a>隐藏设置</h3><p><code>Android</code>设备有数百种不同的设置, 都可以通过<code>Settings</code>类访问, 除了为每个设置提供访问的值, <code>Android</code>还提供给了一些类<code>Intent</code>操作, 使他们可以打开特定的设置UI. 例如, 要启动飞行模式设置, 在创建Intent时可以使用<code>Settings.ACTION_AIRPLANE_MODE_SETTINGS</code></p>
<p><code>Settings</code>类包含了一些隐藏的设置键和Intent操作, 当应用程序需要弄清楚设备的细节或者呈现一个特定系统设置的快捷方式时, 启动的一些常量值是非常方便的.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/" data-id="cj7hnifdn000z6opjbxygt8n1" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap9_Android应用安全问题" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/">《Android 编程实战》Chap9_Android应用安全问题</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/">
            <time datetime="2017-09-11T23:57:47.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android安全的概念"><a href="#Android安全的概念" class="headerlink" title="Android安全的概念"></a>Android安全的概念</h2><p><code>Android</code>具备一个先进的安全模型来保护应用数据和服务不被其他应用访问. 每个应用都有自己的唯一<code>ID</code>来提供最基本的保护. 每个应用都经过它唯一的密钥签名, 这种机制是<code>Android</code>框架中的安全模型基础. 此外只有当其他应用在清单文件中显式声明了正确权限后, <code>Android</code>的权限系统才会和他们共享特定的组件. 应用也可以定义权限, 比如只有使用同一个密钥签名的应用才能使用它们. 最后<code>Android</code>的API提供了各种方法来验证签名, 验证调用进程的用户ID和使用强加密方案.</p>
<h3 id="签名和密钥"><a href="#签名和密钥" class="headerlink" title="签名和密钥"></a>签名和密钥</h3><p><code>Android</code>系统中运行的所有应用都要用密钥来签名, 包括<code>Android</code>系统本身.</p>
<p>可以用同一个密钥来对发布的所有应用进行签名, 但建议为各个应用单独创建一个密钥. 多个应用共享一个密钥通常是因为这些应用要直接访问彼此的数据, 或者设定权限时将保护等级改为<code>signature</code></p>
<p>下面是一种为应用生成密钥的一个方式, 有一种比较好的方式是使用应用的包名作为别名传给<code>-alias</code>.</p>
<p><code>$ keytool -genkey -v -keystore &lt;keystore filename&gt; -alias &lt;alias for key&gt; keyalg RSA -keysize 2048 -validity 10000</code></p>
<p>在生成新密钥时, <code>keytool</code>会让你输入一个密码.</p>
<h3 id="Android权限"><a href="#Android权限" class="headerlink" title="Android权限"></a>Android权限</h3><p>要在<code>Android</code>中使用特殊权限功能, 只要在清单文件中加入一个<code>uses-permission</code>标记即可. 它会告诉系统你的应用需要该项权限, 并在安装时通知用户这项需求.</p>
<p><code>Android</code>中定义了五个保护等级: <code>常规normal</code>, <code>危险dangerous</code>, <code>同一签名signature</code>, <code>同一签名或系统signatureOrSystem</code>, <code>系统system</code>. 除非特殊指定, 默认等级一般为常规. 用来告知系统有应用要用到这个权限的函数. 只有将权限设为危险时, 它才会在用户安装(通常是通过Google Play Store)前提醒用户.</p>
<ul>
<li><code>同一签名</code>保护等级要求应用使用跟定义该权限的应用相同的同一证书来签名. 这对设备制造商来说非常有用, 因为他们可以定义只有跟系统使用同一证书签名的应用才能使用的权限. 这样, 设备制造商就可以像他们使用受保护的系统服务的设备发布新应用.</li>
<li><code>同一签名或系统 以及 系统</code>这两个等级会告诉<code>Android</code>系统, 应用必须驻存在设备的系统分区上, 这样才能使用该权限. 这个功能最常见的例子是预装在系统分区上的Google应用. 这些应用可以使用许多常规应用无法企及的权限, 即使他们用的是Google的签名而不是设备制造商的.</li>
</ul>
<blockquote>
<p>也可以添加属性<code>android:permissionFlags=&quot;costsMoney&quot;</code>它会告诉用户使用此权限的应用会产生费用, 例如要用到发短信的功能的应用. 只要应用提供了可能会给用户带来费用的API, 那就应该用带有此标记的权限来保护该API.</p>
</blockquote>
<h3 id="保护用户数据"><a href="#保护用户数据" class="headerlink" title="保护用户数据"></a>保护用户数据</h3><p>如果要创建安全的数据文件, 不被其他应用访问, 可以在应用数据目录中存储文件. 而不是外部存储中.</p>
<p>如下:演示在应用的数据目录中对一个文件进行数据追加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void appendStringToPrivateFile(Context context, String data, String fileName)&#123;</div><div class="line">    FileOutputStream out = context.openFileOutput(fileName, Context.MODE_APPEND | Context.MODE_PRIVATE);</div><div class="line">    out.write(data.getBytes(&quot;UTF-8&quot;));</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了两个标志位:</p>
<ul>
<li><code>MODE_APPEND</code> 要写入的数据都被追加到文件的末尾,</li>
<li><code>MODE_PRIVATE</code> 该文件只允许你的应用访问, 这个标识位也是默认标志位.</li>
</ul>
<p>当然这只是一种比较安全的方式, 但是如果存储非常敏感的信息, 最好再对文件进行一些加密处理.</p>
<h2 id="客户端数据加密"><a href="#客户端数据加密" class="headerlink" title="客户端数据加密"></a>客户端数据加密</h2><h3 id="Android的加密API"><a href="#Android的加密API" class="headerlink" title="Android的加密API"></a>Android的加密API</h3><p><code>Android</code>中的数据加密和解密API是基于Java SE的<code>javax.crypto</code>包中的API开始的. 实际的实现基于开源的<code>Bouncy Castle</code>加密API. 因此, 在开发<code>Android</code>应用时, 大多是使用Java SE的<code>javax.crypto</code>API就可以.</p>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>使用加密和解密函数时, 需要生成一个可根据用户输入(密码或其他安全方法)重新生成的安全且唯一的密钥.</p>
<p>下面的代码演示了如何为<code>AES算法</code>生成一个<code>SecretKey</code> <code>salt</code>是用于生成密钥的输入部分, 你需要记录下来. 在密码学中, <code>盐salt</code>是用做加密算法中单向函数输入的一段随机数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static SecretKey generateKey(char[] password , byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</div><div class="line">   int iterations = 1000;</div><div class="line">   int outputKeyLength = 128;</div><div class="line"></div><div class="line">   SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);</div><div class="line"></div><div class="line">   PBEKeySpec pbeKeySpec = new PBEKeySpec(password, salt, iterations, outputKeyLength);</div><div class="line"></div><div class="line">   byte[] keyBytes = secretKeyFactory.generateSecret(pbeKeySpec).getEncoded();</div><div class="line">   return new SecretKeySpec(keyBytes, &quot;AES&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个密钥在后面会使用</p>
<h3 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h3><p>要加密数据, 必须先生成用于加密的作为<code>Cipher</code>输入的盐和初始化向量. 下面的代码会通过<code>SecureRandom</code>类生成一个长度为8字节的盐. 注意: 不需要人工给<code>SecureRandom</code>喂种子, 系统会自动帮你处理. 创建一个初始化向量, 初始化<code>Cipher</code>, 然后将明文加密成字节队列. 有了密文数据之后, 可以使用<code>Base64</code>工具类从这些字节生成一个普通的String对象. 并把初始化向量和盐用同样的方式追加上去, 并通过一个<code>非Base64</code>字符来分开.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static String encryptClearText(char[] password, String plainText)</div><div class="line">       throws Exception &#123;</div><div class="line">   SecureRandom secureRandom = new SecureRandom();</div><div class="line">   int saltLength = 8;</div><div class="line">   byte[] salt = new byte[saltLength];</div><div class="line">   secureRandom.nextBytes(salt);</div><div class="line">   SecretKey secretKey = generateKey(password, salt);</div><div class="line"></div><div class="line">   Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</div><div class="line">   byte[] initVector = new byte[cipher.getBlockSize()];</div><div class="line">   secureRandom.nextBytes(initVector);</div><div class="line">   IvParameterSpec ivParameterSpec = new IvParameterSpec(initVector);</div><div class="line">   cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);</div><div class="line">   byte[] cipherData = cipher.doFinal(plainText.getBytes(&quot;UTF-8&quot;));</div><div class="line">   return Base64.encodeToString(cipherData,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING)</div><div class="line">           + &quot;]&quot; + Base64.encodeToString(initVector,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING)</div><div class="line">           + &quot;]&quot; + Base64.encodeToString(salt,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法返回的结果就是加密后的密文字符串. 解密的时候使用同样的规则解密即可</p>
<h3 id="解密数据"><a href="#解密数据" class="headerlink" title="解密数据"></a>解密数据</h3><p>和加密基本相似, 取出加密的的数据部分. 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static String decryptData(char[] password, String encodedData)</div><div class="line">       throws Exception &#123;</div><div class="line">   String[] parts = encodedData.split(&quot;]&quot;);</div><div class="line">   byte[] cipherData = Base64.decode(parts[0], Base64.DEFAULT);</div><div class="line">   byte[] initVector = Base64.decode(parts[1], Base64.DEFAULT);</div><div class="line">   byte[] salt = Base64.decode(parts[2], Base64.DEFAULT);</div><div class="line"></div><div class="line">   Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</div><div class="line">   IvParameterSpec ivParams = new IvParameterSpec(initVector);</div><div class="line">   SecretKey secretKey = generateKey(password, salt);</div><div class="line">   cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParams);</div><div class="line">   return new String(cipher.doFinal(cipherData), &quot;UTF-8&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面方法可以了解到<code>Cipher</code>,<code>初始化向量</code>,<code>SecretKey</code>是如何通过输入的字符串重新生成的. 只要密码匹配, 就能够对数据进行解码和编码.</p>
<h2 id="设备管理API"><a href="#设备管理API" class="headerlink" title="设备管理API"></a>设备管理API</h2><p>关于这部分, 更多偏向于系统级别的开发. 例如对远程安全加固功能, 当丢失设备通过短信,锁定设备等. 所以此处不做记录. 如果有兴趣可以查看API文档<a href="https://developer.android.com/guide/topics/admin/device-admin.html" target="_blank" rel="external">Device Administration API</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/" data-id="cj7hnife3001g6opjy9mtaxk6" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/">《Android 编程实战》Chap8_高级音频,视频及相机应用</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/">
            <time datetime="2017-09-11T23:57:02.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="高级音频应用"><a href="#高级音频应用" class="headerlink" title="高级音频应用"></a>高级音频应用</h2><p><code>Android</code>音频API提供了一些高级功能, 开发者可以把他们集成到自己的应用中. 有了这些API, 就可以很容易的实现<strong>VoIP网络电话</strong>, 构建定制的流媒体音乐客户端, 实现低延迟的游戏音效. 此外, 还有提供文本到语音转换以及语音识别API, 用户可以直接使用音频和用户交互, 而不需要使用用户界面或者触控技术.</p>
<h3 id="低延迟音频"><a href="#低延迟音频" class="headerlink" title="低延迟音频"></a>低延迟音频</h3><p><code>Android</code>有四个用来播放音频的API(算上MIDI那么就是5个)和三个用来录音的API. 接下里会简要介绍这些API.</p>
<hr>
<p><strong>音频播放API</strong></p>
<ul>
<li>音频播放默认使用<code>MediaPlayer</code>. 该类适合播放音乐或者视频, 既能播放流式资源(比如在线网络收音机), 也可以播放本地文件. 每个<code>MediaPlayer</code>都有一个关联的状态机, 需要在应用程序中跟踪这些状态. 开发者可以使用<code>MediaPlayer</code>类的API在自己的应用中嵌入音乐或者视频播放功能, 而无需额外处理或者考虑延迟问题.</li>
<li>第二种是<code>SoundPool</code>类, 它提供了低延迟的支持, 适合播放音效和其他比较短的音频, 比如可以使用<code>SoundPool</code>播放游戏声音. 但是, 它不支持音频流, 所以不适合那些需要实时音频流处理的应用如<code>VoIP</code>.</li>
<li>第三种是<code>AudioTrack</code>类, 它允许把音频流缓冲到硬件中, 支持低延迟播放, 甚至适合流媒体场景. <code>AudioTrack</code>通常能提供足够低的延迟, 可在<code>VoIP</code>或类似应用中使用.</li>
</ul>
<p>下面代码展示如何在<code>VoIP</code>应用中使用<code>AudioTrack</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class AudioTrackDemo &#123;</div><div class="line"></div><div class="line">    private final AudioTrack mAudioTrack;</div><div class="line">    private final int mMinBufferSize;</div><div class="line"></div><div class="line">    public AudioTrackDemo() &#123;</div><div class="line"></div><div class="line">        // 确定音频流的最小缓冲区和大小</div><div class="line">        mMinBufferSize = AudioTrack.getMinBufferSize(16000, AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT);</div><div class="line"></div><div class="line">        mAudioTrack = new AudioTrack(AudioManager.STREAM_VOICE_CALL,</div><div class="line">                16000,</div><div class="line">                AudioFormat.CHANNEL_OUT_MONO,</div><div class="line">                AudioFormat.ENCODING_PCM_16BIT,</div><div class="line">                mMinBufferSize * 2,</div><div class="line">                AudioTrack.MODE_STREAM);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void playPcmPacket(byte[] pcmData)&#123;</div><div class="line">        if (mAudioTrack != null &amp;&amp; mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)&#123;</div><div class="line"></div><div class="line">            // 判断是否处在播放状态</div><div class="line">            if (mAudioTrack.getPlaybackRate() != AudioTrack.PLAYSTATE_PLAYING)&#123;</div><div class="line">                mAudioTrack.play();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mAudioTrack.write(pcmData, 0, pcmData.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //  设置停止</div><div class="line">    public void stopPlayback()&#123;</div><div class="line">        if (mAudioTrack != null)&#123;</div><div class="line">            mAudioTrack.stop();</div><div class="line">            mAudioTrack.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对这个类进行一下整理, 首先从构造函数开始. 最开始需要确定音频流的最小缓冲区大小. 要做到这一点, 需要知道采样率, 数据是单声道还是立体声, 以及是否使用8位或者16位<code>PCM</code>编码. 然后以采样率和采样大小作为参数调用<code>AudioTrack.getMinBufferSize()</code>, 该方法会以字节形式返回<code>AudioTrack</code>实例的最小缓冲区大小</p>
<p>接下来, 根据使用正确的参数创建<code>AudioTrack</code>实例, 第一个参数为音频的类型, 不同的应用使用不同的值. 对于<code>VoIP</code>这种应用来说使用<code>STREAM_VOICE_CALL</code>, 而对流媒体音乐应用则使用<code>STREAM_MUSIC</code>.</p>
<p>对于参数2,3,4会根据使用场景而有所不同. 这些参数跟别表示<code>采样率</code>, <code>立体声/单声道</code>, <code>采样大小</code>. 一般而言, 一个<code>VoIP</code>会使用<code>16kHz</code>的16位单声道, 而常规的音乐CD可能采用<code>44.1kHz</code>的16位立体声. 16位立体声采样率需要更大的缓冲区以及更多的数据传输, 但是音质会更好. 所有的<code>Android</code>设备都支持<code>PCM</code>以<code>8kHz</code>,<code>16kHz</code>,<code>44.1kHz</code>的采样率播放8位或者16位的立体声.</p>
<p>缓冲区大小参数应该是最小缓冲区大小的倍数, 实际取决于具体的需求, 有时网络延迟等因素也会影响缓冲区大小. <strong>注意: 任何时候都应该避免使用空的缓冲区, 因为可能导致播放出现故障</strong></p>
<p>最后一个参数决定只发送一次音频数据<code>MODE_STATIC</code>还是连续发送数据流<code>MODE_STREAM</code>. 第一种情况需要一次发送整个音频剪辑. 对于持续发送音频流的情况, 可以发送任意大小块的<code>PCM数据</code>, 处理流媒体音乐或者VoIP通话时可能会使用这种方式.</p>
<hr>
<p><strong>2. 录音API</strong></p>
<p>说道录制音频(也可能是视频), 首先要考虑的API是<code>MediaRecorder</code>. 和<code>MediaPlayer</code>类似, 需要在应用代码中跟踪<code>MediaRecorder</code>类的内部状况. 由于<code>MediaRecorder</code>只能把录音保存在文件中, 所以他不适合录制流媒体.</p>
<p>如果需要录制流媒体, 可以使用<code>AudioRecorder</code>, 它和之前描述的<code>AudioTrack</code>非常相似.</p>
<p><a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/0109285e016f34c5403195344987cee5a7b791e0" target="_blank" rel="external">链接代码演示了如何创建<code>AudioRecorder</code>实例录制16位单声道16kHz的音频采样</a></p>
<p>其实和<code>AudioTrack</code>的创建过程非常给你相似, 在使用<code>VoIP</code>或者类似应用时可以很方便地把他们结合起来.</p>
<h3 id="OpenSL-ES"><a href="#OpenSL-ES" class="headerlink" title="OpenSL ES"></a>OpenSL ES</h3><p>前面说了3播放API和2个录制API. 还有最后一个API <code>OpenSL ES</code>, 它同时支持播放和录制. 该API是科纳斯组织(Khronos Group)的一个标准, 这个组织还负责<code>OpenGL API</code></p>
<p><code>OpenSL ES</code>提供了低级别的音频硬件访问和低延迟特性来处理音频播放和录制. 虽然<code>Android</code>中其他音频API都有方便的Java API, 但是<code>OpenSL ES</code>目前仅支持在<code>Android NDK</code>中使用本地C代码访问.</p>
<blockquote>
<p><code>= =!!! 到这里能力受限, 无法实现出效果...所以此章抄书就此太监. 后续包括OpenGL 串联Surface用于视频MediaPlayer的渲染层或者相机处理把预览画面的流连接到纹理流, 并实施处理画面实现现实AR应用等.</code></p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/" data-id="cj7hnifdy001a6opjtajn6b8f" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap7_序列化说明" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/">《Android 编程实战》Chap7_序列化说明</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/">
            <time datetime="2017-09-11T23:56:25.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="数据存储的介绍"><a href="#数据存储的介绍" class="headerlink" title="数据存储的介绍"></a>数据存储的介绍</h2><p>谈到数据数据存储通常会使用<code>持久化</code>, 而用<code>序列化</code>描述数据是如何表现其存储状态的. 如果没有数据的<code>持久化</code>, 那么数据还能在<code>RAM</code>中保持其状态, 一旦相关进程结束数据就会消失. 实现数据的持久化通常涉及性能, 延迟, 数据大小和复杂度等因素的这种. 例如, 快速的数据读取往往会导致较慢的写入. 序列化就是关于数据如何组织的, 同时包括在持久化状态和内存中.</p>
<h2 id="Android持久化选项"><a href="#Android持久化选项" class="headerlink" title="Android持久化选项"></a>Android持久化选项</h2><p><code>Android</code>中提供了两种现成的方法, 分别是:</p>
<ul>
<li><code>偏好文件(preference files)</code>: 使用<code>XML</code>格式, 通过<code>SharePreferences</code>类提供接口</li>
<li><code>数据库(sqlite)</code>: 通常被包装成<code>ContentProider</code>组件.</li>
</ul>
<p>通常选项, 应用配置属性用<code>preferences files</code>来存储; 数组表格,或者Java表示的一些数据用数据库进行存储; 而一些二进制数据, 例如图片通常当做常规文件来存储在本地.</p>
<h2 id="Preferences-file"><a href="#Preferences-file" class="headerlink" title="Preferences file"></a>Preferences file</h2><p>这些文件存储在应用程序的内部目录中, 其结构只允许存储键值对.</p>
<p>创建<code>SharePreferences</code>对象最简单的方式是使用<code>PreferenceManager.getDefaultSharedPreferences()</code>方法, 它会返回应用程序默认的偏好对象. 这种方式的便利是系统会自动管理<strong>偏好文件名</strong>. 如果需要多个偏好文件那么要使用<code>Context.getSharedPreferences()</code>方法, 它允许开发者自由命名文件. 如果只是创建<code>Activity</code>相关的偏好文件, 可以使用<code>Activity.getPreference()</code>方法, 他会在调用时得到<code>Activity</code>的名字.</p>
<blockquote>
<p><code>getDefaultSharePreferences()</code>创建的偏好文件名是由包名+<code>_preferences</code>组成的.</p>
</blockquote>
<p>其内部支持的存储值类型有<code>int</code>, <code>float</code>, <code>long</code>, <code>boolean</code>, <code>String</code>以及<code>Set&lt;String&gt;</code>对象. 键名必须是一个有效的字符串.</p>
<hr>
<p><strong>如果需要文件修改并提交存储</strong></p>
<p>首先需要获得<code>Editor</code>实例, 他提供了相应的<code>PUT</code>方法, 以及用于提交修改的方法. 在<code>Android 2.3</code>之前, 通过使用<code>commit()</code>方法把修改<strong>同步</strong>提交到存储设备中. 但在2.3之后, <code>Editor</code>类提供了用于<strong>异步</strong>执行写操作的<code>apply()</code>方法. 因为要尽可能地避免主线程执行阻塞操作, 所以<code>apply()</code>相对来说比<code>commit()</code>更好.</p>
<hr>
<p><strong>如果需要对偏好值被修改的时候可以收到通知</strong></p>
<p>那么可以通过注册一个回调函数, 每当<code>apply()</code>和<code>commit()</code>方法时都会触发该监听器. 通过对<code>SharedPreferences</code>的实例调用<code>registerOrSharedPreferenceChangeListener()</code>方法来添加内容改变回调.</p>
<h3 id="用户选项和设置用户界面"><a href="#用户选项和设置用户界面" class="headerlink" title="用户选项和设置用户界面"></a>用户选项和设置用户界面</h3><p>Android提供一套现成的<code>Activity</code>和<code>Fragment</code>类针对用户更改应用程序的选项和设置, 使得创建这类用户界面非常简单容易<code>PreferenceActivity</code>和<code>PreferenceFragment</code>.</p>
<p>但! 是! 感觉没啥用处, 基本应用都会按照自己的ui风格进行设计. 知道一下就行</p>
<h2 id="ContentProvider注意事项"><a href="#ContentProvider注意事项" class="headerlink" title="ContentProvider注意事项"></a>ContentProvider注意事项</h2><h3 id="Android数据库设计"><a href="#Android数据库设计" class="headerlink" title="Android数据库设计"></a>Android数据库设计</h3><p>关系数据库的设计通常通过<code>数据库规范化</code>完成. 该过程使用一些<code>范式</code>规则来减少数据库中的依赖和冗余. 有许多数据库范式, 但在大多数情况下, 只有前三个是相关的. 如果一个数据库设计满足了前三个范式, 可以认为它是<code>规范化</code>的.</p>
<p>由于面向的对象为<code>android</code>应用. 有可能不一定在表中尽可能多的使用外键, 虽然使用外键可以更好的减少空间的占用, 但是相对于开发中操作多表的困难度也就相应的提高. 所以需要权衡一下.</p>
<h3 id="创建和升级数据库"><a href="#创建和升级数据库" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h3><p>建议总是使用<code>ContentProvider</code>组件包装<code>SQLite</code>数据库. 通过这种方式, 可以只在一个地方管理的数据库调用, 还可以使用一些现成的数据库工具类.</p>
<h3 id="查询方法说明"><a href="#查询方法说明" class="headerlink" title="查询方法说明"></a>查询方法说明</h3><p>查询数据库(通常会调用<code>ContentResolver.query()</code>)会调用<code>ContentProvider.query()</code>方法. 在实现查询方式时必须解析传入的<code>Uri</code>以决定执行哪个查询, 并且还要检查所有传入的参数是否正确.</p>
<blockquote>
<p>编写数据库查询要把<code>WHERE</code>语句中较简单的比较放在前面. 这样会加快查询, 因为其可以尽早决定要包含的信息.</p>
</blockquote>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>每次在<code>SQLite</code>数据库执行一条<code>SQL</code>语句都会执行一次数据库事务操作. 除非是自己专门管理事务, 否则每条语句都会自动创建一个事务. 因为大多数<code>ContentProvider</code>调用最终都只会生成一条<code>SQL</code>语句, 这种情况下几乎没有必要手动处理事务. 但是如果应用程序将执行多条<code>SQL</code>语句, 比如一次插入很多条记录, 记得总是自己管理事务.</p>
<p><code>ContentProvider</code>类提供了两个事务管理的方法: <code>ContentProvider.bulkInsert()</code>和<code>ContentProvider.applyBatch()</code> 相比与普通的<code>insert()</code>快了很多.</p>
<p>事务的语义很简单. 首先调用<code>SQLiteDatabase.beginTransaction()</code>开始一个新的事务. 当成功插入所有记录之后调用<code>SQLiteDatabase.setTransactionSuccessful()</code>, 然后使用<code>SQLiteDatabase.endTransaction()</code>结束本次事务. 如果某条数据插入失败, 会抛出<code>SQLiteException</code>, 而之前的所有插入都会回滚, 因为在成功之前没有调用过<code>setTransactionSuccessful()</code></p>
<p><strong>bulkInsert()虽然会提高数据插入性能, 但是此方法只使用插入操作</strong></p>
<p>如果要在一次事务中执行多次<code>update()</code>或者<code>delete()</code>语句, 必须实现<code>ContentProvider.applyBatch()</code>方法. 接收一个<code>ContentProviderOperation集合</code>.内部循环集合通过调用<code>apply()</code>在事务内部实现操作.</p>
<p>该API是为<code>ContactsProvider</code>等较复杂的<code>ContentProvider</code>设计的, 他们有许多连接的表, 每个都有自己的<code>Uri</code>. 另外如果要批量插入多个表, 该API也可以使用.</p>
<h2 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h2><p>如果要在<code>Intent</code>上传输数据或者和另外一台设备共享数据, 需要把数据转化成接收端能识别的格式, 并且还要适于在网络上传输. 这种技术称为<code>序列化(serialization)</code></p>
<p>序列化是从内存中取出数据并把其写到文件(或者其他输出)中, 是的以后能读取完全相同的数据称为<code>反序列化</code>. android内部使用了<code>Parcelable</code>接口来处理序列化工作, 但它不适合在文件上持久存储或者在网络上传输数据.</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p><code>JSON</code>是<code>JavaScript Object Notation</code>的缩写, 是<code>JavaScript</code>标准的一个子集. 这种格式很适合表示非二进制数据的.</p>
<p>例如一下JSON数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;name&quot;:&quot;张三&quot;</div><div class="line">        &quot;id&quot;  :&quot;1&quot;</div><div class="line">        &quot;sex&quot; :&quot;男&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;name&quot;:&quot;张三&quot;</div><div class="line">        &quot;id&quot;  :&quot;1&quot;</div><div class="line">        &quot;sex&quot; :&quot;男&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        &quot;name&quot;:&quot;张三&quot;</div><div class="line">        &quot;id&quot;  :&quot;1&quot;</div><div class="line">        &quot;sex&quot; :&quot;男&quot;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这里说一下另一个<code>API</code>作为了解, 通过获得输入输出流利用<code>JsonReader</code>和<code>JsonWriter</code>API进行. 相比较直接把一个流中的全部内容读取为一个<code>String</code>中, 然后传给<code>JSONArray</code>的构造函数, 使用<code>JsonReader</code>会消耗更少的内存, 并且相对来说会更快.</p>
<p>直接使用JSON API 现在也不常用, 想了解看一下<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/blob/master/StoreOrTest/app/src/main/java/com/szysky/note/storeortest/serialization/JSONDemo.java" target="_blank" rel="external">实例代码</a></p>
<h3 id="Gson介绍"><a href="#Gson介绍" class="headerlink" title="Gson介绍"></a>Gson介绍</h3><p><code>JSONObject</code>和<code>JSONArray</code>类使用起来虽然很方便, 但是他们也有一定的局限性, 并且通常会消耗更多不必要的内存. 同样, 如果有多个不同类型的对象, 使用<code>JsonReader</code>和<code>JsonWriter</code>需要编写比较多的代码. 所以如果需要更高级的JSON数据序列化和反序列化方法, 可是使用<code>Gson</code></p>
<p><code>Gson</code>允许把简单的Java对象转换成<code>JSON</code>, 反之亦然. 所以常做的就是生成一个<code>JavaBean</code>对象, 提供set/get并转换成json对象.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/" data-id="cj7hnifdq00106opjay74moqq" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap7_序列化说明/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap6_重识BroadcastReceiver" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/">《Android 编程实战》Chap6_重识BroadcastReceiver</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/">
            <time datetime="2017-09-11T23:55:35.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p><code>Android</code>中发送广播事件最常用的方式是通过<code>Content.sendBroadcast()</code>方法给<code>BroadcastReceiver</code>发送<code>Intent</code>对象. 许多标准系统事件都被定义成操作字符串, 并可以在<code>Intent</code>类的API文档中查看. 例如, 如果需要在用户连接或者断开充电器的时候收到通知, 可以使用<code>Intent</code>中定义的两个广播操作: <code>ACTION_POWER_DISCONNECTED</code>和<code>ACTION_POWER_CONNECTED</code>.</p>
<hr>
<p><strong>举例: 例如监听手机充电状态改变的广播</strong></p>
<p>首先派生出一个<code>BroadcastReceiver</code>的子类.复写<code>onReceiver()</code>方法. 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ChargerConnectedReceiver extends BroadcastReceiver &#123;</div><div class="line">    public ChargerConnectedReceiver() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line"></div><div class="line">        if (Intent.ACTION_POWER_CONNECTED.equals(action))&#123;</div><div class="line">            Toast.makeText(context, &quot;手机充电啦&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;else if (Intent.ACTION_POWER_DISCONNECTED.equals(action))&#123;</div><div class="line">            Toast.makeText(context, &quot;手机不充电了&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后需要注册广播, 告诉系统在当哪一个<code>action</code>动作发生的时候需要回调我们自定的接收者的<code>onReceive()</code>方法. 这里有两种方法, <code>静态注册</code>和<code>动态注册</code>.</p>
<p><strong>静态注册</strong></p>
<p>在清单文件中声明这个广播组件, 并设置<code>intent-filter</code>即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;receiver android:name=&quot;broadcast.ChargerConnectedReceiver&quot;&gt;</div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;action android:name=&quot;android.intent.action.ACTION_POWER_CONNECTED&quot;/&gt;</div><div class="line">      &lt;action android:name=&quot;android.intent.action.ACTION_POWER_DISCONNECTED&quot;/&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p><strong>动态注册</strong></p>
<p>一般情况动态注册都是在<code>Activity</code>中的<code>onCreate()</code>和<code>onResume()</code>同时出现的. 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class ChargerConnectedActivity extends Activity &#123;</div><div class="line"></div><div class="line">    private ChargerConnectedReceiver chargerConnectedReceiver;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        // 生成对于广播的 intent过滤条件</div><div class="line">        IntentFilter intentFilter = new IntentFilter();</div><div class="line">        intentFilter.addAction(Intent.ACTION_POWER_CONNECTED);</div><div class="line">        intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED);</div><div class="line">        chargerConnectedReceiver = new ChargerConnectedReceiver();</div><div class="line">        registerReceiver(chargerConnectedReceiver, intentFilter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onPause() &#123;</div><div class="line">        super.onPause();</div><div class="line">        unregisterReceiver(chargerConnectedReceiver);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果只在应用程序处于运行或活动状态时才关心广播事件时, 可以选择在代码中注册广播. 这样可以让应用程序消耗更少的资源; 如果在清单文件中声明, 则每当有事件发生时, 广播接收器都会启动, 因此会消耗更多资源.</p>
<h3 id="本地BroadcastReceiver"><a href="#本地BroadcastReceiver" class="headerlink" title="本地BroadcastReceiver"></a>本地BroadcastReceiver</h3><p>如果只是在应用程序进程内发送和接收广播, 那么可以使用<code>LocalBroadcastManager</code>而不是更常用的<code>Context.sendBroadcast()</code>方法. 这种方法更高效, 因为不需要跨进程管理操作, 也不需要考虑广播通常涉及的安全问题. 标准IPA中没有包含<code>LocalBroadcastManager</code>类, 但是可以在支持包(support_V4)中找到. 下面演示如何使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static final String LOCAL_BROADCAST_ACTION = &quot;localBroadcast&quot;;</div><div class="line">private BroadcastReceiver mLocalReceiver;</div><div class="line"></div><div class="line">// 注册本地广播</div><div class="line">private void initLocalBroadcast() &#123;</div><div class="line">   LocalBroadcastManager instance = LocalBroadcastManager.getInstance(getApplicationContext());</div><div class="line">   IntentFilter intentFilter = new IntentFilter(LOCAL_BROADCAST_ACTION);</div><div class="line"></div><div class="line">   mLocalReceiver = new BroadcastReceiver() &#123;</div><div class="line">       @Override</div><div class="line">       public void onReceive(Context context, Intent intent) &#123;</div><div class="line">           Toast.makeText(getApplicationContext(), &quot;本地广播接收到&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   instance.registerReceiver(mLocalReceiver, intentFilter);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 发送本地广播</div><div class="line">findViewById(R.id.btn_send).setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">  @Override</div><div class="line">  public void onClick(View v) &#123;</div><div class="line">      LocalBroadcastManager instance = LocalBroadcastManager.getInstance(getApplicationContext());</div><div class="line">      // 上面定义的通电状态action</div><div class="line">      Intent intent = new Intent(LOCAL_BROADCAST_ACTION);</div><div class="line">      instance.sendBroadcast(intent);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在应用程序内部使用本地广播来广播消息和状态也非常方便. 本地广播比标准的全局广播更高效和安全, 因为它不会把数据泄露给其他应用程序. 切记要和正常的接收器一样, 在对应的方法中要移除注册, 否则可能会有内存泄漏.</p>
<h3 id="普通广播和粘性广播"><a href="#普通广播和粘性广播" class="headerlink" title="普通广播和粘性广播"></a>普通广播和粘性广播</h3><p>广播分为两种类型: <strong>普通广播</strong>和<strong>有序广播</strong>.</p>
<ul>
<li><strong>普通广播</strong>会以异步方式发送给所有的接收者, 并且没有指定的接收顺序. 该方式更加高效, 但是缺少有序广播额一些高级功能, 比如不能发送结果反馈.</li>
<li><strong>有序广播</strong>按照特定的顺序分发, 每次只发给一个接收者, 开发者可以在清单文件中设置接收者的<code>intent-filter</code>标签的<code>android:priority</code>属性来控制广播的接收顺序. 有序广播还有另外一个特性: 通过使用<code>abortBroadcast()</code>, <code>setResultCode()</code>和<code>setResultData()</code>方法, 接收者可以把结果回传给广播, 或者终止广播的分发, 这样<code>Intent</code>就不会传递给下一个广播接收者.</li>
</ul>
<p>有序广播由<code>Context.sendOrderedBroadcast()</code>发起, 在接收者的<code>onReceive()</code>回调中, 通过<code>isOrderedBroadcast()</code>来判断该广播是否是有序广播. 如果是, 可以通过上面<code>setXxxx()</code>方法设置要传递下去的数据.</p>
<p>日常开发很少需要在自己的应用程序发送有序广播, 但如果要跟其他应用程序通信(比如插件), 有序广播就有用途. 在Android系统中, 有序广播最常见的场景就是监听传入的短信(隐藏API)的一部分. 后面篇幅会说.</p>
<h3 id="粘性广播"><a href="#粘性广播" class="headerlink" title="粘性广播"></a>粘性广播</h3><p><code>粘性广播(sticky broadcast)</code> 是一个普通广播的变体, 它和普通广播有细微的区别. 粘性广播在使用<code>Context.sendStickyBroadcast()</code>发送<code>Intent</code>之后, 该<code>Intent</code>还会”继续保留”, 允许之后匹配由该<code>Intent</code>新注册的广播接收者, 并发送<code>Intent</code>.(<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/ec42e2e44877f5b4b3c5363600646c4e808929e3" target="_blank" rel="external">查看验证代码</a>)</p>
<p>粘性广播的一个例子是<code>Intent.ACTION_BATTERY_CHANGED</code>, 它用来指示设备中电池电量的变化. 另一个列子是<code>Intent.ACTION_DOCK_EVENT</code>, 用来只是设备是否放在了底座. 更多的粘性广播请参考google文档. 下面的代码展示如何</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private void myRegisterBattery()&#123;</div><div class="line">   // 构建广播接收者要接收的action</div><div class="line">   IntentFilter intent = new IntentFilter();</div><div class="line">   intent.addAction(Intent.ACTION_BATTERY_CHANGED);</div><div class="line">   intent.addAction(Intent.ACTION_BATTERY_OKAY);</div><div class="line">   intent.addAction(Intent.ACTION_BATTERY_LOW);</div><div class="line">   </div><div class="line">   // 创建监听</div><div class="line">   BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123;</div><div class="line">       @Override</div><div class="line">       public void onReceive(Context context, Intent intent) &#123;</div><div class="line">           if (isInitialStickyBroadcast()) &#123;</div><div class="line">               Log.e(&quot;sususu&quot;, &quot;这是一个粘性广播&quot;);</div><div class="line">           &#125; else &#123;</div><div class="line">               Log.e(&quot;sususu&quot;, &quot;这是不是粘性广播&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   // 注册接收者</div><div class="line">   registerReceiver(broadcastReceiver, intent);</div><div class="line">&#125;</div><div class="line">​``` </div><div class="line"></div><div class="line">该方法在广播全系统的状态时特别有用, 如果你需要发送粘性广播, 那么**请添加权限**在清单文件中`&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt;`权限, 并使用`Context.sendStickyBroadcast()`发送粘性广播. </div><div class="line"></div><div class="line">&gt; 对于粘性广播一定要慎用, 因为它比普通广播更消耗资源.</div><div class="line"></div><div class="line"></div><div class="line">### 定向广播</div><div class="line"></div><div class="line">普通广播的另一个变体是`定向广播(directed broadcast)`. 定向广播使用过了`intent-filter`的一个特性, 通过在`Intent`设置`ComponentName`来显示指定接收者. 它把注册接收者的类名和包名结合在了一起. 如下:</div><div class="line"></div><div class="line"></div><div class="line">​```java</div><div class="line">Intent intent = new Intent();</div><div class="line">intent.setComponent(new Component(packName, className));</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<p>这个例子只会指定的class类的广播接收者才可以收到广播, 即便其他接收器也注册了相同的<code>Intent</code>操作. <strong>注意:使用定向广播需要同时知道接收者的包名和类名.</strong>. 使用场景很少.</p>
<h3 id="启动和禁用广播接收器"><a href="#启动和禁用广播接收器" class="headerlink" title="启动和禁用广播接收器"></a>启动和禁用广播接收器</h3><p>如果广播接收者在清单文件中注册的, 还有另外一种减少对系统负载的影响的方法. 通过<code>PackageManager</code>, 开发者可以启动和禁用应用程序的组件, 这在用户比如在应用设置更改后使用此方法即可. 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 设置组件</div><div class="line">* @param setClass 要设置改变的组件</div><div class="line">* @param isEnable true为启用, false为禁用</div><div class="line">*/</div><div class="line">public void setComponentEnable(boolean isEnable, Class setClass)&#123;</div><div class="line">   PackageManager pm = getPackageManager();</div><div class="line">   // 构建要改变组件的Component</div><div class="line">   ComponentName componentName = new ComponentName(getApplicationContext(), setClass);</div><div class="line">   pm.setComponentEnabledSetting(componentName,</div><div class="line">           isEnable ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</div><div class="line">           PackageManager.DONT_KILL_APP);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>记住, 这里仅适用静态注册就是清单文件上注册, 不支持动态注册的会抛出异常, 并且这里接收的class同样适用于Activity, Service, ContentProvider</code>. 其本质就是改变在清单文件中组件标签的<code>&lt;android:enable=&#39;true/false&#39;&gt;</code>.</p>
<p>关于<code>setComponentEnabledSetting()</code>方法的最后一个参数<code>PackageManager.DONT_KILL_APP</code>的使用. 这回防止平台杀死应用, 如果不设置该值平台默认会杀死应用.</p>
<blockquote>
<p>可以用在应用程序启动图标的切换, 比如,开发者可以在安装应用程序后只显示设置Activity界面, 在设置完成之后使用该方法把启动图标隐藏</p>
</blockquote>
<h3 id="系统广播Intent"><a href="#系统广播Intent" class="headerlink" title="系统广播Intent"></a>系统广播Intent</h3><p><code>Android API</code>定义了许多不同的系统广播事件. 例如电池电量变化, 是否连接了设备电源. 并且还有一些可能会用到的广播, 但是action并没有在API中公开, 所以后面的篇幅也会对一些隐藏的API进行一定记录.这里说一下常用的系统事件</p>
<hr>
<p><strong>自动启动应用程序</strong></p>
<p>关于自启动这个问题在国内比较蛋疼, 由于各种厂商对<code>ROM</code>的修改, 各式各样. 目前为我自己的实验是只有<code>Google Nexus4</code>可以直接声明<code>BOOT_complete</code>重启的广播, <code>魅族4</code>,<code>三星S6</code>都无法做到重启可以监听到重启广播. 需要对应用通过手机提供的应用管理, 把<code>自启动开启才可以达到预期的效果</code>. 这里尝试的做法是<code>注册监听重启广播的接收</code>, <code>添加权限&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;</code>, <code>添加&lt;manifest&gt;标签的内属性android:installLocation=&quot;internalOnly&quot;</code>确保应用正确安装到内存储位置.</p>
<p>广播的监听的对应action:<code>android.intent.action.BOOT_COMPLETED</code></p>
<p>还有一个应用程序包替换的时候的广播, 例如升级<code>android.intent.action.MY_PACKAGE_REPLACED</code></p>
<hr>
<p><strong>用户状态和屏幕状态</strong></p>
<p>虽然当按下关机键和锁屏键会触发屏幕熄灭, <code>Activity</code>会调用对应的焦点失去或者获取的回调. 但是如果服务<code>Service</code>需要注意此动作的时候, 我们通过屏幕的状态广播来监听这是很方便的.</p>
<p>相关广播<code>action</code></p>
<ul>
<li><code>action.intent.action.SCREEN_OFF</code></li>
<li><code>action.intent.action.SCREEN_ON</code></li>
<li><code>action.intent.action.SCREEN_PRESENT</code></li>
</ul>
<p>开启和关闭设备屏幕时, 系统会分别发送<code>Intent.ACTION_SCREEN_ON</code>和<code>Intent.ACTION_OFF</code>广播事件. 当用户解锁屏幕时系统会发送<code>Intent.ACTION_USER_PRESENT</code>广播事件.</p>
<hr>
<p><strong>网络和连接变化</strong></p>
<p>大多数<code>Android</code>设备都支持两种类型的网络: <strong>蜂窝网络</strong>和<strong>Wi-Fi网络</strong>. 如果应用程序过度依赖网络操作, 开发者可能要在蜂窝网络中推迟数据的传输, 知道设备连接到<code>Wi-Fi网络</code>; 否则, 如果使用<code>3G</code>, <code>LTE</code>之类的移动网络传输可能会产生相当可观的流量.</p>
<p>连接的相关广播和网络相关的广播分别由不同的API负责. 每当有通用的网络连接变化发生时, 比如从<code>Wi-Fi</code>切换到移动数据, 系统就会发送<code>ConnectivityManager.CONNECTIVITY_ACTION</code>广播, 接下来可以使用<code>Context.getService()</code>方法来检索<code>ConnectivityManager</code>服务, 它允许开发者获取当前网络的更多信息.</p>
<p>然而, 要获取当前网络更细粒度的信息, 开发者还需要监听来自<code>TelephonyManager</code>和<code>WifiManager</code>的广播事件. <code>TelephonyManager</code>允许查询移动数据连接的类型, <code>WiFiManager</code>允许检索<code>WiFi</code>连接状态并访问和<code>WiFi</code>相关的不同<code>ID(SSID是wifi名称和BSSID对应mac地址)</code></p>
<p>以下代码会检测设备是否连接到了预先设置的某一个<code>WiFi</code>. 使用此方法可以有效地和服务器或者只是支持特定的<code>Wi-Fi</code>的媒体进行通信.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 检查wifi广播--&gt;</div><div class="line">&lt;receiver</div><div class="line">  android:name=&quot;broadcast.CheckForHomeWifi&quot;&gt;</div><div class="line"></div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;!--监听wifi的连接状态是否连接上一个有效无线路由--&gt;</div><div class="line">      &lt;action android:name=&quot;android.net.wifi.WIFI_STATE_CHANGED&quot; /&gt;</div><div class="line">      &lt;!--监听wifi的打开和关闭, 和wifi具体的连接不关心--&gt;</div><div class="line">      &lt;action android:name=&quot;android.net.wifi.STATE_CHANGE&quot; /&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line"></div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p>如果只需要关心wifi的开启, 和wifi连接到某一个路由, 那么这两个广播监听足够了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onReceive(Context context, Intent intent) &#123;</div><div class="line"></div><div class="line">   // 需要判断的路由名字 对应ssid </div><div class="line">   String name = &quot;\&quot;ziroom502\&quot;&quot;;</div><div class="line"></div><div class="line">   // 1.首先判断wifi是否开启, 并连接</div><div class="line">   NetworkInfo networkInfo = intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);</div><div class="line">   if (networkInfo != null &amp;&amp; networkInfo.getState().equals(NetworkInfo.State.CONNECTED)) &#123;</div><div class="line"></div><div class="line">       // 2.再判断连接的wifi的具体信息</div><div class="line">       WifiInfo WifiInfo = intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);</div><div class="line">       if (WifiInfo != null &amp;&amp; name.equals(WifiInfo.getSSID())) &#123;</div><div class="line">           Log.d(&quot;sususu&quot;, &quot;连接到指定wifi&quot;);</div><div class="line">       &#125; else &#123;</div><div class="line">           Log.d(&quot;sususu&quot;, &quot;连接到其他wifi&quot;);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个简单的初步判断, 如果需要结合手机连接判断, 结合下面的另一个监听, 整合起来就差不多了.</p>
<hr>
<p>这个监听来自<code>ConnectivityManager</code>的变化, 并确定当前连接的是否为移动数据网络. 如果收到移动数据, 接下来在使用<code>TelephonyManager</code>检查是否在使用<code>3G</code>或者<code>LTE</code>网络.</p>
<p>监听广播的清单文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> &lt;!--判断手机连接--&gt;</div><div class="line">&lt;receiver</div><div class="line">  android:name=&quot;broadcast.WhenOn3GorLTE&quot;&gt;</div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;!--此广播监听, 网络连接的设置包括wifi和数据的打开和关闭--&gt;</div><div class="line">      &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public class WhenOn3GorLTE extends BroadcastReceiver &#123;</div><div class="line">    private static final String TAG = WhenOn3GorLTE.class.getSimpleName();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line">        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action))&#123;</div><div class="line">            boolean noConnectivity = intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);</div><div class="line">            </div><div class="line">            if (noConnectivity)&#123;</div><div class="line">                Log.e(TAG, &quot;没有连接&quot; );</div><div class="line">            &#125;else&#123;</div><div class="line">                int networkType = intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_DUMMY);</div><div class="line">                </div><div class="line">                if (networkType == ConnectivityManager.TYPE_MOBILE)&#123;</div><div class="line">                    checkfor3GorLte(context);</div><div class="line">                &#125;else&#123;</div><div class="line">                    Log.i(TAG, &quot;不是移动连接&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     *  当前如果移动数据开启, 那么显示出移动数据的连接类型</div><div class="line">     */</div><div class="line">    private void checkfor3GorLte(Context context)&#123;</div><div class="line"></div><div class="line">        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</div><div class="line"></div><div class="line">        switch (telephonyManager.getNetworkType())&#123;</div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSDPA:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSDPA&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSPA:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSPA&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSPAP:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSPAP&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_HSUPA:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_HSUPA&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case TelephonyManager.NETWORK_TYPE_LTE:</div><div class="line">                Log.d(TAG, &quot;连接类型: NETWORK_TYPE_LTE&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">            default:</div><div class="line">                Log.d(TAG, &quot;连接类型: 未知类型, 可能传输速度会慢&quot;);</div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>此广播稍微有2秒左右延迟, 当wifi开关,和移动数据开关变化的时候不会立即响应</strong></p>
<p>一下记录一下测试的结果广播接收情况,以上判断条件是获取的<code>intent中的ConnectivityManager.EXTRA_NO_CONNECTIVITY</code>(测试手机三星S6), 可能会因为不同的条件产生不同的结果. 这里只说明代码中的条件说明:</p>
<ul>
<li><code>当wifi连接开启</code>: 这时打开或者关闭移动数据, 不会发送广播.</li>
<li><code>当移动数据开启</code>: 这时操作wifi开关会接收到两个广播.</li>
<li><ul>
<li>如果从<code>wifi关闭</code>-&gt;<code>wifi开启</code>那么首先会发送一个<code>移动数据的状态info广播</code>,紧接着会发送一个<code>wifi连接</code>相关的广播(总共两个有效连接)</li>
</ul>
</li>
<li><ul>
<li>如果<code>wifi开启</code> -&gt; <code>wifi关闭</code>那么首先会收到一个<code>无连接</code>的广播, 然后会接收到一个<code>移动数据</code>连接类型的广播.</li>
</ul>
</li>
<li><code>如果当都关闭的时候</code>: 开启任意一个只能接收到一个广播.</li>
</ul>
<p>这种方式也可以获取<code>wifi</code>连接的信息, 但是<strong>延迟性</strong>是这个方式的特点.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/" data-id="cj7hnifdw00176opj1wh47t2d" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap6_重识BroadcastReceiver/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap5_重识IPC" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/">《Android 编程实战》Chap5_重识IPC</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/">
            <time datetime="2017-09-11T23:54:53.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Binder简介"><a href="#Binder简介" class="headerlink" title="Binder简介"></a>Binder简介</h2><p><code>Android</code>有一个强大的功能, 就是能够在不同应用程序之间进行通信. 绝大部分的实现都是由<code>Binder IPC(Inter-Process Communication)</code>进行处理的.</p>
<p><code>Android</code>中的<code>Binder</code>有着悠久的历史. 最终它的名字叫做<code>OpenBinder</code>, 是Be公司开发的Be操作系统(BeOS). 后来被移植到<code>Android</code>平台, 并且进行了重写以支持应用程序间的IPC. 基本上<code>Binder</code>提供了在不同执行环境间绑定功能和数据的特性. <code>Binder</code>非常适合在<code>Android</code>应用程序间进行通信, 因为每个<code>Android</code>应用程序都运行在自己的<code>Dalvik</code>虚拟机里, 而每个虚拟机又是独立的运行环境.</p>
<blockquote>
<p>在2009年, <code>Linux</code>社区就谷歌选择<code>Binder</code>而非选择<code>dbus</code>的原因有过很长时间的争论, 因为在此之前<code>Linux</code>内核一直使用<code>dbus</code>来实现IPC机制. 最开始开发<code>Android</code>时, <code>Binder</code>成了IPC的最佳选择, 如今它已成为<code>Android</code>系统的一个组成成分. <code>Linux</code>中的<code>dbus</code>机制也用在许多的<code>Android</code>设备上, 特别是为无线接口层(Radio Interface Layer, RIL)通信以及<code>Android 4.3</code>以后的蓝牙通信. 但大部分IPC还是<code>Binder</code>.</p>
</blockquote>
<p>使用<code>Binder IPC</code>进行通信时, 两个应用程序使用内核驱动来传递消息(如下图), 除了发送消息, <code>Binder</code>还提供了其他功能, 比如识别远程调用者(进程ID和用户ID), 以及当远程进程被烧死(<code>link-to-death</code>)时发送通知.</p>
<p><img src="http://szysky.com/2016/09/28/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B05-%E9%87%8D%E8%AF%86-IPC/BinderIPC.png" alt="img"></p>
<p>例如, 当<code>系统Service</code>(通过WindowManager管理Android所有窗口)为每个应用保持一个<code>Binder</code>引用时会调用这些附加函数, 当应用窗口关闭时会收到link-to-death通知.</p>
<p><code>Binder</code>通信遵循<strong>客户端-服务端模式</strong>, 客户端使用客户端代理来处理与内核驱动程序的通信. 在服务器端, <code>Binder</code>框架维护了一系列<code>Binder线程</code>. 内核驱动会使用服务端的<code>Binder</code>线程把消息从客户端代理分发个接收对象. 这一点需要特别注意, 因为当通过Binder接收<code>Service</code>调用时, 他们并不会运行在应用程序的主线程上, 这样一来, 客户端连接远程Service的连接就不会阻塞应用的主线程.</p>
<h3 id="Binder地址"><a href="#Binder地址" class="headerlink" title="Binder地址"></a>Binder地址</h3><p>使用<code>Binder</code>通信时, 客户端需要知道远程<code>Binder</code>对象的地址. 然而, <code>Binder</code>的设计要求只有实现类(比如要调用的Service)才知道该地址. 开发者使用<code>Intent</code>解析来进行寻址. 客户端使用<code>action</code><br>字符串或者组件名(componentName)来构造<code>Intent</code>对象, 然后使用它初始化于远程应用程序的通信. <code>Intent</code>只是实际<code>Binder</code>地址的抽象描述, 为了能够建立通信, 还需要翻译成实际的地址.</p>
<p><code>ServiceManager</code>是一个特殊的<code>Binder</code>节点, 它运行在<code>Android</code>系统服务内, 管理所有的地址解析, 是唯一一个有全局地址的<code>Binder</code>节点. 因为所有的<code>Android组件</code>都是用<code>Binder</code>进行通信, 所以它们需要使用<code>ServiceManager</code>进行注册.</p>
<p>客户端要想和<code>Service</code>或者其他组件进行通信, 需隐式地通过<code>Intent</code>查询<code>ServiceManager</code>来接收<code>Binder</code>地址.</p>
<h3 id="Binder事务"><a href="#Binder事务" class="headerlink" title="Binder事务"></a>Binder事务</h3><p>在<code>Android</code>中, <strong>事务(transaction)</strong>是指一个进程发送数据到另一个进程. 在<code>Binder</code>上开启事务首先会在客户端调用<code>IBinder,transact()</code>, 然后<code>Service</code>收到<code>Binder.onTranscat()</code>方法回调.</p>
<p>如下演示了在客户端如何使用<code>IBinder</code>引用向服务端执行自定义的<code>Binder</code>事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public String performCustomBinderTransaction(IBinder binder, String arg0, int arg1) throws RemoteException &#123;</div><div class="line"></div><div class="line">   Parcel request = Parcel.obtain();</div><div class="line">   Parcel response = Parcel.obtain();</div><div class="line"></div><div class="line">   // 组装请求数据, 要发送到服务端的</div><div class="line">   request.writeString(arg0);</div><div class="line">   request.writeInt(arg1);</div><div class="line"></div><div class="line">   // 执行事务</div><div class="line">   binder.transact(IBinder.FIRST_CALL_TRANSACTION, request, response, 0);</div><div class="line"></div><div class="line">   // 从响应中读取结果</div><div class="line">   String result = response.readString();</div><div class="line"></div><div class="line">   // 释放资源, 以便循环利用</div><div class="line">   request.recycle();</div><div class="line">   response.recycle();</div><div class="line"></div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而服务端会实现一个继承<code>Binder</code>类, 通过<code>onTransact()</code>来接收客户端的数据, 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class ServerBinder extends Binder &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</div><div class="line">//        return super.onTransact(code, data, reply, flags);</div><div class="line"></div><div class="line">        // 开始读取客户端发送的请求数据</div><div class="line">        String arg0 = data.readString();</div><div class="line">        int arg1 = data.readInt();</div><div class="line"></div><div class="line">        // 处理接收结果, 并生成返回的数据</div><div class="line">        String result = buildResult(arg0, arg1);</div><div class="line"></div><div class="line">        // 把结果写入想用Parcel</div><div class="line">        reply.writeString(result);</div><div class="line"></div><div class="line">        // 成功后返回true</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String buildResult(String arg0, int arg1)&#123;</div><div class="line">        String result = null;</div><div class="line"></div><div class="line">        // ...这里省略业务逻辑, 以后可自行添加</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上, 因为属于作为远程服务端中实现自定义的<code>Binder</code>对象时没有使用<code>AIDL</code>. 所以这里需要自己处理<code>onTransact()</code>方法.</p>
<p>上面两个代码通过<code>Binder IPC</code>进行的同步双向调用. 也可在客户端执行单项的调用, 只需在客户端发送事务的方法进行相应更改即可, 如<code>IBinder.transact()</code>方法调用中把标识位设置为<code>FLAG_ONEWAY</code>, 这样就可以把第二个<code>Parcel</code>参数设置为null. 单项调用会提供更好的性能, 因为只需对一个<code>Parcel</code>对象进行编解码操作.</p>
<p>当然这里只是让其了解一下流程, 当真正实现进程间通信, 或者提供其他应用调用的API的时候不会直接操作这种底层的方式在两个程序之间执行事务, 而是使用对这种事务进行进一步封装的<code>AIDL</code>或者<code>Messenger</code>等.<br>而对于更细粒度地控制数据如何应用间发送, 使用底层binder操作事务这是正确的.</p>
<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p><code>Binder</code>事务通常会传递事务数据, 这种数据被称为<code>Parcel</code>(包裹).</p>
<p><code>Android</code>中的<code>Parcel</code>和<code>Java SE</code>中序列化对象类似, 不同之处在于, 开发者需要使用<code>Parcelable</code>接口实现对象的编解码工作. 该接口定义了两个编写<code>Parcel</code>对象的方法, 以及一个静态的不可被复写的<code>Creator</code>对象, 该对象用来从<code>Parcel</code>中读取相应的对象.</p>
<h3 id="link-to-death"><a href="#link-to-death" class="headerlink" title="link to death"></a>link to death</h3><p><code>Binder</code>的另一个特点, 允许客户端在<code>Service</code>终止的时候收到通知. 这就被称为<code>link to death</code>.</p>
<p><code>Binder</code>的<code>IBinder.linkToDeath()</code>方法实现了该机制. 当客户端在<code>onServiceConnected()</code>方法中收到<code>IBinder</code>对象, 它可以用实现了<code>IBinder.DeathRecipient</code>接口的参数调用<code>linkToDeath()</code>方法. 因为<code>Android</code>可能在资源不足的(RAM)时被系统杀死, 在客户端注册远程被终止的监听通知会很有用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> /*</div><div class="line">  * ClassDescription: 无实际意义, 只为演示如何使用IBinder注册link-to-death</div><div class="line">  */</div><div class="line">public class LinkToDeathSample extends Service &#123;</div><div class="line"></div><div class="line">    private static final String TAG = LinkToDeathSample.class.getSimpleName();</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     *  对客户端提供注册方法</div><div class="line">     */</div><div class="line">    private void notifyRemoteServiceDeath(IBinder iBinder )&#123;</div><div class="line">        try &#123;</div><div class="line">            iBinder.linkToDeath(new MyLinkToDeath(), 0);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class MyLinkToDeath implements IBinder.DeathRecipient&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void binderDied() &#123;</div><div class="line">            // 处理远端binder被杀死的情况</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以调用<code>IBinder.pingBinder()</code>检查远端的<code>Binder</code>进程是否处于活动状态. 如果结果为true, 表明远端的进程处于活跃可用的状态.</p>
<p>如果绑定到的是<code>Service</code>那么就不需要监听了, 因为断开连接时总会是伴随着<code>ServiceConnection.onServiceDisconnected()</code>函数被回调. 但是, 如果使用其他方式接受<code>Binder</code>对象, 该方法可能就有用处了.</p>
<h2 id="设计API"><a href="#设计API" class="headerlink" title="设计API"></a>设计API</h2><p>虽然大多数的应用都不需要为第三方应用提供API, 但是说不定哪一天领导就突发奇想的想要这个结果.</p>
<p>可以使用<code>Service</code>或者<code>ContentProvider</code>为第三方应用开发API. 这里先介绍使用<code>Service</code>提供API. 在后续的篇幅会展示如何使用<code>ContentProvider</code>. 当实现API是, 开发者还需要考虑的因素: 是否需要处理并发请求? 每次只处理一个客户端请求是否足够? API是否只包含一个或是很少的操作? 或者是一组更加复杂的方法? 这些问题的答案将决定实现远程API最合适的方法.</p>
<p>另一个问题考虑的细节是否与其他开发者分享该API? 或者只是用于自己的应用? 如果是第一种情况 , 可以考虑构建一个库工程, 使用易于使用的Java API包装客户端的实现. 如果只是自己使用API, 那么可以使用<code>Messenger</code>或者<code>AIDL</code>, 下面我们将针对这两个使用展开.</p>
<h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>在软件工程中, <strong>接口定义语言</strong>(Interface Definition Language,IDL)已经成为通用的术语. 是用来描述软件组件接口的特定语言. 在<code>Android</code>中, 该<code>IDL</code>被称为<code>Android接口定义语言(AIDL)</code>. 它是纯文本文件, 使用Java类似语法编写. 但是, 编写Java接口和编写AIDL文件还有所有不同:</p>
<ul>
<li>首先, 对所有的非原始数据类型参数, 需要指定如下三种类型方向指示符之一:<code>in</code>, <code>out</code>, <code>inout</code>.<code>in</code>类型方向指示符只用于输入, 客户端不会看到<code>Service</code>对对象的修改. <code>out</code>类型表明输入对象不包含相关的数据, 但会由<code>Service</code>生成相关的数据. <code>inout</code>类型是上面两种类型的结合. 切记只使用需要的类型, 因为每种类型都有相应的消耗.</li>
<li>所有用于通信的自定义都需要创建一个<code>AIDL</code>文件, 用来声明该类实现了<code>Parcelable</code>接口.</li>
</ul>
<p>整理一下步骤:</p>
<ol>
<li>首先创建<code>AIDL</code>文件, 为了客户端和服务端后续的使用. <a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/592cd9ef1db38fc768e5defe87be6bc7c50f1801" target="_blank" rel="external">参考链接</a> 注意: 在<code>IMyApiInterfaceV1.aidl</code>文件中对<code>CustomData</code>进行了手动的<code>import</code>导入, 并且当作为参数传递的时候使用了<strong>方向指示符</strong>,因为只有原始数据类型才不需要<strong>方向指示符</strong>,因只调用其值.(有一个<code>CustomData</code>在下次参考链接中可以看到, 应该属于这一个步骤的)</li>
<li>然后对客户端服务端进行代码实现. <a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/2aa6da78376f33ac4aa3ad2f386c388ade0d6e0c" target="_blank" rel="external">参考链接</a>. 现在客户端就可以利用<code>Binder</code>调用远程的服务实现的<code>IBinder</code>方法. <strong>注意:</strong>一旦客户端实现了代码, 那么就不要在修改或者移除AIDL文件中的方法. 可以在文件末尾添加新的方法, 因为AIDL编译器会为每一个方法生成标识符, 所以不能修改现存的方法, 否则不能向后兼容老版本. 这个方法使用AIDL的缺点就是如上. 解决方案中的一种方法就是提供Java包装类, 并以库工程或者.jar文件的形式发布一遍使用. 后续会说道.</li>
<li>现在可以考虑是否需要对客户端进行回调. 如果需要,那么相同的步骤创建<code>AIDL</code>接口文件. 并在客户端实现接口文件. 在服务端使用的<code>AIDL</code>文件中添加新的方法, 这个方法用来在服务端注册一个客户端回调. 客户端的回调通过方法的参数传入, 并在客户端获取远程服务端的<code>Binder</code>对象进行注册方法调用.<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/7e75d4d7b8aa27521952dac87b5fe3d951b5e5b1" target="_blank" rel="external">参考链接</a></li>
</ol>
<p>关于客户端实现AIDL文件的时候, 在使用了<code>oneway</code>关键字, 这会告诉AIDL编译器该接口只是单向通信. 对调用者(本类中的Service)的响应不是必须的. 这样做会轻微的性能提升. 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.szysky.note.ipc.aidl;</div><div class="line"></div><div class="line">import com.szysky.note.ipc.aidl.CustomData;</div><div class="line"></div><div class="line">oneway interface IMyAidlCallback &#123;</div><div class="line">  void onDataUpdated(in CustomData[] data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里, 说明了两个应用之间传输Binder对象, 而不需要使用<code>ServiceManager</code>注册它. 由于只有客户端和<code>Service</code>知道<code>Binder</code>的地址, 因此它可以作为一种高效的IPC安全机制.</p>
<h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>使用<code>Messenger</code>进行远程通信, 有时会更简单, 当然使用场景是<strong>Service不需要支持并发操作时就可以选择使用Messenger信使来跨进程通信</strong>. <code>Messenger</code>使用<code>Handler</code>执行每个传入的消息, 所有的客户端的调用按顺序运行在同一个线程上.</p>
<ul>
<li><strong>服务端的实现</strong>: 在<code>onCreate()</code>中构建<code>Messenger</code>, 然后在<code>onBind()</code>中返回<code>Binder</code>对象. 当<code>Messenger</code>接收到消息的时候, 它可以使用在<code>replyTo</code>成员变量里的Messenger对象响应客户端都请求.<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/8833697273dc9bb0cda6850d76c82b1ffcc2d47b" target="_blank" rel="external">参考链接</a></li>
<li><strong>客户端的实现</strong>: 为了可以在服务端响应回来数据, 在<code>onCreate()</code>方法中, 同样构建一个<code>Messenger</code>作为客户端的信使. 然后在<code>onResume()</code>进行服务绑定, 在<code>ServiceConnection#onServiceConnected()</code>回调中通过获取的<code>IBinder</code>来还原出服务端的<code>Messenger</code>. 然后就可以调用其<code>send(Message)</code>方法向远程发送消息. 当然参数中的<code>Message</code>需要新建一个. 如果要做到回应客户端那么使用<code>Message.replyTo=本地Messenger实例</code>, 这样就可以在客户端构建的Messenger时传入的<code>Handler.callback()</code>接收处理.<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/4b0f94b6a39a09e0a67784f8476ac839c13d1ed7" target="_blank" rel="external">参考链接</a></li>
</ul>
<p>这种方法和<code>IntentServiec</code>很相似, 但本例没有使用<code>Intent</code>, 而是使用<code>Message</code>触发<code>Handler</code>的操作. 此外, <code>Messenger</code>实现异步通信很方便, 并且也不需要使用<code>BroadcastReceiver</code>.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/" data-id="cj7hnife1001d6opjiaoxcjhq" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap5_重识IPC/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap4_手势操作进阶, 重识Service" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/11/android/books/《Android 编程实战》Chap4_手势操作进阶, 重识Service/">《Android 编程实战》Chap4_手势操作进阶, 重识Service</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/11/android/books/《Android 编程实战》Chap4_手势操作进阶, 重识Service/">
            <time datetime="2017-09-11T13:36:48.000Z" itemprop="datePublished">2017-09-11</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="设计自定义视图"><a href="#设计自定义视图" class="headerlink" title="设计自定义视图"></a>设计自定义视图</h2><h3 id="View的声明周期"><a href="#View的声明周期" class="headerlink" title="View的声明周期"></a>View的声明周期</h3><p><code>View</code>也有自己的声明周期. 该生命周期并不直接和展示它的<code>Fragment</code>或者<code>Activity</code>相连, 相反<strong>它和显示它的窗口状态以及渲染循环相关</strong></p>
<p>当视图被添加到View层级结构中时, 第一个被回调的函数是<code>View.onAttachedToWindow()</code>, 这标志着它现在可以加载所需的资源了. 构建自定义视图时, 开发者应该重载该方法, 并在该方法中加载所有资源并初始化视图所需的依赖. 基本上所有的耗时的初始化都应该放在这个方法内.</p>
<p>还要一个匹配的回调名为<code>View.onDetachedFromWindow()</code>, 从View层次结构中移除视图时调用这个方法. 在这里需要关注的是需要显示清理的操作, 比如所有被加载的资源, 启动的<code>Service</code>, 或者其他依赖.</p>
<p>视图被添加到<code>View</code>层次结构中之后, 它会经过一个循环, 该循环首先计算动画, 接下来会一次回调<code>View.onMeasure()</code>, <code>View.onLayout()</code>, <code>View.onDraw()</code>等方法.</p>
<h3 id="多点触控"><a href="#多点触控" class="headerlink" title="多点触控"></a>多点触控</h3><p>先看下图效果:</p>
<p><img src="http://szysky.com/2016/09/26/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B04-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-Service/multi1.gif" alt="img"></p>
<p>贴一下实现的主要代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(final Canvas canvas) &#123;</div><div class="line">   super.onDraw(canvas);</div><div class="line"></div><div class="line">   // 绘制已经完成过的手势事件的所有path路径</div><div class="line">   // 如果不循环绘制, 那么当一个触控点到达了up事件之后, 那么这个触控点从down到up的事件的轨迹将会消失.</div><div class="line">   for (Path completedPath : mCompletedPaths) &#123;</div><div class="line">       canvas.drawPath(completedPath, mFingerPaint);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // 绘制当前触摸屏上的触摸事件正在进行的轨迹 (down ~ up)</div><div class="line">   for (Path fingerPath : mFingerPaths) &#123;</div><div class="line">       if (fingerPath != null)&#123;</div><div class="line">           canvas.drawPath(fingerPath, mFingerPaint);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">   // 获得当前触摸屏上的触摸个数</div><div class="line">   int pointerCount = event.getPointerCount();</div><div class="line">   int cappedPointerCount = pointerCount &gt; MAX_FINGERS ? MAX_FINGERS : pointerCount;</div><div class="line"></div><div class="line">   // 获得当前触摸事件对象所在系统保存队列中的位置</div><div class="line">   int actionIndex = event.getActionIndex();</div><div class="line">   // 获得当前触摸事件的动作类型,  这里包括 MotionEvent.ACTION_POINTER_DOWN, MotionEvent.ACTION_POINTER_UP 多点触控按下和多点触控抬起(对应数值5, 6)</div><div class="line">   int action = event.getActionMasked();</div><div class="line">   // 此值返回此触摸事件存在时刻的唯一标识id.</div><div class="line">   int pointerId = event.getPointerId(actionIndex);</div><div class="line"></div><div class="line"></div><div class="line">   // 检查是否收到按下或者抬起的动作</div><div class="line">   if ((action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) &amp;&amp; pointerId &lt; MAX_FINGERS )&#123;</div><div class="line">  </div><div class="line">       // 当有新的触摸事件开始的时候, 就使用这个事件的标识id来当下标创建一个Path对象存储起来</div><div class="line">       mFingerPaths[pointerId] = new Path();</div><div class="line">       // 注意虽然在down事件中, actionIndex和pointerId会保持一致, 但最好使用触摸事件所在的队列位置来获取坐标</div><div class="line">       mFingerPaths[pointerId].moveTo(event.getX(actionIndex), event.getY(actionIndex));</div><div class="line">  </div><div class="line"></div><div class="line">   &#125;else if ((action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP) &amp;&amp; pointerId &lt; MAX_FINGERS)&#123;</div><div class="line">       // 这里的pointerId和actionIndex不一定保持一致!! 所以一定要正确使用这个两个来获取</div><div class="line">       mFingerPaths[pointerId].setLastPoint(event.getX(actionIndex), event.getY(actionIndex));</div><div class="line">       mCompletedPaths.add(mFingerPaths[pointerId]);</div><div class="line"></div><div class="line">       mFingerPaths[pointerId].computeBounds(mPathBounds, true);</div><div class="line">       invalidate((int) mPathBounds.left, (int) mPathBounds.top, (int) mPathBounds.right, (int) mPathBounds.bottom);</div><div class="line">       mFingerPaths[pointerId] = null;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   int tempIndex = 0;</div><div class="line">   // 这里主要是move事件时候进行的动态绘制实现</div><div class="line">   for (int i = 0; i &lt; cappedPointerCount; i++) &#123;</div><div class="line">       // 保证滑动事件不丢失</div><div class="line">       while(mFingerPaths[tempIndex] == null)&#123;</div><div class="line">           tempIndex++;</div><div class="line">           if (tempIndex &gt; 4)&#123;</div><div class="line">               return true;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       if (mFingerPaths[tempIndex] != null)&#123;</div><div class="line">           // 通过数组的下标也就是触摸事件的唯一标识id获得队列中的位置</div><div class="line">           int index = event.findPointerIndex(tempIndex);</div><div class="line">           // 对从down事件或者上一次移动事件的Path进行lineTo移动.</div><div class="line">           mFingerPaths[tempIndex].lineTo(event.getX(index), event.getY(index));</div><div class="line">           mFingerPaths[tempIndex].computeBounds(mPathBounds, true);</div><div class="line">           invalidate((int) mPathBounds.left, (int) mPathBounds.top, (int) mPathBounds.right, (int) mPathBounds.bottom);</div><div class="line">           tempIndex++;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是伪代码, 如果想需要完整类,<a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/blob/master/MultiTouch/app/src/main/java/com/szysky/note/multitouch/MultiTouchView.java" target="_blank" rel="external">点击此链接到github查看</a></p>
<p>这里在进行解释说明一下:</p>
<p>每次时间发生改变的时候<code>onTouchEvent(MotionEvent)</code>都会被回调. 并且<code>MotionEvent</code>会保存当前时间点的所有<strong>触摸点的事件</strong>.</p>
<hr>
<p>举例一个场景: <strong>当三个手指同时按下</strong></p>
<p>首先系统内部有一个保存当前多点触摸事件的<strong>集合</strong>,由于跟进源码后发现方法调用的是本地方法,所以只能从出现的规律可以反推出这个集合应该是一个<strong>队列</strong>.从以下结果也可以看出.</p>
<p>虽然三个手指同时按下, 但是会依次触发<code>onTouchEvent()</code>回调. 也就是说会走三遍此回调. 当第一个触摸事件发生<code>down</code>时. 系统会创建保存一个事件对象并给这个对象的<code>pointerID</code>赋一个<code>0</code>的值并放到队列的首部, 这时当多点触控的第二个触摸事件按下的时候. 系统会遍历队列中的触摸事件的<code>pointerID</code>,如果队列第一个对象的<code>pointerID</code>不等于0那么就插入在这个对象的头部,如果等于继续下一个元素,如果下一个对象的<code>pointerID为1(就是顺序递增的效果)</code>那就继续遍历下一个元素,如果不是那就插入到这个元素也就是第二个元素对象的首部, 依次类推. 当插入后, 插入元素的<strong>所在队列的位置</strong>当做第二个触控点事件的<code>pointerID</code>; 当第三个多点触控发生时, 还是会重复上面的插入规则, 这个时候会遍历到已经存在的两个触摸对象其<code>pointerID</code>是从0开始的递增,所以这个触摸事件放到这个队列的尾部, 也就是第三个触控事件的<code>pointerID=3</code>. <code>这也就是同一个时间段,不会存在相同的pointerID的原因</code></p>
<p><code>为什么要这么麻烦的说这个? 因为当多点触控的时候不弄仅通过getX()或者getY()来取得最后一个坐标点,这个方法只是返回这个队列中的第一个元素的坐标点, 而处理多点的时候我们应该知道具体是队列总的哪一个事件触发并获取其值需要getActionIndex()获得触发事件对象的位置,然后通过getX(actionIndex)才能获取真正的发生变化的触摸点, 而且我们自己在本地记录的出现过得Path路径轨迹进行存储整理. 所以我们需要一个唯一标示来区分不同的触控点进行后续的操作</code></p>
<p><img src="http://szysky.com/2016/09/26/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B04-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-Service/multitouch_add.png" alt="img"></p>
<p><strong>而获取这个触控的事件的队列虽然在插入的时候会保证返回的所在队列的位置和其pointerID一致, 但是在连续抬起事件队列删除的元素时候有序队列元素的位置会变化, 就会导致这两个值有所不同, 请看下图</strong></p>
<p><img src="http://szysky.com/2016/09/26/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B04-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-Service/multitouch_action_index.png" alt="img"></p>
<p>上图和实现代码中有一个<code>getActionIndex()</code>获得的<code>ActionIndex</code>的int值.<strong>这个值表示触发事件对象所在系统保存的所有还在运行的事件的队列的位置.</strong> 当我们知道是一个队列的时候规律也就不难推出<code>move事件</code>的时候, 此值不会发生改变. 但是当<code>down和up事件的时候</code>会动态变化. 因为队列前面元素的变化会导致后边的元素.</p>
<p>这里可能我说的有点啰嗦, 如果看不懂解释可以去上面的连接地址down下代码, 观察输出日志即可.</p>
<hr>
<p><code>Android</code>中的<code>MotionEvent</code>类是所有<code>pointer</code>相关的操作的核心类, <code>pointer</code>意味着手指, 手写笔, 电脑鼠标或者一个外部的触摸板.</p>
<h3 id="PointerCoordinates"><a href="#PointerCoordinates" class="headerlink" title="PointerCoordinates"></a>PointerCoordinates</h3><p>这个知识点只做了解, 因为关于触摸压力值并不是真正的支持, 有的是由按下面积和或者获得的值就是恒定的.</p>
<p><code>MotionEvent</code>对象包含<code>pointer</code>的所有信息. 不同类型的的输入设备, 手指, 鼠标等都能生成<code>pointer</code>, 所以<code>MotionEvent</code>不仅包含x,y坐标. Android API支持所有<code>Linux</code>内核定义的输入设备. 因为不同设备的输入参数可能不同, 所以<code>pointer</code>被设计成有多个坐标轴. 最常用的就是坐标轴xy. 但也有描述其他信息的坐标轴, 比如压力, 距离, 方向等.</p>
<p>另外<code>MotionEvent</code>类不仅支持生成<code>pointer</code>坐标的输入设备, 还支持游戏控制相关的坐标轴信息以及诸如节流阀, 方向舵, 倾斜, 滚轮之类的输入来源.</p>
<h3 id="旋转手势"><a href="#旋转手势" class="headerlink" title="旋转手势"></a>旋转手势</h3><p><code>Android API</code>中有两个工具类能帮助开发者检测各种手势, <code>GestureDetector</code>类和<code>ScaleGestureDetector</code>类. 第一个类支持一些简单的触控手势: 比如长按, 双击, 快速滑动. 第二个类能检测类似于地图所用的双指缩放手势, 以及图片的放大手势等.</p>
<p>类似这样的效果:</p>
<p><img src="http://szysky.com/2016/09/26/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B04-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-Service/rotate.gif" alt="img"></p>
<p>代码就不贴了, 有兴趣<a href="http://szysky.com/2016/09/26/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B04-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-Service/" target="_blank" rel="external">类链接地址</a></p>
<h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><p>虽然可以使用SDK提供的部件, 或者使用自定义的视图来构建大部分的Android应用, 但有时需要更底层和更高性能的图形API. 主要用于游戏. <code>OpenGL ES</code>(嵌入式子系统)很适合. Android系统最高支持<code>OpenGL ES 3.0版本</code>主要取决于硬件和android版本. <code>Android 4.3</code>支持最新的3.0标准.</p>
<p>Android已经在标准UI框架中使用<code>OpenGL ES 2.0</code>来启动硬件加速, 但是并没有对开发者开放. 而3.0完全向后兼容2.0的. 所以如果使用3.0可以放心使用.</p>
<p>如果想要了解<code>Android上的OpenGl</code>, 可以在官网,这里跳转<a href="https://developer.android.com/guide/topics/graphics/opengl.html" target="_blank" rel="external">到Google介绍openGL</a></p>
<h2 id="重识Service"><a href="#重识Service" class="headerlink" title="重识Service"></a>重识Service</h2><h3 id="何时并如何使用Service"><a href="#何时并如何使用Service" class="headerlink" title="何时并如何使用Service"></a>何时并如何使用Service</h3><p><code>Android</code>文档关于<code>Service</code>组件的描述如下:</p>
<blockquote>
<p>Service组件表示在不影响用户的情况下执行耗时的操作或者提供给其他应用使用的功能.</p>
</blockquote>
<p>即使使用<code>Service</code>还是需要把耗时的任务放到一个独立的线程中, 那为什么还有服务的出现?</p>
<p>因为<code>Service</code>和<code>Activity</code>有着不同的生命周期, 对比起来<code>Service</code>更适合管理耗时的操作.</p>
<p>那么耗时操作的定义, 其实建议把所有和用户界面无关的操作都放到后台线程去执行. 因为UI线程需要保持高度响应来与用户进行交互. 所以应尽可能排除掉一切可以不影响用户界面响应速度的操作.</p>
<h3 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h3><ol>
<li><strong>用来执行和用户输入无关的操作</strong>. 例如音乐播放器能够在用户从前台退出应用的情况下还能继续播放音乐. 或者例如即时通讯应用, 在用户退出前它要一直保持运行并接收消息.</li>
<li><strong>直接由用户触发</strong> 比如照片共享应用, 用户拍完照后, 应用使用<code>Intent</code>把照片发送给<code>Service</code>(更准确地说是使用指向本地的Uri). 接下来<code>Service</code>启动并解析<code>Intent</code>里的数据, 最后在后台线程中上传该照片. 当操作完成后系统会自动停止<code>Service</code>.</li>
</ol>
<h3 id="Service的创建和销毁"><a href="#Service的创建和销毁" class="headerlink" title="Service的创建和销毁"></a>Service的创建和销毁</h3><p><code>service</code>有两个必定会调用的生命回调周期<code>onCreate()</code>和<code>onDestroy()</code></p>
<ul>
<li><code>onCreate():</code>做一些初始化例如初始化新的<code>Handler</code>对象, 获取系统服务, 注册广播, 以及执行<code>service</code>操作需要的其他初始化工作. <strong>请注意这个生命周期可是运行主线程的,如果要执行耗时操作需要使用AsyncTask,Handler等方法</strong></li>
<li><code>onDestroy():</code>所有的清理工作都应该在<code>onDestroy()</code>方法完成, 特别的, 需要停止所有已经启动的<code>HandlerThread</code>对象, 并且注销之前注册的广播. 同样, 此回调也是运行在主线程中, 所以清理工作同样放在单独线程.</li>
</ul>
<h3 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h3><p><code>Service</code>的启动方式有两种: 通过<code>Content.startService()</code>或者<code>Content.bindService()</code>.</p>
<p>这里先说<code>startService()</code>方法:</p>
<p>当以<strong>启动模式</strong>打开<code>Service</code>时, 参数中的<code>Intent</code>必须匹配<code>Service</code>定义的<code>intent-filter</code>. (也可以显示地使用<code>Service</code>的<code>ComponentName</code>而不再定义<code>intent-filter</code>). 该方法不提供任何对<code>Service()</code>的引用, 但它在执行基于消息的触发操作方面很有用. 该方法适合执行由用户触发并且运行时间不确定的操作, 比如上传照片或者向服务器发送状态更新. 它在为其他应用提供简单的接口方便也很有用.</p>
<p>当时用<strong>启动模式</strong>打开服务的时候, <code>Service#onStartCommand()</code>方法会被调用, 并收到发送给<code>Service</code>的<code>Intent</code>. 该方法返回一个整型常量, 用来告诉系统如何处理<code>Service</code>的重启操作. 这是<code>Service</code>比较复杂的部分, 所以最起码要记住以下三种返回值(真正返回不止3种):</p>
<ul>
<li><code>START_STICKY:</code> 代表当系统由于某些原因关闭<code>Service</code>时(通常是由于内存不足). <code>Service</code>会被重新启动. 然而当系统重新启动<code>Service</code>时, <code>onStartCommand()</code>参数中的<code>Intent</code>会被置为<code>null</code>, 请注意这一点. 使用<code>START_STICKY</code>返回值的一个典型例子就是音乐播放器.</li>
<li><code>START_NOT_STICKY:</code> 表示<code>Service</code>不会再系统关闭之后重新启动. 这在使用<code>Service</code>执行一次性操作的时候特别有用, 比如上传的东西到服务器. 如果Service在完成任务前就被系统关闭了, 它不应该再尝试重复之前的操作.</li>
<li><code>START_REDELIVER_INTENT:</code> 它和<code>START_STICKY</code>基本一样, 不过当系统重启<code>Service</code>时, <code>onStartCommand()</code>会收到<code>Service</code>被销毁之前接收到的最后一个<code>intent</code>.</li>
</ul>
<hr>
<p><strong>接着说onStartCommand()这个回调方法的一共有三个返回值:</strong></p>
<ul>
<li><code>intent:</code> 根据前面讲解返回值的时候可以看出在某些特定情况下, 该参数可能会为null.</li>
<li><code>标志位:</code> 标识本次启动请求, 可能的值为0, <code>START_FLAG_RETRY</code>, <code>START_FLAG_REDELIVERY</code>.</li>
<li><code>startId:</code> 如果多次调用<code>onStartCommand()</code>且需要安全地停止<code>Service</code>, 此参数会有用.</li>
</ul>
<h3 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h3><p><strong>绑定模式</strong>这是使用<code>Content.bindService()</code>. 被绑定的<code>Service</code>会一直运行, 知道所有绑定的客户端都断开后才会停止. 在同一个应用进程中绑定<code>Service</code>只需获取<code>Service</code>对象的的引用, 并调用对象相应的方法即可. 这种方式成为<code>本地binder</code>.</p>
<p>如下代码: 只贴出核心代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  实现一个bindService模式的, 简单演示方法被调用的服务类</div><div class="line"> */</div><div class="line">public class LocalService extends Service &#123;</div><div class="line"></div><div class="line">    public void doBackgroundOperation()&#123;</div><div class="line">        Toast.makeText(getApplicationContext(), &quot;定义服务方法被调用&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        return new LocalBinder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class LocalBinder extends Binder&#123;</div><div class="line">        public LocalService getService()&#123;</div><div class="line">            return LocalService.this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在Activity中进行强转即可</div><div class="line">serviceConnection = new ServiceConnection() &#123;</div><div class="line">  @Override</div><div class="line">  public void onServiceConnected(ComponentName name, IBinder service) &#123;</div><div class="line">      mService = ((LocalService.LocalBinder)service).getService();</div><div class="line">      //  通过mService就可以调用服务的内部方法, 注意这只是在应用内部, 不可以跨进程</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onServiceDisconnected(ComponentName name) &#123;</div><div class="line">      mService = null;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="保持活跃"><a href="#保持活跃" class="headerlink" title="保持活跃"></a>保持活跃</h3><p>当服务已经启动, 并且应用程序在前台运行(当前正在展示应用的某个Activity), 那么该<code>Service</code>会是最后一个被杀死. 然而一旦用户离开了发起服务的应用, 那么此服务也就不再是前台应用, 有可能会被杀死. 所以如果需要在应用不处于前台活动状态下仍然保持<code>Service</code>在前台运行, 则可以调用<code>Service.startForeground()</code>. (当应用程序更新可以使用<code>Notification</code>通知配合服务来完成)</p>
<blockquote>
<p>系统会试图尽可能长地保持<code>Service</code>处于活动和运行状态. 只有当资源耗尽, 通常是没有足够内存(RAM), 才有可能会去停止<code>Service</code>. 当是我们应该在开发中假设这种情况会随时发生.</p>
</blockquote>
<h3 id="停止服务Service"><a href="#停止服务Service" class="headerlink" title="停止服务Service"></a>停止服务Service</h3><p>一旦<code>Service</code>启动, 它会尽可能长时间运行. 根据启动方式的不同, 系统会在系统资源不足杀死<code>Service</code>后重启.</p>
<blockquote>
<p>当Service再次启动时, 可能会出现一些意想不到的结果, 所以适当的停止服务就显得很重要.</p>
</blockquote>
<ul>
<li><code>绑定模式:</code> 此模式下服务会一直运行到没有客户端连接为止. 但有一种例外情况, 即最后连接的客户端调用了<code>Service.startForeground()</code>时还会保持<code>Service</code>的运行, 所以需要在适当的时候调用<code>Service.stopForeground()</code></li>
<li><code>启动模式:</code> 只能通过<code>Service.stopSelf()</code>或者<code>Content.stopService()</code>来停止<code>Service</code>. 这标志着需要停止和移除<code>service</code>. 而重新启动<code>Service</code>的唯一方式是显示调用<code>Content.startService()</code>或者<code>Content.bindService()</code>. 注意, 当通过<code>startService()</code>启动服务时, 不管调用多少次<code>onStartCommand()</code>(即调用<code>Content.startService()</code>不会叠加), 调用<code>Service.stopSelf()</code>或者<code>Content.stopSelf()</code>一定会停止服务.</li>
</ul>
<h3 id="后台运行的IntentService"><a href="#后台运行的IntentService" class="headerlink" title="后台运行的IntentService"></a>后台运行的IntentService</h3><p>普通的服务的生命周期回调都是触发在<strong>主线程上</strong>. 如果需要处理耗时操作那么需要把耗时操作移动到一个单独的线程中.</p>
<p><strong>IntentService</strong></p>
<p>由于<code>Handler</code>在android中的处理消息的便利, 和<code>Service</code>分离与UI线程无关的代码. 所以google提供了一个名为<code>IntentService</code>的工具类, 它在<code>Service</code>中包装了一个处理后台线程的<code>Handler</code>. 开发者只需要继承该类, 实现<code>onHandlerIntent()</code>方法, 并添加希望<code>Service</code>能够接收的action.</p>
<p><code>onHandlerIntent()</code>方法运行在自己线程, 并不一定是主线程. 并且每次只能处理一个<code>Intent</code>,当处理结束之后服务也就自动关闭. 可以通过不同的<code>action</code>组装成intent, 也可以给<code>intent</code>附加信息, 用以在服务中区分不同的动作请求. 当多次通过<code>startService()</code>调用服务的时候, 每次调用的<code>Intent</code>会被保存到队列中, 所以该类能确保任意时间只会有一个<code>intent</code>会被处理. 知道队列为空, 那么服务也就随之消失.</p>
<hr>
<p><strong>并行问题</strong></p>
<p><code>IntentService</code>虽然方便好用, 并且能够顺序处理同一时间内的多个请求. 但是正因为是<strong>串行的处理模式</strong>, 可能我们有的时候更需要并行更快的处理完成.如果是这样, 那我们就使用线程池来处理. 可以在<code>AsyncTask</code>中使用<code>Executor</code>并行地执行操作. 但是<code>AsyncTask</code>的特点是比较适合执行运行时间至多几面的操作, 如果要执行比较耗时的操作. 可以使用<code>ExecutorService</code>使用<code>Executors.newCacheThreadPool()</code>.</p>
<h3 id="对Service的通信"><a href="#对Service的通信" class="headerlink" title="对Service的通信"></a>对Service的通信</h3><p>前面记录了何时使用, 如何执行. 那么接下来接说一下对服务的通信. 一般有两种:</p>
<ul>
<li><code>Content.StartService()</code>会把<code>Intent</code>分发给<code>Service.onStartCommand()</code>方法,可以在该方法中触发后台操作, 然后通过广播或者其他方式再把结果分发给调用组件.</li>
<li><code>Content.bindService()</code>方法可以获得<code>Binder</code>对象, 使用它可以直接调用<code>Service</code>对象.</li>
</ul>
<hr>
<p><strong>使用Intent进行异步消息的传递</strong></p>
<p>如果想要知道服务中处理的结果, 只需要采用发送广播的进行通知调用者即可.</p>
<p>总结一下这种的优缺点:</p>
<ul>
<li><strong>优点:</strong> Android提供了线程的机制, 而不需要开发者自己构建复杂的组件间消息处理系统. 开发者只需要声明表示异步消息的<code>action</code>. 并在响应的组件中注册这些广播. 即便<code>Service</code>属于其他应用或者运行在一个单独的进程中, 该方法同样有效.</li>
<li><strong>缺点:</strong> 通知的结果受限于<code>Intent</code>. 此外这种方式不适合在<code>IntentService</code>和<code>Activity</code>之间进行大规模快速更新的操作, 比如更新进度条, 因为这会阻塞系统. 如果确定需要实现此功能那么可以使用<code>bindService</code>.</li>
</ul>
<hr>
<p><strong>本地绑定的Service进行的交互</strong></p>
<p>当<code>Service</code>提供的接口太过复杂, 很难用<code>Intent</code>消息机制解决, 而普通的<code>Java</code>方法又可以很好的解决这个问题; 另一个使用绑定本地<code>Service</code>的原因是可以在<code>Service</code>中给Activity提供更为复杂的回调. 因为那些耗时的操作必须放到<code>Service</code>的后台线程, 所以<code>Service</code>的大部分回调应该是异步的. 实际的调用触发后台操作立即返回, 一旦操作完成, <code>Service</code>使用回调接口来通知<code>Activity</code>响应的执行结果.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/11/android/books/《Android 编程实战》Chap4_手势操作进阶, 重识Service/" data-id="cj7g7uqlr000616pjj48lo4s5" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/11/android/books/《Android 编程实战》Chap4_手势操作进阶, 重识Service/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/24/react/第5篇React-Native布局实战2/" class="title">第5篇React-Native布局实战2</a></p>
                            <p class="item-date"><time datetime="2017-09-24T14:12:33.000Z" itemprop="datePublished">2017-09-24</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/24/react/第4篇React-Native布局实战/" class="title">第4篇React-Native布局实战</a></p>
                            <p class="item-date"><time datetime="2017-09-24T14:11:36.000Z" itemprop="datePublished">2017-09-24</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/22/react/第3篇CSS和UI布局/" class="title">第3篇CSS和UI布局</a></p>
                            <p class="item-date"><time datetime="2017-09-22T08:00:37.000Z" itemprop="datePublished">2017-09-22</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/22/react/第2篇代码结构/" class="title">第2篇代码结构</a></p>
                            <p class="item-date"><time datetime="2017-09-22T07:16:42.000Z" itemprop="datePublished">2017-09-22</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/22/react/第1篇环境配置 & Hello World/" class="title">第1篇环境配置 &amp; Hello World</a></p>
                            <p class="item-date"><time datetime="2017-09-22T07:15:10.000Z" itemprop="datePublished">2017-09-22</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">44</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/android/code/">code</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/github/">github</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android开发艺术探索》/">《Android开发艺术探索》</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android编程权威指南》/">《Android编程权威指南》</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/设计模式/">设计模式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/面试/">面试</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/learn/">learn</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/learn/《如何高效学习》/">《如何高效学习》</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/node/7days/">7days</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a><span class="category-list-count">5</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">59</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/analysis/">analysis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">37</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anslysis/">anslysis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/autoLink/">autoLink</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/">code</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitlab/">gitlab</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/indicator/">indicator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learn/">learn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/share/">share</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/textview/">textview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/analysis/" style="font-size: 10px;">analysis</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/anslysis/" style="font-size: 10px;">anslysis</a> <a href="/tags/autoLink/" style="font-size: 10px;">autoLink</a> <a href="/tags/code/" style="font-size: 15px;">code</a> <a href="/tags/git/" style="font-size: 11.67px;">git</a> <a href="/tags/github/" style="font-size: 18.33px;">github</a> <a href="/tags/gitlab/" style="font-size: 10px;">gitlab</a> <a href="/tags/glide/" style="font-size: 15px;">glide</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/indicator/" style="font-size: 10px;">indicator</a> <a href="/tags/java/" style="font-size: 13.33px;">java</a> <a href="/tags/learn/" style="font-size: 10px;">learn</a> <a href="/tags/markdown/" style="font-size: 11.67px;">markdown</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/node/" style="font-size: 16.67px;">node</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/share/" style="font-size: 10px;">share</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/textview/" style="font-size: 10px;">textview</a> <a href="/tags/vim/" style="font-size: 11.67px;">vim</a> <a href="/tags/设计模式/" style="font-size: 11.67px;">设计模式</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2017 Ernest Chang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2142274"></script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>