<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>The Old Man and the Sea</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="All any predator can do is to keep on trying.">
<meta property="og:type" content="website">
<meta property="og:title" content="The Old Man and the Sea">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="The Old Man and the Sea">
<meta property="og:description" content="All any predator can do is to keep on trying.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Old Man and the Sea">
<meta name="twitter:description" content="All any predator can do is to keep on trying.">
    

    
        <link rel="alternate" href="/" title="The Old Man and the Sea" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">The Old Man and the Sea</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="https://ernestchang.github.io/2017/08/23/other/about/">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/uploads/images/avert.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="https://ernestchang.github.io/2017/08/23/other/about/">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/uploads/images/avert.png" />
            <h2 id="name">Ernest Chang</h2>
            <h3 id="title">Developer &amp; Designer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Hangzhou, China</span>
            <a id="follow" target="_blank" href="https://github.com/Ernestchang/">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                84
                <span>posts</span>
            </div>
            <div class="article-info-block">
                23
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Ernestchang/" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="twitter" class=tooltip>
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-android/code/Android Studio 常用手册" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/code/Android Studio 常用手册/">Android Studio常用手册</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/code/Android Studio 常用手册/">
            <time datetime="2017-09-12T01:25:38.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/code/">code</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>, <a class="tag-link" href="/tags/code/">code</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>整理<code>Android群英传</code>和网上出现的比较完整<code>AS</code>的快捷小技巧. <code>mac</code>版已测, <code>win</code>大部分测试. 最后有一个整理的完整<code>快捷键表格</code>. win也好mac也好, 如果快捷被修改还是错误, 都可以通过提供的<code>Keymap中的关键字</code>来进行重设.<br>图中<code>gif</code>如果看不清, 放大页面即可.</p>
</blockquote>
<p>转载标明出处:</p>
<ul>
<li><a href="https://github.com/suzeyu1992/repo.git" target="_blank" rel="external">作者GitHub</a></li>
<li><a href="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/" target="_blank" rel="external">博客地址</a></li>
</ul>
<h2 id="常用小操作"><a href="#常用小操作" class="headerlink" title="常用小操作"></a>常用小操作</h2><h3 id="单词选择"><a href="#单词选择" class="headerlink" title="单词选择"></a>单词选择</h3><p>一般<code>IDE</code>通过<code>option + 方向键左右</code>(win为<code>ctrl + 左右方向键</code>)对光标进行单词的跳动, 但是由于我们使用驼峰式命名较多, 默认的会导致由多个单词组成的驼峰式的首尾跳转. 还好<code>AS</code>可以对这种风格进行设定.</p>
<p><strong>默认效果</strong></p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/smart_old.gif" alt="img"></p>
<p><strong>修改后的效果</strong></p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/smart_new.gif" alt="img"></p>
<p><strong>修改步骤</strong></p>
<p>打开<strong>偏好设置</strong>如图片设置</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/smart.png" alt="img"></p>
<blockquote>
<p>虽然单词跳着爽了, 但是当你想复制这个变量名双击的时候. 只会复制变量名中的某一个单词. 而不是像以前会复制空格分割两边的完整字符串. 反正我是用了不到一天有些不舒服就切换回原来的风格了.<br>但是<code>option + 左右方向键</code>这个小技巧用熟了, 比特意用鼠标点,或者光标一下下移动到目标位置会高效很多.</p>
</blockquote>
<h3 id="显示最近操作-修改的文件"><a href="#显示最近操作-修改的文件" class="headerlink" title="显示最近操作, 修改的文件"></a>显示最近操作, 修改的文件</h3><p>例如: 我打开了<code>main_activity.xml</code>布局文件, 然后关闭页面. 这个时候<code>Command + E</code>, 就会如下显示之前的操作文件.</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/recent_file.png" alt="img"></p>
<p>那么如果要查看之前修改过的文件, <code>Command + Shift + E</code>即可. 可以配合<code>Control + Tab</code>进行快速界面的切换.</p>
<p><strong>快捷键</strong></p>
<ul>
<li>最近操作<ul>
<li><code>Command + E</code> <strong>(mac)</strong></li>
<li><code>ctrl + E</code> <strong>(win)</strong></li>
</ul>
</li>
<li>最近修改<ul>
<li><code>Command + Shift + E</code> <strong>(mac)</strong></li>
<li><code>ctrl + shift + E</code> <strong>(win)</strong></li>
</ul>
</li>
</ul>
<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p><code>search Everywhere</code></p>
<p>项目中的全局查找功能文件功能</p>
<p><strong>查找类文件</strong></p>
<ul>
<li><code>command + o</code> <strong>(mac)</strong></li>
<li><code>ctrl + n</code> <strong>(win)</strong></li>
</ul>
<p>默认只是在项目代码中查找类文件, 如果需要查找<code>sdk</code>或者类库中的相关类. 再按一次快捷键, 或者勾选下图选项搜索全局类文件</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/find_class.png" alt="img"></p>
<hr>
<p><strong>查找文件</strong></p>
<p>这个级别比上面那个更广. 包括所有文件, 如<code>xml</code>等.</p>
<ul>
<li><code>command + shift + o</code> <strong>(mac)</strong></li>
<li><code>ctrl + shift + n</code> <strong>(win)</strong></li>
</ul>
<p>如上如果需要搜索类库或者源码, 请在按一次快捷键, 或者勾选<code>查找类</code>给出图中的选项.</p>
<h3 id="操作记录"><a href="#操作记录" class="headerlink" title="操作记录"></a>操作记录</h3><p>在浏览代码结构的时候, 很多时候总是会跟进许多类里面, 如果想回到之前浏览调转点. 那么这个快捷键你就必须要记住.</p>
<ul>
<li><code>Command + Option + Left\Right</code> 或者 <code>command + [</code>, <code>command + ]</code> <strong>(mac)</strong></li>
<li><code>ctrl + alt + Left\Right</code><strong>(win)</strong></li>
</ul>
<h3 id="移动行"><a href="#移动行" class="headerlink" title="移动行"></a>移动行</h3><p>这个不用太多介绍, 就是<strong>整行</strong>的上下移动.</p>
<ul>
<li><code>Option + shift + 方向键上\方向键下</code> <strong>(mac)</strong></li>
<li><code>alt + shift + 方向键上\方向键下</code> <strong>(win)</strong></li>
</ul>
<h3 id="查找方法调用处"><a href="#查找方法调用处" class="headerlink" title="查找方法调用处"></a>查找方法调用处</h3><p>场景: 查找一个方法在何处被调用, 或者一个ID在哪里被引用. 选中这个方法<strong>右键</strong>, 选择<code>Find Usages</code>即可.</p>
<p>快捷键:</p>
<ul>
<li><code>option + F7</code> <strong>(mac)</strong></li>
<li><code>alt + F7</code> <strong>(win)</strong></li>
</ul>
<h3 id="方法的跟进"><a href="#方法的跟进" class="headerlink" title="方法的跟进"></a>方法的跟进</h3><p>方法总是伴随着调转, 我们也总是会对方法的内部查看细节. 常用的办法是<code>按住Command 并点击方法名</code>的方式.</p>
<p>也可以在光标所在处直接通过<code>Command + B</code>进行方法内部跟进.</p>
<ul>
<li><code>Command + B</code> <strong>(mac)</strong></li>
<li><code>ctrl + alt + B</code> <strong>(win)</strong></li>
</ul>
<h3 id="显示方法的参数"><a href="#显示方法的参数" class="headerlink" title="显示方法的参数"></a>显示方法的参数</h3><p>当我们使用一个方法的时候, 会在刚开始的时候显示出所有的参数. 但是过一会可能就不存在了. 这个时候如果你想知道下一个参数是什么类型, 或者看一下所有参数.</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/params.gif" alt="img"></p>
<p>快捷键:</p>
<ul>
<li><code>command + P</code> <strong>(mac)</strong></li>
<li><code>ctrl + P</code> <strong>(win)</strong></li>
</ul>
<p>如果你还想查看一下方法的文档, 不用跟进源码, 直接<code>F1</code>键即可显示出文档.</p>
<h3 id="行的快速操作"><a href="#行的快速操作" class="headerlink" title="行的快速操作"></a>行的快速操作</h3><p>快速删除行, 其实使用剪切功能就可以<code>Command + X</code></p>
<p><strong>快速复制行</strong>, 使用<code>command + D</code><strong>mac</strong>, <code>ctrl + D</code><strong>win</strong></p>
<h3 id="多行操作"><a href="#多行操作" class="headerlink" title="多行操作"></a>多行操作</h3><p>可能有时候我们会声明做一系列相关的变量为<code>float</code>类型, 但是真实的需要的是<code>int</code>类型. 这个时候就可以进行<code>多重选择</code>进行整体修改. 如下图:</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/mul_condition.gif" alt="img"></p>
<p>按住<code>option</code>(win为<code>alt</code>)键, 然后鼠标进行区域的选择. 然后进行对应修改即可.</p>
<p>你可能认为上面的必须要连续的才可以. 那么如果可以设置<code>多个光标点</code>是否就可以满足你的问题了?</p>
<p>看下图:</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/mul_no_condition.gif" alt="img"></p>
<ul>
<li><code>option + shift + 鼠标点击</code> <strong>(mac)</strong></li>
<li><code>alt + shift + 鼠标点击</code><strong>(win)</strong></li>
</ul>
<p>即可添加一个<code>编辑光标</code>. 最后如果不需要那么就<code>esc</code>即可关闭多余光标.</p>
<h3 id="快速补全完成"><a href="#快速补全完成" class="headerlink" title="快速补全完成"></a>快速补全完成</h3><p>创建一个对象. 或者<code>findViewById()</code>有时总需要移动鼠标或者光标到末尾进行<code>分号</code>的补全. 这些都可以快捷键搞定. 当你用习惯之后, 会非常的方便好用.</p>
<ul>
<li><code>command + shift + enter</code><strong>(mac)</strong></li>
<li><code>ctrl + shift + enter</code><strong>(win)</strong></li>
</ul>
<p>实现的功能</p>
<ul>
<li>方法体大括号的添加</li>
<li>行尾分号的添加</li>
<li>自动格式化改行操作等</li>
</ul>
<h3 id="代码提示"><a href="#代码提示" class="headerlink" title="代码提示"></a>代码提示</h3><p>任何地方都可以调出的代码提示.</p>
<p><code>control + option + /</code>(不是默认, mac默认为<code>control + space</code>). 这里要说的是. 代码提示之后一般都会<code>回车键</code>确定. 当按<code>回车键</code>的时候. 会保留光标之后的内容. 当有的时候我们并不需要. 这个时候你就可以使用<code>table</code>键进行选择. 它会将后面的输入内容删掉.</p>
<p>win的快捷方式<code>ctrl + 空格</code>(win同样大部分和输入法冲突, 请手动在AS设置里面<code>keymap</code>项查找<code>completion basic</code>手动修改快捷键)</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/tip.gif" alt="img"></p>
<p><strong>快速生成变量</strong></p>
<p>比如在方法体中<code>logi</code>直接快速生成一个<code>log</code>日志输出的模板, 但是<code>TAG</code>这个常量还没有声明. 这个时候用光标移动到<code>TAG</code>上. 使用快捷键提示即可快速生成.</p>
<ul>
<li><code>option + enter</code><strong>(mac)</strong></li>
<li><code>alt + enter</code><strong>(win)</strong></li>
</ul>
<h3 id="变量的快速操作"><a href="#变量的快速操作" class="headerlink" title="变量的快速操作"></a>变量的快速操作</h3><p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/filed.gif" alt="img"></p>
<p>上图使用了两次快捷键,</p>
<ul>
<li><p>第一次: 跳转到变量的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">声明处</div></pre></td></tr></table></figure>
<ul>
<li><code>command + B</code> <strong>(mac)</strong></li>
<li><code>ctrl + b</code> <strong>(win)</strong></li>
</ul>
</li>
<li><p>第二次: 跳转到变量类型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">定义处</div></pre></td></tr></table></figure>
<ul>
<li><code>command + shift + B</code> <strong>(mac)</strong></li>
<li><code>ctrl + shift + b</code> <strong>(win)</strong></li>
</ul>
</li>
</ul>
<h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><p>对代码块进行折叠和展开.</p>
<ul>
<li><code>command + 加号\减号</code><strong>(mac)</strong></li>
<li><code>ctrl + 加号\减号</code> <strong>(win)</strong></li>
</ul>
<h3 id="预览方法定义"><a href="#预览方法定义" class="headerlink" title="预览方法定义"></a>预览方法定义</h3><p>如果只想大体了解方法的定义, 而不需要进行方法所在源码类的跳转显示. 可以通过<code>Command + Y</code>(win快捷键为<code>ctrl + shift + I</code>)来进行预览</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/method_pre.png" alt="img"></p>
<h3 id="粘贴板管理"><a href="#粘贴板管理" class="headerlink" title="粘贴板管理"></a>粘贴板管理</h3><p>对于复制粘贴. 我们习惯只是<code>单次</code>的<code>c+v</code>, 那么如果你想查看之前被覆盖了的<code>复制过的</code>内容. <code>AS</code>同样有<code>复制粘贴板</code>来管理. 展示最近几次的复制内容.</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/command_copy.png" alt="img"></p>
<ul>
<li><code>command + shift + v</code> <strong>(mac)</strong></li>
<li><code>ctrl + shift + v</code> <strong>(win)</strong></li>
</ul>
<h3 id="拆分窗口"><a href="#拆分窗口" class="headerlink" title="拆分窗口"></a>拆分窗口</h3><p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/split.png" alt="img"></p>
<p>只需要在标签页上<code>右键</code>. 选择<code>split vertical\horizontal</code>.</p>
<h3 id="变量命名风格"><a href="#变量命名风格" class="headerlink" title="变量命名风格"></a>变量命名风格</h3><p>对于<code>成员变量</code>应该<code>m</code>开头. 对于<code>静态成员</code>通常是<code>s</code>开头. 可以这样设置这个风格.</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/set_name.png" alt="img"></p>
<p>这样在输入一个变量的名字时, 就可以自动补全<code>m</code>或者<code>s</code>. 同时在<code>Extra</code>代码的时候, 生成的代码都可以自动根据这个规则重构.</p>
<h3 id="查看大纲"><a href="#查看大纲" class="headerlink" title="查看大纲"></a>查看大纲</h3><p>当一个类很大的时候. 可以通过<code>command + F12</code>(win为<code>ctrl + F12</code>) 打开大纲界面. 展示全部的方法和成员变量列表.</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/all_body.png" alt="img"></p>
<p>并且支持模糊搜索. 来进行筛选显示. 可以快速的找到要搜索的方法集.</p>
<h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>在浏览大型代码, 或者调试时. 有时可能会需要记住一些关键的代码或者方法. 这个时候就可以使用<code>书签</code>. 来记录此关键代码. 只需要在点击需要标记的行, 并按<code>F3</code>就会在左侧出现一个<code>小对勾</code>. 这就说明已经打上了一个书签.</p>
<p>同时在<code>Favorites</code>标签中, 也可以找到对应的<code>Bookmarks</code></p>
<p>可以通过快捷键<code>command + F3</code> (win为<code>shift + F11</code>)快速调出书签面板, 进行后续的操作.</p>
<h2 id="快速重构"><a href="#快速重构" class="headerlink" title="快速重构"></a>快速重构</h2><h3 id="重构入口"><a href="#重构入口" class="headerlink" title="重构入口"></a>重构入口</h3><p>当一个代码片段准备重构的时候. 可以使用<code>control + T</code> (win为<code>ctrl + alt + shift + T</code>)打开重构入口. 或者<code>右键单击</code>选择<code>Refactor</code>显示重构界面.</p>
<p>这里有很多方便的功能. 提成方法等等.</p>
<h3 id="surround-With"><a href="#surround-With" class="headerlink" title="surround With"></a>surround With</h3><p>当对一个段代码进行, 条件包裹, 捕捉异常, 循环, Runnable等. 可以直接使用快捷的方式, 而不需要手动生成条件在进行代码块的<code>复制-粘贴</code></p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/runnable.gif" alt="img"></p>
<p>快捷键</p>
<ul>
<li><code>command + option + T</code><strong>(mac)</strong></li>
<li><code>ctrl + alt + T</code><strong>(win)</strong></li>
</ul>
<h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><p>你可以经常使用它,提取出一个方法.</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/extract_method.gif" alt="img"></p>
<p>不仅仅如此, 你还可以对<code>xml</code>中的多个控件相同的属性进行抽取为<code>style</code></p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/extract_xml.gif" alt="img"></p>
<p>是不是很爽?</p>
<p>这是其一, 对于<code>xml</code>不仅可以抽取<code>Style</code>, 还可以抽取布局<code>Layout</code></p>
<p>而代码中, 可以提取各种变量, 参数, 长廊.</p>
<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p><code>AS</code>中已经内置了很多代码模板, 你可以很嗖嗖嗖的就完成之前倒背如流的代码. 如下一小部分</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/template.gif" alt="img"></p>
<p>通过快捷键可调出这些代码模板</p>
<ul>
<li><code>command + J</code><strong>(mac)</strong></li>
<li><code>ctrl + J</code><strong>(win)</strong></li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>Google</code>提供了很多代码分析工具, 这些工具都集中在顶部菜单栏的<code>Analyze</code>中.</p>
<h3 id="Inspect-Code-amp-Code-cleanup"><a href="#Inspect-Code-amp-Code-cleanup" class="headerlink" title="Inspect Code &amp; Code cleanup"></a>Inspect Code &amp; Code cleanup</h3><p><code>Inspect Code</code>可以让<code>IDE</code>分析整个工程. 类似于<code>Lint</code>分析, 并会给出大致修改意见等</p>
<p><code>Code cleanup</code>功能可以进行自动的代码修复.</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>通过<code>Analyze</code>中的几个<code>Dependencies</code>选项. 可以快速分析项目的依赖.</p>
<h3 id="方法调用栈"><a href="#方法调用栈" class="headerlink" title="方法调用栈"></a>方法调用栈</h3><p>对于某些方法来说, 查看它被调用的地方和调用的顺序是非常重要的. 可通过<code>control + option + H</code>快速查找方法调用栈.</p>
<h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><h3 id="快速断点"><a href="#快速断点" class="headerlink" title="快速断点"></a>快速断点</h3><p><code>条件断点</code>. 主要用在循环体内. 一个循环10次的<code>for</code>. 只想在第<code>8</code>次进入断点.</p>
<p>和<code>普通断点</code>相似, 一样先声明一个断点. 然后在<code>普通断点</code>上<code>单击鼠标右键</code>. 在弹出的菜单填写断点条件即可. 如下:</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/condition.gif" alt="img"></p>
<p>上面图中<code>Enable</code>可以控制<code>启用</code>, 还是<code>停用</code>一个断点.</p>
<hr>
<p><code>临时断点</code>. 如果需要一个只执行一次的断点. 执行完之后断点自动取消. 那么可以通过快捷点将当前行作为临时断点.</p>
<p><img src="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/one_debug.png" alt="img"></p>
<ul>
<li><code>command + option + shift + F8</code></li>
<li><code>ctrl + alt + shift + F8</code></li>
</ul>
<p>为了篇幅不是很长, 调试的部分贴一个讲解很详细的帖子</p>
<ul>
<li><a href="http://blog.csdn.net/dd864140130/article/details/51560664" target="_blank" rel="external">Android Studio代码调试大全</a></li>
</ul>
<h2 id="快捷键查找表"><a href="#快捷键查找表" class="headerlink" title="快捷键查找表"></a>快捷键查找表</h2><table>
<thead>
<tr>
<th>功能描述</th>
<th>keymap对应名字</th>
<th>Mac</th>
<th>Win/Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>提示错误解决方案</strong></td>
<td><strong>Show Intention Actions</strong></td>
<td><code>option + enter</code></td>
<td><code>alt + enter</code></td>
</tr>
<tr>
<td><strong>AS配置界面</strong></td>
<td><strong>Preferences</strong></td>
<td><code>command + ,</code></td>
<td><code>control+alt+S</code></td>
</tr>
<tr>
<td><strong>工程项目配置界面</strong></td>
<td><strong>Project Structure</strong></td>
<td><code>command + ;</code></td>
<td><code>Control＋Alt+Shift+S</code></td>
</tr>
<tr>
<td><strong>快速构成代码</strong></td>
<td><strong>Code Generate</strong></td>
<td><code>command + N</code></td>
<td><code>alt + insert</code></td>
</tr>
<tr>
<td><strong>代码提示</strong></td>
<td><strong>Completion/Basic</strong></td>
<td><code>control + space</code>(mac会冲突, 手动修改)</td>
<td><code>ctrl + 空格</code>(win同样大部分和输入法冲突, 手动修改)</td>
</tr>
<tr>
<td><strong>选择视图</strong></td>
<td><strong>select in any view</strong></td>
<td><code>option + F1</code></td>
<td><code>alt + F1</code></td>
</tr>
<tr>
<td><strong>添加书签标识</strong></td>
<td><strong>Toggle Bookmark</strong></td>
<td><code>option + F3</code></td>
<td><code>ctrl + F11</code></td>
</tr>
<tr>
<td><strong>向下移动一行</strong></td>
<td><strong>Move Line Down</strong></td>
<td><code>option + shift + Down</code></td>
<td><code>alt + shift + Down</code></td>
</tr>
<tr>
<td><strong>向上移动一行</strong></td>
<td><strong>Move Line Up</strong></td>
<td><code>option + shift + Up</code></td>
<td><code>alt + shift + Up</code></td>
</tr>
<tr>
<td><strong>注释代码</strong></td>
<td><strong>Comment with Line Comment</strong></td>
<td><code>command + /</code></td>
<td><code>ctrl + /</code></td>
</tr>
<tr>
<td><strong>用代码模板包裹代码</strong></td>
<td><strong>surround with Live Template</strong></td>
<td><code>command + option + J</code></td>
<td><code>ctrl + alt + J</code></td>
</tr>
<tr>
<td><strong>格式化代码</strong></td>
<td><strong>Reformat Code</strong></td>
<td><code>command + option + L</code></td>
<td><code>ctrl + alt + L</code></td>
</tr>
<tr>
<td><strong>Copy Reference</strong></td>
<td><strong>Copy Reference</strong></td>
<td><code>command + option + shift + C</code></td>
<td><code>ctrl + alt + shift + C</code></td>
</tr>
<tr>
<td><strong>if/try等包裹代码</strong></td>
<td><strong>Surround With..</strong></td>
<td><code>command + option + T</code></td>
<td><code>ctrl + alt + T</code></td>
</tr>
<tr>
<td><strong>查看声明</strong></td>
<td><strong>Declaration</strong></td>
<td><code>command + B</code></td>
<td><code>ctrl + B</code></td>
</tr>
<tr>
<td><strong>快捷向下复制行</strong></td>
<td><strong>Duplicate Line or Block</strong></td>
<td><code>command + D</code></td>
<td><code>ctrl + D</code></td>
</tr>
<tr>
<td><strong>删除行</strong></td>
<td><strong>Delete Line</strong></td>
<td><code>command + delete</code></td>
<td><code>ctrl + Y</code></td>
</tr>
<tr>
<td><strong>快捷最近打开</strong></td>
<td><strong>Recent Files</strong></td>
<td><code>command + E</code></td>
<td><code>ctrl + E</code></td>
</tr>
<tr>
<td><strong>查找</strong></td>
<td><strong>Edit/Find/Find</strong></td>
<td><code>command + F</code></td>
<td><code>ctrl + F</code></td>
</tr>
<tr>
<td><strong>文件方法结构</strong></td>
<td><strong>File Structure</strong></td>
<td><code>command + F12</code></td>
<td><code>ctrl + F12</code></td>
</tr>
<tr>
<td><strong>显示书签</strong></td>
<td><strong>Show Bookmarks</strong></td>
<td><code>command + F3</code></td>
<td><code>shift + F11</code></td>
</tr>
<tr>
<td><strong>代码高亮向下查找</strong></td>
<td><strong>Move To Next Occurrence</strong></td>
<td><code>command + G</code></td>
<td><code>F3</code></td>
</tr>
<tr>
<td><strong>代码高亮向上查找</strong></td>
<td><strong>Move To Previous Occurrence</strong></td>
<td><code>command + shift + G</code></td>
<td><code>shift + F3</code></td>
</tr>
<tr>
<td><strong>按照模板生成代码</strong></td>
<td><strong>Insert Live Template</strong></td>
<td><code>command + J</code></td>
<td><code>ctrl + J</code></td>
</tr>
<tr>
<td><strong>定位到行</strong></td>
<td><strong>Navigate/Line</strong></td>
<td><code>command + L</code></td>
<td><code>ctrl + G</code></td>
</tr>
<tr>
<td><strong>快速到行首/尾</strong></td>
<td><strong>Move Caret to Line Start/End</strong></td>
<td><code>command + Left/Right</code></td>
<td><code>ctrl + Left/Right</code></td>
</tr>
<tr>
<td><strong>代码折叠/展开</strong></td>
<td><strong>Collapse/Expand</strong></td>
<td><code>command + 减号/加号</code></td>
<td><code>ctrl + 减号/加号</code></td>
</tr>
<tr>
<td><strong>查找类</strong></td>
<td><strong>Navigate/Class</strong></td>
<td><code>command + O</code></td>
<td><code>ctrl + N</code></td>
</tr>
<tr>
<td><strong>多行注释</strong></td>
<td><strong>Code/Comment</strong></td>
<td><code>command + option + /</code></td>
<td><code>ctrl + alt + /</code></td>
</tr>
<tr>
<td><strong>格式化代码</strong></td>
<td><strong>Reformat Code</strong></td>
<td><code>command + option + L</code></td>
<td><code>ctrl + alt + L</code></td>
</tr>
<tr>
<td><strong>提示参数类型</strong></td>
<td><strong>Parameter Info</strong></td>
<td><code>command + P</code></td>
<td><code>ctrl + P</code></td>
</tr>
<tr>
<td><strong>查找替换</strong></td>
<td><strong>Replace</strong></td>
<td><code>command + R</code></td>
<td><code>ctrl + R</code></td>
</tr>
<tr>
<td><strong>查找命令</strong></td>
<td><strong>Find Action</strong></td>
<td><code>command + shift + A</code></td>
<td><code>ctrl + shift + A</code></td>
</tr>
<tr>
<td><strong>拷贝文件路径</strong></td>
<td><strong>Copy Paths</strong></td>
<td><code>command + shift + C</code></td>
<td><code>ctrl + shift + C</code></td>
</tr>
<tr>
<td><strong>移动代码块</strong></td>
<td><strong>Move Statement Up/Down</strong></td>
<td><code>command + shift + down/up</code></td>
<td><code>ctrl + shift + down/up</code></td>
</tr>
<tr>
<td><strong>代码补全</strong></td>
<td><strong>Complete Current Statement</strong></td>
<td><code>command + shift + enter</code></td>
<td><code>ctrl + shift + enter</code></td>
</tr>
<tr>
<td><strong>全路径查找</strong></td>
<td><strong>Find in Path</strong></td>
<td><code>command + shift + F</code></td>
<td><code>ctrl + shift + F</code></td>
</tr>
<tr>
<td><strong>代码高亮</strong></td>
<td><strong>Highlight Usages in File</strong></td>
<td><code>command + shift + F7</code></td>
<td><code>alt + J</code></td>
</tr>
<tr>
<td><strong>窗口内所有代码折叠/展开</strong></td>
<td><strong>Collapse/Expand All</strong></td>
<td><code>command + shift + 减号/加号</code></td>
<td><code>ctrl + shift + 减号/加号</code></td>
</tr>
<tr>
<td><strong>查找文件</strong></td>
<td><strong>Navigate/File</strong></td>
<td><code>command + shift + O</code></td>
<td><code>ctrl + shift + N</code></td>
</tr>
<tr>
<td><strong>全路径中替换</strong></td>
<td><strong>Replace in Path</strong></td>
<td><code>command + shift + R</code></td>
<td><code>ctrl + shift + R</code></td>
</tr>
<tr>
<td><strong>大小写转换</strong></td>
<td><strong>Toggle Case</strong></td>
<td><code>command + shift + U</code></td>
<td><code>ctrl + shift + U</code></td>
</tr>
<tr>
<td><strong>显示粘贴版历史</strong></td>
<td><strong>Paste from History</strong></td>
<td><code>command + shift + V</code></td>
<td><code>ctrl + shift + V</code></td>
</tr>
<tr>
<td><strong>快速查找定义</strong></td>
<td></td>
<td><code>command + space</code></td>
<td><code>ctrl + shift + I</code></td>
</tr>
<tr>
<td><strong>粘贴</strong></td>
<td><strong>Paste</strong></td>
<td><code>command + V</code></td>
<td><code>ctrl + V</code></td>
</tr>
<tr>
<td><strong>复制</strong></td>
<td><strong>Copy</strong></td>
<td><code>command + C</code></td>
<td><code>ctrl + C</code></td>
</tr>
<tr>
<td><strong>去除无效包引用</strong></td>
<td><strong>Optimize Imports</strong></td>
<td><code>control + option + O</code></td>
<td><code>ctrl + alt + O</code></td>
</tr>
<tr>
<td><strong>显示类关系继承体系</strong></td>
<td><strong>Type Hierarchy</strong></td>
<td><code>control + H</code></td>
<td><code>ctrl + H</code></td>
</tr>
<tr>
<td><strong>快速覆写方法</strong></td>
<td><strong>override Methods</strong></td>
<td><code>control + O</code></td>
<td><code>ctrl + O</code></td>
</tr>
<tr>
<td><strong>查找调用的位置</strong></td>
<td><strong>Call hierarchy</strong></td>
<td><code>control + option + H</code></td>
<td><code>ctrl + alt + H</code></td>
</tr>
<tr>
<td><strong>添加书签</strong></td>
<td><strong>Toggle Bookmark</strong></td>
<td><code>F3</code></td>
<td><code>F11</code></td>
</tr>
<tr>
<td><strong>扩大缩小选中范围</strong></td>
<td><strong>Extend Selection/Shrink Selection</strong></td>
<td><code>option + UP/Down</code></td>
<td><code>ctrl + W + shift + W</code></td>
</tr>
<tr>
<td><strong>跳转到父类</strong></td>
<td><strong>Super method</strong></td>
<td><code>command + U</code></td>
<td><code>ctrl + U</code></td>
</tr>
<tr>
<td><strong>关闭当前tab标签</strong></td>
<td><strong>Editor Tabs / Close</strong></td>
<td><code>command + W</code></td>
<td><code>ctrl + shift + a</code></td>
</tr>
<tr>
<td><strong>关闭除编辑窗口的其余窗口</strong></td>
<td><strong>Hide All Tool Windows</strong></td>
<td><code>command + shift + F12</code></td>
<td><code>ctrl + shift + F12</code></td>
</tr>
<tr>
<td><strong>预览方法定义</strong></td>
<td><strong>Quick Definition</strong></td>
<td><code>command + Y</code></td>
<td><code>ctrl + shift + I</code></td>
</tr>
<tr>
<td><strong>返回光标最后编辑位置</strong></td>
<td><strong>Last Edit Location</strong></td>
<td><code>command + shift + delete</code></td>
<td><code>control + shift + Backspace</code></td>
</tr>
<tr>
<td><strong>调到代码块首部/尾部</strong></td>
<td><strong>Move Caret To Code Block</strong></td>
<td><code>Option + Command + [ 或者 ]</code></td>
<td><code>Control+[ 或者 ]</code></td>
</tr>
<tr>
<td><strong>重命名</strong></td>
<td><strong>Rename</strong></td>
<td><code>shift + F6</code></td>
<td><code>shift + F6</code></td>
</tr>
<tr>
<td><strong>抽取方法</strong></td>
<td><strong>Extract Method</strong></td>
<td><code>command + option + M</code></td>
<td><code>control+alt+M</code></td>
</tr>
<tr>
<td><strong>抽取变量</strong></td>
<td><strong>Extract Variable</strong></td>
<td><code>command + option + V</code></td>
<td><code>control+alt+V</code></td>
</tr>
<tr>
<td><strong>抽取字段</strong></td>
<td><strong>Extract Field</strong></td>
<td><code>command + option + F</code></td>
<td><code>control+alt+F</code></td>
</tr>
<tr>
<td><strong>抽取常量</strong></td>
<td><strong>Extract Constant</strong></td>
<td><code>command + option + C</code></td>
<td><code>control+alt+C</code></td>
</tr>
<tr>
<td><strong>抽取参数</strong></td>
<td><strong>Extract Parameter</strong></td>
<td><code>command + option + P</code></td>
<td><code>control+alt+P</code></td>
</tr>
<tr>
<td><strong>重构入口</strong></td>
<td><strong>Refactor This</strong></td>
<td><code>control + T</code></td>
<td><code>ctrl + alt + shift + T</code></td>
</tr>
</tbody>
</table>
<p>转载标明出处:</p>
<ul>
<li><a href="https://github.com/suzeyu1992/repo.git" target="_blank" rel="external">作者GitHub</a></li>
<li><a href="http://szysky.com/2016/12/17/Android-Studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/" target="_blank" rel="external">博客地址</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/code/Android Studio 常用手册/" data-id="cj7sunbtw0000zfpjgfelley2" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/code/Android Studio 常用手册/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-java/设计模式六大原则解析" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/java/设计模式六大原则解析/">设计模式六大原则解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/java/设计模式六大原则解析/">
            <time datetime="2017-09-12T01:24:10.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/java/">java</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/java/设计模式/">设计模式</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/设计模式/">设计模式</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a><br>列举出设计模式中的六大原则应该如何实现</p>
</blockquote>
<h2 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 SRP"></a>单一职责原则 SRP</h2><blockquote>
<p>Single Responsibility Principle</p>
</blockquote>
<p><code>场景</code>: 如果让你写出一个图片缓存类, 要求内部实现缓存策略, 并提供方法只需要传递<code>控件</code>和<code>图片地址</code>就可以自动设置背景的类.</p>
<p>先给出最简单<code>直接</code>的写法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">    /**</div><div class="line">     * 图片的缓存</div><div class="line">     */</div><div class="line">    LruCache&lt;String , Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 线程池</div><div class="line">     */</div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    public ImageLoader()&#123;</div><div class="line">        // 初始化内存缓存策略</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initImageCache() &#123;</div><div class="line"></div><div class="line">        // 获得可使用的最大内存</div><div class="line">        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line"></div><div class="line">        // 设置 1/4 的最大内存为作为缓存</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line"></div><div class="line">        mImageCache = new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap value) &#123;</div><div class="line">                //  返回缓存的bitmap大小</div><div class="line">                return value.getRowBytes() * value.getHeight() /1024 ;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void displayImage(final ImageView iv, final String imgUrl)&#123;</div><div class="line">        // 获取缓存</div><div class="line">        Bitmap bitmap = mImageCache.get(imgUrl);</div><div class="line">        if(null != bitmap)&#123;</div><div class="line">             iv.setImageBitmap(bitmap);</div><div class="line">             return;</div><div class="line">        &#125;</div><div class="line">        // 网络加载</div><div class="line">        iv.setTag(imgUrl);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = downloadImage(imgUrl);</div><div class="line">                if (null == bitmap)</div><div class="line">                    return ;</div><div class="line">                if (iv.getTag().equals(imgUrl)) &#123;</div><div class="line">                    iv.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(imgUrl,bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据图片的url下载图片并转换成bitmap对象返回</div><div class="line">     */</div><div class="line">    public Bitmap downloadImage(String url)&#123;</div><div class="line">        Bitmap bitmap = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            URL url1 = new URL(url);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url1.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">​``` </div><div class="line"></div><div class="line"></div><div class="line">对于功能来说这是没有问题的. 但是接下来分析一下. 这样写会有什么弊端. </div><div class="line"></div><div class="line">1. 首先这个类的职责包括了两个`图片缓存的逻辑`和`图片下载的逻辑`. 耦合性太强,</div><div class="line">2. `类的职责过多`那么就会造成类中的代码更多,两个逻辑的代码会交叉分布. 不易被阅读.</div><div class="line">3. `扩展性`随着后续的实现`磁盘缓存`修改`加载图片`逻辑等会让代码越来越复杂难懂. </div><div class="line"></div><div class="line">那么重构一下, 让两个职责分离开来. </div><div class="line"></div><div class="line"></div><div class="line">​```java</div><div class="line">/**</div><div class="line"> * 处理图片的加载</div><div class="line"> */</div><div class="line">public class ImageLoader &#123;</div><div class="line">    /**</div><div class="line">     * 图片的缓存</div><div class="line">     */</div><div class="line">    ImageCache mImageCache = new ImageCache();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 线程池</div><div class="line">     */</div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    public void displayImage(final ImageView iv, final String imgUrl)&#123;</div><div class="line">        // 获取缓存</div><div class="line">         Bitmap bitmap = mImageCache.getCache(imgUrl);</div><div class="line">        if(null != bitmap)&#123;</div><div class="line">            iv.setImageBitmap(bitmap);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // 网络加载</div><div class="line">        iv.setTag(imgUrl);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = downloadImage(imgUrl);</div><div class="line">                if (null == bitmap)</div><div class="line">                    return ;</div><div class="line">                if (iv.getTag().equals(imgUrl)) &#123;</div><div class="line">                    iv.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.putCache(imgUrl,bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据图片的url下载图片并转换成bitmap对象返回</div><div class="line">     */</div><div class="line">    public Bitmap downloadImage(String url)&#123;</div><div class="line">        Bitmap bitmap = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            URL url1 = new URL(url);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url1.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 图片缓存逻辑处理类</div><div class="line"> */</div><div class="line">public class ImageCache &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 图片的缓存</div><div class="line">     */</div><div class="line">    LruCache&lt;String , Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public ImageCache()&#123;</div><div class="line">        // 初始化内存缓存策略</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initImageCache() &#123;</div><div class="line"></div><div class="line">        // 获得可使用的最大内存</div><div class="line">        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line"></div><div class="line">        // 设置 1/4 的最大内存为作为缓存</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line"></div><div class="line">        mImageCache = new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap value) &#123;</div><div class="line">                //  返回缓存的bitmap大小</div><div class="line">                return value.getRowBytes() * value.getHeight() /1024 ;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 提供一个对 bitmap 进行缓存的方法</div><div class="line">     */</div><div class="line">    public void putCache(String imgUrl, Bitmap bitmap)&#123;</div><div class="line">        mImageCache.put(imgUrl, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 对外提供一个 获取缓存的方法</div><div class="line">     */</div><div class="line">    public Bitmap getCache(String imgUrl)&#123;</div><div class="line">        return mImageCache.get(imgUrl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将原类拆分为两个类之后, 每个类的职责变得清晰. 如果需要更改<code>缓存策略</code>那么只需要修改<code>ImageCache</code>类总逻辑. 如果需要替换<code>HttpURLConnection</code>为<code>OKHttp</code>那么只需要在<code>ImageLoader</code>类中修改. 这样充分了体现了一个类<code>单一职责SRP</code>的好处, 清晰, 排除了修改时的多余干扰代码.</p>
<h2 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 OCP"></a>开闭原则 OCP</h2><blockquote>
<p>全称<code>Open Close Principle</code></p>
</blockquote>
<p><code>定义</code>: 对于对象应该对于扩展是开放的, 对于修改是封闭的. 就是在后续的功能添加的时候要尽可能做到不修改已存在的代码! 就是通过<code>继承</code> <code>接口</code>的特性来实现的. 就是我们口中常说的<code>面向接口编程</code></p>
<p>还是上面的代码, 这个时候我们如果想增添一个<code>二级缓存,添加一个磁盘的缓存</code>那么代码就如下了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 磁盘缓存</div><div class="line"> */</div><div class="line">public class DiskCache &#123;</div><div class="line"></div><div class="line">    public static final String cacheDir = &quot;sdcard/cache/&quot;;</div><div class="line"></div><div class="line">    // 从磁盘中获取缓存</div><div class="line">    public Bitmap getCache(String imgUrl)&#123;</div><div class="line">        return BitmapFactory.decodeFile(cacheDir+imgUrl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 向磁盘中缓存</div><div class="line">    public void putCache(String imgUrl, Bitmap bitmap)&#123;</div><div class="line">        try(FileOutputStream fileOutputStream = new FileOutputStream(cacheDir+imgUrl))&#123;</div><div class="line">            // 对bitmap压缩到本地文件</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 还需要对ImageLoader类进行部分修改 只贴出添加的代码</div><div class="line">/**</div><div class="line"> * 处理图片的加载</div><div class="line"> */</div><div class="line">public class ImageLoader &#123;</div><div class="line">    /**</div><div class="line">     * 磁盘缓存</div><div class="line">     */</div><div class="line">    DiskCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 设置一个标记表示是否开启磁盘缓存</div><div class="line">     */</div><div class="line">    public boolean isUseDiskCache = false;</div><div class="line">    </div><div class="line">    public void displayImage(final ImageView iv, final String imgUrl)&#123;</div><div class="line">        // 获取缓存</div><div class="line">         Bitmap bitmap = mImageCache.getCache(imgUrl);</div><div class="line">        if(null != bitmap)&#123;</div><div class="line">            iv.setImageBitmap(bitmap);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 判断磁盘缓存</div><div class="line">        if (isUseDiskCache)&#123;</div><div class="line">            bitmap = mDiskCache.getCache(imgUrl);</div><div class="line">            if (null != bitmap)</div><div class="line">                return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 省略相同的网络下载代码...   </div><div class="line">    &#125; </div><div class="line">    public void setUseDiskCache(boolean useDiskCache) &#123;</div><div class="line">        isUseDiskCache = useDiskCache;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此初步的添加功能需求已经完成, 增加了一个<code>DiskCache</code>类实现磁盘缓存, 并在<code>ImageLoader</code>类中进行判断使用的代码.</p>
<p><code>分析</code>: 现在的加载可以有两种.一种是只使用<code>LruCache</code>缓存, 另一种是实现两种缓存同时实现. 那么这样的代码会有怎样的问题?</p>
<ul>
<li>问题1: 如果想实现单磁盘缓存? 那么必须再对<code>ImageLoader</code>进行修改. 添加判断条件. 并且三种缓存策略<code>if</code>的判断也就比较多.</li>
<li>问题2: 如果用户想实现<code>自定义缓存</code>? 呵呵哒. 目前的代码没这么厉害的扩展性…</li>
</ul>
<p>那么看一下<code>UML</code>类图</p>
<p><img src="http://szysky.com/2016/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/1.png" alt="img"></p>
<p>可以看出只要添加一个缓存策略就要建立一个依赖关系.</p>
<p>那么如果通过<code>接口</code>的方式来修改代码呢. 看一下…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 缓存接口</div><div class="line"> */</div><div class="line">public interface BaseCache &#123;</div><div class="line"></div><div class="line">    // 添加缓存的抽象方法</div><div class="line">    void putCache(String imgUrl, Bitmap bitmap);</div><div class="line"></div><div class="line">    // 获取缓存的抽象方法</div><div class="line">    Bitmap getCache(String imgUrl);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 双缓存</div><div class="line"> */</div><div class="line">public class DoubleCache implements BaseCache &#123;</div><div class="line"></div><div class="line">    BaseCache mMemoryCache = new ImageCache();</div><div class="line">    BaseCache mDiskCache = new DiskCache();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void putCache(String imgUrl, Bitmap bitmap) &#123;</div><div class="line">        // 缓存</div><div class="line">        mMemoryCache.putCache(imgUrl, bitmap);</div><div class="line">        mDiskCache.putCache(imgUrl, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Bitmap getCache(String imgUrl) &#123;</div><div class="line">        // 先从缓存取没有再从sd取</div><div class="line">        Bitmap cache = mMemoryCache.getCache(imgUrl);</div><div class="line">        if (null == cache)&#123;</div><div class="line">            cache = mDiskCache.getCache(imgUrl);</div><div class="line">        &#125;</div><div class="line">        return cache;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 图片缓存逻辑处理类</div><div class="line"> */</div><div class="line">public class ImageCache  implements BaseCache&#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 图片的缓存</div><div class="line">     */</div><div class="line">    LruCache&lt;String , Bitmap&gt; mImageCache;</div><div class="line"></div><div class="line">    public ImageCache()&#123;</div><div class="line">        // 初始化内存缓存策略</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initImageCache() &#123;</div><div class="line"></div><div class="line">        // 获得可使用的最大内存</div><div class="line">        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line"></div><div class="line">        // 设置 1/4 的最大内存为作为缓存</div><div class="line">        final int cacheSize = maxMemory / 4;</div><div class="line"></div><div class="line">        mImageCache = new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class="line">            @Override</div><div class="line">            protected int sizeOf(String key, Bitmap value) &#123;</div><div class="line">                //  返回缓存的bitmap大小</div><div class="line">                return value.getRowBytes() * value.getHeight() /1024 ;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 提供一个对 bitmap 进行缓存的方法</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void putCache(String imgUrl, Bitmap bitmap)&#123;</div><div class="line">        mImageCache.put(imgUrl, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 对外提供一个 获取缓存的方法</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public Bitmap getCache(String imgUrl)&#123;</div><div class="line">        return mImageCache.get(imgUrl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 处理图片的加载</div><div class="line"> */</div><div class="line">public class ImageLoader &#123;</div><div class="line">    /**</div><div class="line">     * 图片的缓存 默认只是内存缓存</div><div class="line">     */</div><div class="line">    BaseCache mImageCache = new ImageCache();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 注入缓存策略</div><div class="line">     */</div><div class="line">    public void setmImageCache(BaseCache mImageCache) &#123;</div><div class="line">        this.mImageCache = mImageCache;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    /**</div><div class="line">     * 线程池</div><div class="line">     */</div><div class="line">    ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line"></div><div class="line">    public void displayImage(final ImageView iv, final String imgUrl)&#123;</div><div class="line">        // 获取缓存 具体的缓存策略实现了依赖注入. 有调用者后续决定, 默认内存缓存</div><div class="line">         Bitmap bitmap = mImageCache.getCache(imgUrl);</div><div class="line">        if(null != bitmap)&#123;</div><div class="line">            iv.setImageBitmap(bitmap);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 网络加载</div><div class="line">        iv.setTag(imgUrl);</div><div class="line">        mExecutorService.submit(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Bitmap bitmap = downloadImage(imgUrl);</div><div class="line">                if (null == bitmap)</div><div class="line">                    return ;</div><div class="line">                if (iv.getTag().equals(imgUrl)) &#123;</div><div class="line">                    iv.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.putCache(imgUrl,bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据图片的url下载图片并转换成bitmap对象返回</div><div class="line">     */</div><div class="line">    public Bitmap downloadImage(String url)&#123;</div><div class="line">        Bitmap bitmap = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            URL url1 = new URL(url);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url1.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码没有<code>单磁盘缓存</code>的策略, 但是如果现在想要实现了这个功能, 怎么做? 只需要创建一个类实现<code>BaseCache</code>. 在创建<code>ImageLoader</code>的时候通过<code>setmImageCache()</code>来注入不同的实现. <code>不需要修改源代码</code>, 并且<code>ImageLoader</code>中的<code>if</code>语句判断和<code>布尔标记</code>也完全不需要, 代码更加简洁.</p>
<p>看一下类图:</p>
<p><img src="http://szysky.com/2016/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/2.png" alt="img"></p>
<p>可以看到<code>ImageLoader</code>依赖了接口编程. 接口定义了缓存的共性方法. 在后续只要是其子类就可以使用.这不正满足了<code>开闭原则的定义</code>, <code>对修改封闭, 对于扩展开放</code>了.</p>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 LSP"></a>里氏替换原则 LSP</h2><blockquote>
<p>全称<code>Liskov Substitution Principle</code></p>
</blockquote>
<p><code>定义</code>: 所有引用基类的地方必须能透明的使用其子类.</p>
<p>说白了就是Java中的<code>继承</code>和<code>多态</code>的特性. 父类可以直接引用子类类型. 比如<code>Object</code>可以引用任何类型的概念.</p>
<p>其实在上面的<code>开闭原则</code>中就已经存在了<code>里氏替换</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 注入缓存策略</div><div class="line">*/</div><div class="line">public void setmImageCache(BaseCache mImageCache) &#123;</div><div class="line">   this.mImageCache = mImageCache;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数接收的<code>BaseCache</code>类型. 可以透明的引用任何的子类. 通过<code>抽象</code>实现了多种可能.</p>
<p>一般来说<code>开闭原则</code>和<code>里氏替换</code>是不离不弃, 生死相依的. 通过<code>里氏替换</code>达到了对扩展的开发, 对修改封闭的效果. 这两个原则同时实现了一个<code>OOP</code>的一个重要特性<code>抽象</code></p>
<h2 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h2><blockquote>
<p>全称:Dependence Inversion Principle</p>
</blockquote>
<p><code>定义</code>: 指代了一种特定的解耦方式, 使得<code>高层次</code>的模块不依赖于<code>低层次的模块实现细节</code>.</p>
<ul>
<li>高层次模块不应该依赖低层次, 两者都应该依赖其抽象</li>
<li>抽象不应该依赖细节</li>
<li>细节应该依赖抽象</li>
</ul>
<p>而在<code>Java</code>中的表现就是: <code>模块间的依赖通过抽象发生, 实现类之间不发生直接的依赖关系, 其依赖关系是通过接口或抽象产生的</code></p>
<p>直接看代码, 还是上面的<code>ImageLoader</code>类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 依赖于接口抽象, </div><div class="line">BaseCache mImageCache = new ImageCache();</div><div class="line"></div><div class="line">// 依赖于细节, 内存缓存</div><div class="line">ImageCache mImageCache = new ImageCache();</div><div class="line">// 依赖于细节, 双缓存</div><div class="line">DoubleCache mImageCache = new DoubleCache();</div></pre></td></tr></table></figure>
<p>如果依赖了内存缓存细节, 那么注入的缓存策略必须是<code>ImageCache</code>的子类. 但是这个子类已经具备一个细节的实现, 我们再去做其他细节的实现. 岂不是很怪异. 这个类中的出现的方法也是匪夷所思. 并且可能用户实现的具体策略也不一定是<code>内存</code>方法的缓存. 在命名上的限制也是很不友好.</p>
<p>总结一句话: <code>依赖抽象, 而不依赖具体实现</code></p>
<h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 ISP"></a>接口隔离原则 ISP</h2><blockquote>
<p>全称: Interface Segregation Principle</p>
</blockquote>
<p><code>定义</code>: 类间的依赖关系应该建立在最小的接口上.</p>
<p>接口隔离的原则就是让系统接口耦合, 从而更容易重构, 更改和重新部署.</p>
<p>对于操作<code>IO</code>或者<code>网络</code>我们总是需要在<code>finally</code>中确保资源的释放. 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fileOutputStream = null;</div><div class="line">try&#123;</div><div class="line">  fileOutputStream = new FileOutputStream(cacheDir+imgUrl);</div><div class="line">  bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">&#125;catch (IOException e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">&#125;finally &#123;</div><div class="line">  try &#123;</div><div class="line">      fileOutputStream.close();</div><div class="line">  &#125; catch (IOException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是多么蛋疼的代码… 一堆堆的花括号.</p>
<p>对于可关闭的对象, 都具备一个接口<code>Closeable</code>. 这个接口一个空接口, 也就是<code>标识接口</code>. 作用? 就是标识这个对象可以调用<code>close()</code>被关闭. 体现了一类对象的某一个特性. 而且这个特性<code>建立在了最小接口</code>的原则上.</p>
<p>那么编写这么一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class CloseUtils &#123;</div><div class="line">    </div><div class="line">    // 整个方法通过最小接口的特性, 实现了隔离其他无用的属性. 只关心</div><div class="line">    // Closeable接口即可. 接口隔离</div><div class="line">    </div><div class="line">    // 参数 对应了里氏替换的原则</div><div class="line">    public static void fastClose(Closeable closeObj)&#123;</div><div class="line">        if (null != closeObj)&#123;</div><div class="line">            try &#123;</div><div class="line">                // close()方法的调用, 对应了 依赖倒置原则</div><div class="line">                closeObj.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前的代码调用就变成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fileOutputStream = null;</div><div class="line">try&#123;</div><div class="line">  fileOutputStream = new FileOutputStream(cacheDir+imgUrl);</div><div class="line">  bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream);</div><div class="line">&#125;catch (IOException e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">&#125;finally &#123;</div><div class="line">  CloseUtils.fastClose(fileOutputStream);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不仅简单, 而且方便到处调用, 看起来也舒服多了.</p>
<h2 id="迪米特原则-LOD"><a href="#迪米特原则-LOD" class="headerlink" title="迪米特原则 LOD"></a>迪米特原则 LOD</h2><blockquote>
<p>Law of Demeter</p>
</blockquote>
<p>就是一个对象应该尽可能少的关联其他对象.</p>
<p>通俗讲, 一个类应该对自己需要耦合或调用的类知道的<code>最少</code>, 类的内部如何实现与调用者或者依赖者没有关系, 调用者或者依赖者只需要知道他需要的方法即可, 其他的一概不关心. 因为类与类之间的关系越密切, 耦合度也就越大, 当一个类发生改变时, 对另一个类的影响也会变大.</p>
<p>太懒了, 无具体实现…</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/java/设计模式六大原则解析/" data-id="cj7hnifbv00016opjrfkqwgiq" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/java/设计模式六大原则解析/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-java/设计模式之路" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/java/设计模式之路/">设计模式之路</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/java/设计模式之路/">
            <time datetime="2017-09-12T01:23:31.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/java/">java</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/java/设计模式/">设计模式</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/设计模式/">设计模式</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="灵活之路-面向对象六大原则"><a href="#灵活之路-面向对象六大原则" class="headerlink" title="灵活之路 - 面向对象六大原则"></a>灵活之路 - 面向对象六大原则</h2><p><code>如果下面文字描述,不是很明白那么跳转到后面链接有详细代码说明</code><a href="http://szysky.com/2016/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">原则解析</a></p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">单一职责原则SRP(Single Responsibility Principle)</div></pre></td></tr></table></figure>
<ul>
<li><code>定义</code>: 就一个类而言, 应该仅有一个引起它的变化的原因. <code>通俗点</code>就是一个类应该是相关性很高数据封装</li>
<li><code>举例</code>: 现在有一个图片加载类. 但是这个类内部包含了<strong>图片下载的逻辑</strong>,<strong>图片缓存的逻辑</strong>这样就使得这个类的职责过多, 随着功能的不断完善, 这个类的代码和逻辑也变得纵横交错混合在了一起. 对于后续的修改维护扩展都是不利的. 所以让两个类组合起来, 一个类内部只负责<strong>图片下载</strong>,另一个类内部负责<strong>图片缓存</strong>. 保持每个类的<strong>单一职责</strong></li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">开闭原则OCP(Open Close Principle)</div></pre></td></tr></table></figure>
<ul>
<li><code>定义</code>: 软件中的对象应该对于<strong>扩展</strong>是<strong>开放</strong>的 但是对于<strong>修改</strong>是<strong>封闭</strong>的. <code>通俗点</code> : 尽量通过<strong>扩展的方式</strong>来实现变化, 而不是通过修改已有的代码来实现.</li>
<li><code>举例</code>: 此时我们实现了一个<strong>双缓存类</strong>和<strong>单缓存类</strong>. 在<strong>图片加载类</strong>中进行这两个缓存类的实例. 并对外暴露一个布尔值让用户设置是否使用双缓存来决定内部缓存的逻辑. ok. 目前看可能没有问题. 但是如果有一个更好的缓存算法类, 这时候每次都需要在<strong>图片加载类中修改代码</strong>. 这就违反了<code>OCP</code>原则, 利用<strong>继承,接口</strong>的特性可以让此类问题得以解决. 比如: 我们可以定义一个<code>缓存接口</code>, 在<strong>加载类</strong>中使用的个这个接口中的方法. 而这个接口的具体实现通过暴露一个方法让外部调用的时候传入, 以后如果有新的缓存类只需要调用方法传入接口的子类就可以. 这样就对于原始代码修改进行了关闭, 而对于扩展是开放的.</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">里氏替换原则LSP(Liskov Substitution Principle)</div></pre></td></tr></table></figure>
<ul>
<li><code>定义</code>: 所有引用基类的地方必须能透明地使用其子类. <code>通俗点</code>:是基于继承,多态两大特性. 再简单点<strong>抽象</strong></li>
<li><code>举例</code>: <code>Window#show(View view)</code>这个方法接收一个<strong>View</strong>, 但是我们可以<code>Button</code>,<code>TextView</code>等等. 其实很简单. 我们常用只不过不知道这个名字而已. 所以<code>LSP</code>的原则的核心就是<strong>抽象</strong>. 抽象又依赖于继承这个特性. <strong>通常开闭原则和里氏替换是不离不弃的</strong>例如上面<code>OCP</code>中举得例子. 在外部调用就是利用了继承的特性, 也就是<strong>里氏替换</strong></li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">依赖倒置原则DIP(Dependence Inversion Principle)</div></pre></td></tr></table></figure>
<ul>
<li><code>定义</code>: 指代了一种特定的解耦形式, 使得高层次的模块不依赖于低层次的模块的实现细节的目的, 依赖模块被颠倒了. <code>通俗点</code>: 在Java中依赖抽象(接口,抽象类), 而不依赖具体实现类. 模块之间的依赖通过<strong>抽象</strong>发生, 实现类之间不发生直接的依赖关系, 其依赖关系是通过接口或抽象类产生.</li>
<li><code>举例</code>: 还是在<code>OCP</code>中的例子, 内部加载类依赖于也就是成员变量是<code>缓存接口</code>, 而不是具体的某一个<code>单缓存</code>或者<code>双缓存</code>的实现类.</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">接口隔离原则ISP(Interface Segregation Principles)</div></pre></td></tr></table></figure>
<ul>
<li><code>定义</code>: 接口的依赖关系应该建立在最小的接口上. <code>通俗点</code>:接口隔离原则的目的是系统解开耦合, 从而容易重构, 更改和重新部署.</li>
<li><code>举例</code>: 在操作一些<strong>IO文件,网络</strong>的时候我们总是伴随着<code>try...catch...finally</code>. 在最终调用块中调用<code>close()</code>确保资源可以正确的释放. 但这样这样的代码不仅可读性差可以每次都是写一些冗余的模板代码. 其实可以提供一个静态方法, 而根据java中的的特性,之上操作的对象都会实现一个<strong>标识接口Closeable</strong>,这个接口标识了一个可关闭的对象有一个<code>close()</code>. 所以这个静态方法的形参接收一个<code>Closeable</code>接口,并在方法内调用<code>close()</code>即可. 仔细想想: 这个方法的形参在调用的时候传入的实参是<strong>里氏替换原则</strong>, 而方法内部调用的是一个接口的<code>close()</code>方法,但传入的可能是某一个实现类,那么这不就是<strong>依赖导致原则</strong>,并且建立在最小化的依赖基础上, 只要知道这个对象是可关闭的, 别的一概不关心, 这就是<strong>接口隔离原则</strong>.</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">迪米特原则LOD(Law of Demeter)</div></pre></td></tr></table></figure>
<ul>
<li><code>定义</code>: 一个对象应该对其他对象有<strong>最少</strong>的了解. <code>通俗点</code>: 一个类应该对自己需要耦合或调用的类知道的最少, 类的内部如果实现与调用者或者依赖者没有关系, 调用者或者依赖者只需要知道他需要的方法即可, 其他一概不管.</li>
<li><code>举例</code>: 房间类, 中介类, 上班族类. 可以<strong>上班族</strong>应该只关心<strong>中介类</strong>, 而不需要关注<strong>房间类</strong>. 只需要<strong>中介类</strong>返回房子的地址即可. 而不需要通过调用<strong>中介类</strong>返回一个<strong>房间类</strong> . 这也就是代码中需要注意的. 不要过度耦合, 要降低类之间的关系.</li>
</ul>
</li>
</ul>
<h2 id="启航之路-UML类图说明"><a href="#启航之路-UML类图说明" class="headerlink" title="启航之路 - UML类图说明"></a>启航之路 - UML类图说明</h2><blockquote>
<p>对于许多类组成的庞大关系网, 最好的办法是通过图来表示出其关系. 可以直观的看出组合的元素, 元素直接是如何存在的, 元素与哪些元素直接存在着联系等. 表示出来的图就是<code>UML类图</code>.</p>
</blockquote>
<p>可以看如下一个稍微完整的一个<code>UML类图</code></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_ALL.png" alt="img"></p>
<hr>
<p><strong>组成元素</strong></p>
<ul>
<li><code>类和接口</code>: 通过黄色的矩形框来表示一个类, 例如上面鸟就是一个<strong>普通类</strong>, 如果类名是斜体那么就是<strong>抽象类</strong>, 如果和<strong>飞翔</strong>或者<strong>唐老鸭</strong>的表示法那么就是接口.</li>
<li><code>访问权限</code>: 通过<code>+ 公共权限</code>, <code>- 私有权限</code>, <code># 保护权限</code></li>
<li><code>变量和方法</code>: 分别在第二行, 和第三行表示,抽象方法同样斜体表示, 静态属性的用下划线表示.</li>
</ul>
<hr>
<p><strong>关系结构</strong></p>
<ul>
<li><code>继承关系</code>: 类与类之间的关系, 通过<strong>空心三角+实线</strong>表示, 通过<strong>箭头的方向指向父类</strong>表述关系.</li>
<li><code>实现关系</code>: 类与接口直接的关系, 通过<strong>空心三角+虚线</strong>表示, 通过<strong>箭头的方向指向接口</strong>表述关系.</li>
<li><code>关联关系</code>: 当一个类知道另一个类的时候,可以使用<strong>关联</strong>, 比如企鹅和气候两个类中, <code>企鹅类的变量有气候类的引用</code>, 这个时候就如上图之间的关系. <strong>实线箭头</strong>表示, <strong>箭头指向被知道的类</strong></li>
<li><code>依赖关系</code>: 例如<strong>动物</strong>是依赖<strong>氧气和水的</strong>, 就如<code>动物类中的方法形参类型依赖这两个类型</code>. 如上图动物和水之间关系. 使用<strong>虚线箭头</strong>, <strong>箭头指向被依赖的类</strong></li>
<li><code>聚合关系</code>: 表示一种弱拥用, A可以包含B, 但B不可以包含A. 如大雁和雁群两个类. 雁群类中会有一个数组,数组的元素是大雁类型. 这之间就是<code>聚合</code>. 使用<strong>空心菱形+实线箭头</strong></li>
<li><code>合成关系</code>: 也可以认为是<code>组合</code>. 是一种强拥有关系. 例如鸟类和翅膀类, 鸟类是整体, 翅膀类是部分. 并且其生命周期相同, 对应着就是<strong>在鸟类初始化的时候,翅膀类也会随之初始化</strong>. 并且, 上图中的鸟到翅膀还有<code>1..2</code>的字样. 这称为<strong>基数</strong>. 表明一段会有几个实例, 例如一个鸟会有两个翅膀. 如果一个类有无数个实例那就用<code>n</code>表示. <code>关联关系</code>,<code>聚合关系</code>也是可以有<strong>基数</strong>的. 使用<strong>实心菱形+实线箭头</strong>表示.</li>
</ul>
<blockquote>
<p>编程是门技术, 更加是一门艺术, 不能只满足代码结果运行正确就完事, 时常考虑如果让代码更加简练, 更加容易维护, 更易扩展和复用, 这样才可以真正提高.</p>
</blockquote>
<h2 id="发现之路-23种设计模式"><a href="#发现之路-23种设计模式" class="headerlink" title="发现之路 - 23种设计模式"></a>发现之路 - 23种设计模式</h2><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3><h4 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h4><ul>
<li><code>定义</code>: 确保某个类只有一个实例, 而且自行实例化并向整个系统提供这个实例.</li>
<li><code>场景</code>: 确保一个类只会有一个对象实例, 避免产生多个对象消耗过多的资源, 或者某种类型的对象只应该有且只有一个. 如创建一个对象需要消耗的资源过多, 访问IO和数据库等资源时就可以考虑单例.</li>
</ul>
<h4 id="模式范例"><a href="#模式范例" class="headerlink" title="模式范例"></a>模式范例</h4><p>单例模式的实现有5种.</p>
<ul>
<li>饿汉式单例 –&gt; <a href="https://github.com/suzeyu1992/AlgorithmTraining/blob/master/src/design/single/HungrySingle.java" target="_blank" rel="external">实现代码</a></li>
<li>懒汉式单例 –&gt; <a href="https://github.com/suzeyu1992/AlgorithmTraining/blob/master/src/design/single/LazySingle.java" target="_blank" rel="external">实现代码</a></li>
<li>静态内部类单例 –&gt; <a href="https://github.com/suzeyu1992/AlgorithmTraining/blob/master/src/design/single/InnerStaticSingle.java" target="_blank" rel="external">实现代码</a></li>
<li>枚举单例 –&gt; <a href="https://github.com/suzeyu1992/AlgorithmTraining/blob/master/src/design/single/EnumSingle.java" target="_blank" rel="external">实现代码</a></li>
<li>容器实现单例 –&gt; <a href="https://github.com/suzeyu1992/AlgorithmTraining/blob/master/src/design/single/CollectionSingle.java" target="_blank" rel="external">实现代码</a> 这种方式在<code>android</code>源码中存在.</li>
</ul>
<hr>
<p><strong>知识扩展</strong></p>
<p><code>枚举实现法</code>最大的优点就是实现简单, 但是在<code>android</code>却比较消耗内存. 有一点与其他单例模式不同的是: 默认枚举实例的创建<code>是线程安全的</code>. 为什么? 因为其他的单例在一种特定的场合下会重新创建对象,那就是<code>反序列化</code>.</p>
<p><code>反序列化</code>是从磁盘读回数据并创建一个新的对象. 即使构造函数是私有的, 反序列化依然可以通过特殊的途径去创建一个实例, 相当于调用了构造函数. 反序列化提供了一个很特别的<code>钩子函数</code>, 类中具有一个私有的, 被实例化的方法<code>readResolver()</code>, 这个方法可以让开发人员控制对象的反序列化. 例如上面的几个单例模式, 如果想杜绝单例对象在被反序列化时重新生成对象, 那么必须加入如下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private Object readResolve() throws ObjectStreamException()&#123;</div><div class="line">    return sInstent;        // 返回单例中的实例对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在反序列化的时候就不是默认的重新生成一个新对象. 而对于枚举,并不存在这个问题. 因为即使反序列化它也不会重新生成新的实例.</p>
<h4 id="Android源码对应模式"><a href="#Android源码对应模式" class="headerlink" title="Android源码对应模式"></a>Android源码对应模式</h4><p>我们经常会在<code>Activity</code>中通过<code>getSystemService(String name)</code>这个函数来获取系统的服务, 比如说<code>WMS</code>,<code>AMS</code>,<code>LayoutInflater</code>等等. 这些服务都会在某一时刻以<code>容器单例</code>的形式保存在应用中.</p>
<p>以<code>Adapter#getView()</code>中使用布局加载器<code>LayoutInflate.from(context).inflate(layoutId,null)</code>为例</p>
<p>会调用<code>ContextImpl#getSystemService(String)</code>方法获取服务, 而方法内部只是从一个<code>SYSTEM_SERVICE_MAP</code>名字的集合中获取了一个<code>ServiceFetcher</code>对象, 并从其中获取具体的服务返回.</p>
<p>那么我们可以缕一下应用的启动, 并定位到何时保存的这些服务到这个集合的.</p>
<ol>
<li>首先应用的入口为<code>ActivityThread#main()</code>,在这个函数里面会创建<code>ActivityThread</code>对象, 并启动消息循环(UI)线程, 调用<code>attach(boolean)</code>函数</li>
<li>在<code>attach(boolean)</code>中通过<code>Binder</code>机制与<code>ActivityManagerService</code>通信, 最终回调本类的<code>handlelaunchActivity()</code>函数.</li>
<li>然后执行<code>PerformLaunchActivity()</code>函数, 开始创建<code>Application</code>,<code>Context</code>,<code>Activity</code>, 并把上下文关联到<code>Activity</code>中, 最终调用<code>Activity#onCreate()</code></li>
</ol>
<p>ok刚才大概流程是这样的, 通过之前的分析我们知道, 各个系统服务是保存在<code>ContextImpl类中的</code>, 这个类是在上面的第3步中被初始化的. 看如下代码, 就是服务被注册的代码, 时机也就是第一个<code>Context</code>被创建的时候.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class ContextImpl extends Context &#123;</div><div class="line">    // 存储所有系统服务的集合</div><div class="line">    private static final HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP =new HashMap&lt;String, ServiceFetcher&gt;();</div><div class="line">    </div><div class="line">    // 一个注册服务的并添加到结合的方法</div><div class="line">    private static void registerService(String serviceName, ServiceFetcher fetcher) &#123;</div><div class="line">       if (!(fetcher instanceof StaticServiceFetcher)) &#123;</div><div class="line">           fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++;</div><div class="line">       &#125;</div><div class="line">       SYSTEM_SERVICE_MAP.put(serviceName, fetcher);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 静态语句块, 只在类第一次被加载的时候调用, 保证了服务只被添加一次.</div><div class="line">    static &#123;</div><div class="line">        // 注册了LayoutInflate服务</div><div class="line">        registerService(LAYOUT_INFLATER_SERVICE, new ServiceFetcher() &#123;</div><div class="line">                public Object createService(ContextImpl ctx) &#123;</div><div class="line">                    return PolicyManager.makeNewLayoutInflater(ctx.getOuterContext());</div><div class="line">                &#125;&#125;);</div><div class="line">                </div><div class="line">        registerService(INPUT_SERVICE, new StaticServiceFetcher() &#123;</div><div class="line">                public Object createStaticService() &#123;</div><div class="line">                    return InputManager.getInstance();</div><div class="line">                &#125;&#125;);</div><div class="line"></div><div class="line">        /**</div><div class="line">         *  后面省略一大坨的注册的服务代码</div><div class="line">        **/</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h3><h4 id="模式介绍-1"><a href="#模式介绍-1" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>一个复杂的对象有很多组成成分, 如汽车, 车轮, 方向盘, 发动机,等等. 为了在构建过程中对外部隐藏实现细节, 就可以使用<code>Builder</code>模式将部件和组装过程分离, 使得构建过程和部件都可以自由扩展, 两者之间的耦合也将到了最低.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ol>
<li>当初始化一个队形特别复杂, 参数特别多, 且有很多参数都具有默认值时.</li>
<li>相同的方法, 不同的执行顺序, 产生不同的事件结果时</li>
<li>多个部件或零件, 都可以装配到一个对象中, 但是产生的运行结果又不相同.</li>
</ol>
</li>
</ul>
<h4 id="模式范例-1"><a href="#模式范例-1" class="headerlink" title="模式范例"></a>模式范例</h4><p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/builder" target="_blank" rel="external">范例代码</a></p>
<p>范例的UML类图</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Builder.png" alt="img"></p>
<p>上例中通过具体<code>MacbookBuilder</code>类构建<code>Macbook</code>对象, 而<code>Director</code>封装了构建复杂产品对象的过程, 对外隐藏了构建的细节. <code>Builder</code>于<code>Director</code>一起将一个复杂对象的构建与它的表示分离, 是的同样的构建过程可以创建不同的对象.</p>
<p>可能你会觉得<code>唉? 怎么和我见过的Builder模式不一样呢?</code> ,这是因为<code>Director</code>这个角色经常会被忽略. 而直接使用一个<code>Builder</code>来进行对象的封装, 并且这个<code>Builder</code>通常为<strong>链式调用</strong>, 它的每个<code>setter</code>方法都会返回<code>this</code>自身, 比如我们常用的<code>AlertDialog</code>. 下节介绍.</p>
<h4 id="Android源码模式实现"><a href="#Android源码模式实现" class="headerlink" title="Android源码模式实现"></a>Android源码模式实现</h4><p>在Android中最经典的<code>Builder</code>实现就是<code>AlertDialog</code>. 看一下开发中的使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 一个粗略的创建dialog</div><div class="line">// 创建构建者builder角色</div><div class="line">AlertDialog.Builder builder = new AlertDialog.Builder(this);</div><div class="line">builder.setIcon(android.R.drawable.sym_def_app_icon)</div><div class="line">      .setTitle(&quot;标题&quot;)</div><div class="line">      .setMessage(&quot;message&quot;)</div><div class="line">      // 设置点击等..</div><div class="line">      .setPositiveButton(&quot;确定&quot;, null);</div><div class="line"></div><div class="line">// 构建</div><div class="line">AlertDialog alertDialog = builder.create();</div><div class="line"></div><div class="line">// 显示</div><div class="line">alertDialog.show();</div></pre></td></tr></table></figure>
<p>从类名就可以看出这是一个<code>Builder模式</code>, 通过<code>Builder</code>对象来组装<code>Dialog</code>的各个部分. 将<code>Dialog</code>的构造和表示进行了分离.</p>
<p>接下来看一下<code>AlertDialog</code>的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div></pre></td><td class="code"><pre><div class="line">public class AlertDialog extends Dialog implements DialogInterface &#123;</div><div class="line">    // AlertController 这个对象会保存Builder对象中的各个参数</div><div class="line">    private AlertController mAlert;</div><div class="line">    </div><div class="line">    // 实际上操作的是上面这个变量中的属性</div><div class="line">    @Override</div><div class="line">    public void setTitle(CharSequence title) &#123;</div><div class="line">        super.setTitle(title);</div><div class="line">        mAlert.setTitle(title);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setMessage(CharSequence message) &#123;</div><div class="line">        mAlert.setMessage(message);</div><div class="line">    &#125;</div><div class="line">    // 省略一坨代码如各种setter等</div><div class="line">    // Builder以内部类的形式存在</div><div class="line">    public static class Builder &#123;</div><div class="line">        // 1.存储AlertDialog的各个参数 如title,icon等</div><div class="line">        private final AlertController.AlertParams P;</div><div class="line">        </div><div class="line">        // 构造函数</div><div class="line">        public Builder(Context context) &#123;</div><div class="line">            this(context, resolveDialogTheme(context, 0));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 2. 设置参数, 我们构建的Builder设置的参数就是这些方法</div><div class="line">        public Builder setTitle(int titleId) &#123;</div><div class="line">            P.mTitle = P.mContext.getText(titleId);</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        public Builder setTitle(CharSequence title) &#123;</div><div class="line">            P.mTitle = title;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // ....</div><div class="line">        </div><div class="line">        // 3.构建AlertDialog, 传递参数</div><div class="line">        public AlertDialog create() &#123;</div><div class="line">            // 4.因为已经通过builder设置了参数, 接下来就可以创建真正需要的AlertDialog对象</div><div class="line">            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);</div><div class="line">            </div><div class="line">            // 5.将Builder类中的成员变量P应用到AlertDialog类中</div><div class="line">            P.apply(dialog.mAlert);</div><div class="line">            dialog.setCancelable(P.mCancelable);</div><div class="line">            if (P.mCancelable) &#123;</div><div class="line">                dialog.setCanceledOnTouchOutside(true);</div><div class="line">            &#125;</div><div class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</div><div class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</div><div class="line">            if (P.mOnKeyListener != null) &#123;</div><div class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</div><div class="line">            &#125;</div><div class="line">            return dialog;</div><div class="line">        &#125;      </div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line">​``` </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">对, 最后还调用了`AlertDialog#show()`函数, 这个函数主要做了如下几件事情:</div><div class="line"> </div><div class="line">1. 通过`dispatchOnCreate()`函数来调用`AlertDialog#onCreate()`函数</div><div class="line">2. 然后调用`AlertDialog#onStart()`函数</div><div class="line">3. 最后将`Dialog`的`DecorView`添加到`WindowManager`中.</div><div class="line"></div><div class="line">那么在看一下`onCreate()`函数的源码及后续调用.</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">​```java</div><div class="line">// AlertDialog类</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">   super.onCreate(savedInstanceState);</div><div class="line">   mAlert.installContent();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// AlertController类</div><div class="line">public void installContent() &#123;</div><div class="line">   // 设置窗口, 没有title类型</div><div class="line">   mWindow.requestFeature(Window.FEATURE_NO_TITLE);</div><div class="line">   int contentView = selectContentView();</div><div class="line">   // 设置窗口的内容视图</div><div class="line">   mWindow.setContentView(contentView);</div><div class="line">   // 初始化AlertDialog其他子视图的内容</div><div class="line">   setupView();</div><div class="line">   setupDecor();</div><div class="line">&#125;</div><div class="line">​```  </div><div class="line">     </div><div class="line">这部分比较重要, 通过`Window#setContentView()`和Activity是一样的过程, 设置了内容布局, 通过`AlertController`的构造函数可以发现加载布局资源就是`com.android.internal.R.layout.alert_dialog`这个文件, 之前的Builder中的各种`setter`方法就是把设置的内容传入到这个布局当中. </div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">可以看到`Android源码中的AlertDialog`并没有遵循`GOF设计模式`中经典的实现方式, 而是进行了变种, 但却使其使用更加的方便. 这里`AlertDialog.Builder`这个类同时扮演了范例中的`builder`,`具体实现builder`,`Director`的角色. 简化了`Builder`设计模式, 因为模块比较稳定不会存在变化, 根据具体场景简化模式, 正是体现了灵活运用设计模式的实例.</div><div class="line"></div><div class="line"></div><div class="line">#### 实战场景</div><div class="line"></div><div class="line">就如`Picasso`,`Glide`等链式的调用, 你可以通过链式设置很多配置属性, 也可以仅调用两三此传入必要参数即可. 是的调用实现更加灵活. </div><div class="line"></div><div class="line"></div><div class="line">### 原型模式 Prototype</div><div class="line"></div><div class="line">#### 模式介绍</div><div class="line"></div><div class="line">&gt; **创建性**模式, 从一个样板对象中复制出一个内部属性一致的对象, 其实就是**克隆**. 而被复制的对象就叫做**原型**, 多用于创建复杂的或者构造耗时的实例</div><div class="line"></div><div class="line">* `定义`: 用原型实例指定创建对象的种类, 并通过拷贝这些原型创建新的对象.</div><div class="line">* `场景`: </div><div class="line">    1. 类初始化需要消耗非常多的资源, 这个资源包括数据,硬件资源等, 可通过原型拷贝避免这些消耗</div><div class="line">    2. 通过`new`产生一个对象需要非常繁琐的数据准备或访问权限, 同样可以使用原型模式</div><div class="line">    3. 一个对象需要提供给其他对象访问, 并且会能会对其修改属性, 可以用原型拷贝多个对象提供使用</div><div class="line"></div><div class="line">其实这个模式很简单, 就是利用`Object#clone()`方法可以复制一份提供使用(clone是一个`native`方法). 但是需要注意, 通过实现`Cloneable`接口的原型模式在调用`clone`函数构造并不一定就比通过`new`方式的快, 只有当通过`new`构造对象较为耗时或者说成本较高时, 通过`clone`方法才能获得效率提升.</div><div class="line"></div><div class="line">**UML类图**</div><div class="line"></div><div class="line">![](UML_Prototype.png)</div><div class="line"></div><div class="line">#### 模式范例</div><div class="line"></div><div class="line">这里模式实现很简单, 实现也比较少, 这里就贴出代码</div><div class="line"></div><div class="line"></div><div class="line">​```java</div><div class="line">public class WordDocument implements Cloneable&#123;</div><div class="line"></div><div class="line">    // 文本</div><div class="line">    public String mText;</div><div class="line"></div><div class="line">    // 图片名列表</div><div class="line">    public ArrayList&lt;String&gt; mImages = new ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">    public WordDocument()&#123;</div><div class="line">        System.out.println(&quot;-----------WordDocument构造函数-----------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected WordDocument clone() &#123;</div><div class="line">        try &#123;</div><div class="line">            // 通过本地方法特殊途径, 构建一个对象</div><div class="line">            WordDocument doc = (WordDocument) super.clone();</div><div class="line">            doc.mText = this.mText;</div><div class="line"></div><div class="line">            // 因为Image是引用类型, 这样直接赋值属于浅拷贝, 再次对集合进行clone. 实现wordDocument的深拷贝</div><div class="line">            doc.mImages = (ArrayList&lt;String&gt;) this.mImages.clone();</div><div class="line">            return doc;</div><div class="line">        &#125;catch (Exception ex)&#123;&#125;</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 打印文档内容</div><div class="line">     */</div><div class="line">    public void showDocument()&#123;</div><div class="line">        System.out.println(&quot;------------开始输出内容---------------------&quot;);</div><div class="line">        System.out.println(&quot;Text: &quot;+mText);</div><div class="line">        System.out.println(&quot;List: &quot;+mImages.toString());</div><div class="line">        System.out.println(&quot;------------输出结束------------------------&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与标准的原型模式相比<code>WordDocument</code>就是一个<strong>具体实现的原型</strong>对象. 而实现的<code>Cloneable</code>接口为<strong>抽象的原型对象</strong>.</p>
<p>其实<code>Cloneable</code>这个接口内部没有任何方法, 所以其本质就是<code>标识接口</code>,只是表明这个类的对象是<code>可拷贝的</code>, 而<code>clone()</code>这个方法是<code>Objec</code>类中的, 如果没有标识这个接口, 那么调用会抛出异常.</p>
<hr>
<p><strong>深拷贝浅拷贝</strong></p>
<p>例如上面的代码中进行修改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected WordDocument clone() &#123;</div><div class="line">   try &#123;</div><div class="line">       // 通过本地方法特殊途径, 构建一个对象</div><div class="line">       WordDocument doc = (WordDocument) super.clone();</div><div class="line">       doc.mText = this.mText;</div><div class="line"></div><div class="line">       // 这里进行修改 那么此时属于浅拷贝</div><div class="line">       doc.mImages = this.mImages;</div><div class="line">       return doc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能应该发现了什么, 其实本质不过就是通过<code>super.clone()</code>构建了一个本类对象的初始状态, 然后把被拷贝的对象的各个属性值进行<strong>赋值</strong>操作而已.</p>
<p>的确, 就是如此. 就如上面两处不同的代码,</p>
<ul>
<li><code>浅拷贝</code>: 也称<code>影子拷贝</code>, 拷贝出来的对象并不是完全一份独立的对象, 新的对象某些属性如<strong>引用传递</strong>可能会<code>引用</code>原始对象的对应属性值, 也就是说, 对浅拷贝的属性可能会影响到原始数据的属性.</li>
<li><code>深拷贝</code>: 拷贝出一份原始对象, 并对原始对象的属性值, 进行<strong>复制添加</strong>到新拷贝的对象的各个属性上. 这样拷贝出来的对象与原始对象不存在任何关联, 只作为一个数据的副本存在.</li>
</ul>
<p>上面因为<code>mImages</code>的类型是<code>ArrayList</code>如果直接进行赋值那么属于引用传递, 共享的一份数据源, 而如果在对<code>ArrayList</code>进行一次<code>clone</code>, 那么相当于又构建了一个集合并进行数据的复制.</p>
<p>而<code>mText</code>虽然是对象, 但是因为是<code>String</code>类型, 属于安全类型, 由于final类,实例不可更改的特性. 如果对副本进行字符串的修改, 只不过是把原引用删除,重新指向了新的字符串.</p>
<h4 id="Android源码对应实现"><a href="#Android源码对应实现" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>上面我们说了通过对集合再次调用<code>clone()</code>即可完成深拷贝. 那么看一下<code>ArrayList</code>源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</div><div class="line"></div><div class="line">    transient Object[] elementData; </div><div class="line">    private int size;</div><div class="line">    </div><div class="line">    public Object clone() &#123;</div><div class="line">        try &#123;</div><div class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</div><div class="line">            v.elementData = Arrays.copyOf(elementData, size);</div><div class="line">            v.modCount = 0;</div><div class="line">            return v;</div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">            throw new InternalError(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>ArrayList</code>的内部克隆实现很简单, 我们都知道<code>ArrayList</code>内部是通过数组的数据结构来实现的. 通过<code>Arrays</code>工具类对原始集合的数据进行赋值并添加到一个新的数组并返回, 而返回的数组挂到了克隆出来对象上的<code>elementData</code>变量上.</p>
<p>而集合的大小<code>size</code>没有被进行赋值? 因为其类型是整型, 属于<strong>值传递</strong>, 在clone之后原始值通过值传递到了新对象中, 即使修改也不会对原始对象有任何的影响.</p>
<hr>
<p>那么<code>Android</code>源码中的实现是什么?</p>
<p><code>Intent</code>, 我们看如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(&quot;某一个activity的action&quot;);</div><div class="line">intent.putExtra(&quot;result&quot;, &quot;Successful&quot;);</div><div class="line"></div><div class="line">// 调用克隆方法</div><div class="line">Intent clone = (Intent) intent.clone();</div><div class="line">startActivity(clone);</div></pre></td></tr></table></figure>
<p>这样同样没问题, 一样的效果. 那么看一下<code>Intent#clone()</code>内部是如何实现的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object clone() &#123;</div><div class="line">   return new Intent(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* Copy constructor.</div><div class="line">*/</div><div class="line">public Intent(Intent o) &#123;</div><div class="line">   this.mAction = o.mAction;</div><div class="line">   this.mData = o.mData;</div><div class="line">   this.mType = o.mType;</div><div class="line">   this.mPackage = o.mPackage;</div><div class="line">   this.mComponent = o.mComponent;</div><div class="line">   this.mFlags = o.mFlags;</div><div class="line">   this.mContentUserHint = o.mContentUserHint;</div><div class="line">   if (o.mCategories != null) &#123;</div><div class="line">       this.mCategories = new ArraySet&lt;String&gt;(o.mCategories);</div><div class="line">   &#125;</div><div class="line">   if (o.mExtras != null) &#123;</div><div class="line">       this.mExtras = new Bundle(o.mExtras);</div><div class="line">   &#125;</div><div class="line">   if (o.mSourceBounds != null) &#123;</div><div class="line">       this.mSourceBounds = new Rect(o.mSourceBounds);</div><div class="line">   &#125;</div><div class="line">   if (o.mSelector != null) &#123;</div><div class="line">       this.mSelector = new Intent(o.mSelector);</div><div class="line">   &#125;</div><div class="line">   if (o.mClipData != null) &#123;</div><div class="line">       this.mClipData = new ClipData(o.mClipData);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单不需要解释了, 手动<code>new</code>的并进行数据复制. 相当于封装了一下复制的细节而已.</p>
<p>但是为什么没有调用<code>super.clone()</code>来实现拷贝呢? 之前说过使用<code>clone</code>还是<code>new</code>关键字是需要根据构造对象的成本来决定的, 如果对象的构造成本比较复杂或者麻烦, 那么<code>clone</code>则是一种更优的选择, 否则就可以使用<code>new</code>的形式. 这和<code>c++</code>拷贝构造函数是一样的.</p>
<h4 id="实战场景"><a href="#实战场景" class="headerlink" title="实战场景"></a>实战场景</h4><p>当登录模块登录成功之后, 会把一些个人信息,token等信息在保存类中的某个数据结构上, 并通过一个方法对外暴露出去, 提供其他模块使用. 但是如果你返回的是一个数据结构也就是一个对象, 这个对象包含了很多个人信息, 但是正常来说, 对于外部应该只提供查看数据的能力, 不应该提供修改的能力.</p>
<p>所以这个使用, 就可以对登录模块对外暴露的方法进行修改, 利用<code>原型模式</code>对外返回的是一个内部数据的<code>深拷贝</code>, 这样就把可能出现的隐患彻底的隔绝了.</p>
<p><strong>说明</strong></p>
<p><code>原型模式</code>是通过内存中二进制流的方式拷贝, 要比直接通过<code>new</code>一个对象性能更好, 特别是循环体内产生大量对象是. 但是注意, 因为是<code>二进制流的拷贝</code>, 所以构造函数是不会执行的. 这点要明确记牢.</p>
<h3 id="工厂方法模式-Factory"><a href="#工厂方法模式-Factory" class="headerlink" title="工厂方法模式 Factory"></a>工厂方法模式 Factory</h3><h4 id="模式介绍-2"><a href="#模式介绍-2" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>创建型设计模式, 其实这个模式可能在开发中出现很多回了, 只是并不了解什么是工厂模式的概念.</p>
</blockquote>
<ul>
<li><code>定义</code>: 定义一个用于创建的对象的接口, 让子类决定实例化哪个类</li>
<li><code>场景</code>: 在任何需要生成复杂对象的地方, 都可以使用工厂方法模式. 复杂对象适合使用工厂模式, 用<code>new</code>就可以完成创建的对象无需使用工厂模式.</li>
</ul>
<p>工厂方法模式完全符合设计模式原则, 降低了对象之间的耦合度, 而且, 工厂方法模式依赖于抽象的架构, 将实例化的任务交由了子类实现.</p>
<h4 id="模式范例-2"><a href="#模式范例-2" class="headerlink" title="模式范例"></a>模式范例</h4><p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/factory" target="_blank" rel="external">实现代码</a></p>
<p>这是范例的UML类图.</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Factory.png" alt="img"></p>
<p>其实这里, 可以去掉抽象的工厂类, 只需要一个工厂即可. 这样会更加简洁直观.</p>
<h4 id="Android源码对应实现-1"><a href="#Android源码对应实现-1" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>List</code>和<code>Set</code>不陌生, 都继承<code>Collection</code>接口, 而<code>Collection</code>接口继承<code>Iterable</code>接口, 而这个接口很简单就一个<code>iterator()</code>方法, 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</div><div class="line">    // ....</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Iterable&lt;T&gt; &#123;</div><div class="line">    Iterator&lt;T&gt; iterator();</div><div class="line">    </div><div class="line">    // 可能JDK1.8之后添加两个默认方法, 这里我们不需要关心</div><div class="line">&#125;</div><div class="line">​``` </div><div class="line"></div><div class="line">关于`List`和`Set`迭代器的方法遍历元素应该都用过. 那么看一下源码实现.</div><div class="line"></div><div class="line"></div><div class="line">​```java</div><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess &#123;</div><div class="line"></div><div class="line">@Override public Iterator&lt;E&gt; iterator() &#123;</div><div class="line">        return new ArrayListIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class ArrayListIterator implements Iterator&lt;E&gt; &#123;</div><div class="line">        private int remaining = size;</div><div class="line">        </div><div class="line">        private int removalIndex = -1;</div><div class="line"></div><div class="line">        private int expectedModCount = modCount;</div><div class="line"></div><div class="line">        public boolean hasNext() &#123;</div><div class="line">            return remaining != 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123;</div><div class="line">            ArrayList&lt;E&gt; ourList = ArrayList.this;</div><div class="line">            // 返回集合大小元素, 还有几个未遍历</div><div class="line">            int rem = remaining;</div><div class="line">            if (ourList.modCount != expectedModCount) &#123;</div><div class="line">                throw new ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">            if (rem == 0) &#123;</div><div class="line">                throw new NoSuchElementException();</div><div class="line">            &#125;</div><div class="line">            remaining = rem - 1;</div><div class="line">            return (E) ourList.array[removalIndex = ourList.size - rem];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void remove() &#123;</div><div class="line">            Object[] a = array;</div><div class="line">            int removalIdx = removalIndex;</div><div class="line">            if (modCount != expectedModCount) &#123;</div><div class="line">                throw new ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">            if (removalIdx &lt; 0) &#123;</div><div class="line">                throw new IllegalStateException();</div><div class="line">            &#125;</div><div class="line">            System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining);</div><div class="line">            a[--size] = null;  // Prevent memory leak</div><div class="line">            removalIndex = -1;</div><div class="line">            expectedModCount = ++modCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// hashSet 复写逻辑</div><div class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable,Serializable &#123;</div><div class="line">    public Iterator&lt;E&gt; iterator() &#123;</div><div class="line">        return backingMap.keySet().iterator();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// HashMap 复写逻辑</div><div class="line">public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable, Serializable &#123;</div><div class="line">    Iterator&lt;K&gt; newKeyIterator() &#123; return new KeyIterator();   &#125;</div><div class="line">    </div><div class="line">    private final class KeyIterator extends HashIterator</div><div class="line">            implements Iterator&lt;K&gt; &#123;</div><div class="line">        public K next() &#123; return nextEntry().key; &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>HashSet</code>的<code>iterator</code>方法会返回成员变量<code>backingMap</code>中对应<code>HashSet</code>对象元素的迭代器对象, 最终返回的是<code>KeySet</code>中的一个迭代器对象</li>
<li><code>ArrayList</code>和<code>HashMap</code>中的<code>iterator()</code>就相当一个工厂方法, <strong>专为new对象而生</strong>!</li>
</ul>
<hr>
<p>而<code>Android</code>中, 看一下如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(new FrameLayout(this));   </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>onCreate()</code>这个方法, 我们可以构建出任何样式的根布局, 如<code>LinearLayout</code>,<code>TextView</code>等等. 我们在不同的<code>Activity#onCreate()</code>方法将设置的布局通过<code>setContentView()</code>函数传递给<code>frameworks</code>并显示出来. 这不就是一个工厂模式的结构. 方法内部可以创建不同的对象, 产生不同的实例.</p>
<h4 id="实战场景-1"><a href="#实战场景-1" class="headerlink" title="实战场景"></a>实战场景</h4><p>例如对数据的持久化, 可以通过的途径有<code>SP</code>,<code>File</code>,<code>SQLite</code>等. 但是对数据的操作无非就是<code>增删改查</code>, 那么我们可以抽象一个抽象类并定义CURD抽象方法. <code>SP</code>, <code>File</code>,<code>SQLite</code>分别继承抽象类, 并在抽象方法实现自己的处理逻辑. 然后就可以创建一个<code>工厂类</code>, 工厂类有一个方法, <strong>形参为产品实现类的字节码</strong>, 返回一个<strong>泛型上限限定是产品的抽象类</strong>对象, 方法内部通过字节码反射具体的产品类实例.</p>
<p>这样在使用的使用, 我们只需有通过<code>工厂方法</code>传入的不同<code>产品Class</code>就可以构建不同的实例, 而数据的CRUD通过<strong>依赖倒置</strong>抽象特性, 高层不需要依赖底层的类.</p>
<h3 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 Abstract Factory"></a>抽象工厂模式 Abstract Factory</h3><h4 id="模式介绍-3"><a href="#模式介绍-3" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>创建型设计模式, 之前工厂模式会生产某一个产品, 但是如果说, 不同的操作系统图形的场景下的两个产品<strong>按钮</strong>和<strong>文本框</strong>. 对于每一个操作系统, 其本身就构成了一个单独的产品. 两种产品两种变化, 这种情况就较之前的普通工厂升级了复杂度, 如: <code>Android</code>中的<code>Button</code>和<code>TextView</code>, <code>iOS</code>中的<code>Button</code>和<code>TextView</code>或者<code>WindowPhone</code>场景…</p>
</blockquote>
<ul>
<li><code>定义</code>: 为创建一组相关或者是相互依赖的的对象提供一个接口, 而不需要指定他们的具体类</li>
<li><code>场景</code>: 一个对象族有相同的约束时可以使用<strong>抽象工厂</strong>, 如<code>android</code>和<code>iOS</code>都有打电话软件和短信软件, 两者都属于<code>软件的范畴</code>, 但是他们的操作平台不同, 实现逻辑也不会相同. 这个时候就可以使用<code>抽象工厂方法模式</code></li>
</ul>
<h4 id="模式范例-3"><a href="#模式范例-3" class="headerlink" title="模式范例"></a>模式范例</h4><p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/absfactory" target="_blank" rel="external">实现代码</a></p>
<p>范例UML图</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_AbsFactory.png" alt="img"></p>
<p>看一下运行结果:</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/test_absFactory.png" alt="img"></p>
<p>如果这是时候, 如果想创建一种使用<code>普通轮胎</code>, <code>新款发动机</code>的车型. 只需要继承抽象工厂, 并使用原有的普通轮胎类, 并继承<code>IEngfine</code>实现一款新的发动机类. 即可完成扩展. 这就是通过接口扩展.</p>
<p>上面的范例, 对于每一个造车的工厂, 内部使用的零件不管哪个车场都是具有抽象的轮胎和发送机类. 这样可以达到一种自由组合的状态.</p>
<p>但是弊端也显示出来了, 不仅需要扩展新的<code>工厂类</code>还要扩展<code>新的组件类</code>.</p>
<h4 id="Android源码对应实现-2"><a href="#Android源码对应实现-2" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>抽象工厂在<code>Android</code>实现较少, 上一节说<code>onCreate()</code>方法就相当于一个工厂方法. 那么对于另外一个组件<code>Service#onBind()</code>同样也可以看做一个工厂方法.</p>
<p>如果从<code>frameworks</code>层的角度来看<code>Activity</code>和<code>Service</code>可以看做一个具体的工厂, 这样来看相当于一个抽象方法模式的雏形也没错.</p>
<p>另一个更像的例子是<code>Android</code>底层对<code>MediaPlayer</code>使用. 这里书上噼里啪啦一堆C语言. 我就不抄了….</p>
<h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h3><h4 id="模式介绍-4"><a href="#模式介绍-4" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>开发中可能有这样的情况: 实现某一个功能可以有多中算法或者策略, 我们根据不同的功能来选择不同的算法. 针对这种情况, 1.可以在一个类中封装多个方法, 每个方法实现不同算法. 2.通过<code>if..else if..else..</code>条件判断来决定使用哪种算法. 但是这两种都是<code>硬编码</code>实现. 并且随着算法的增多类也就变得臃肿, 维护的成本随之变高. 如果需要增加一种新的算法, 必然需要对算法类进行修改. 这就违反了<code>OCP</code>原则和<code>单一职责</code>的原则.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 策略模式定义了一系列的算法, 并将每一个算法封装起来, 而且使它们还可以相互替换. 策略模式让算法独立于使用它的客户而独立变化.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li><p>针对同一类型问题的多种处理方式, 仅仅是具体行为有差别时</p>
</li>
<li><p>需要安全地封装多种同一类型的操作时</p>
</li>
<li><p>出现同一抽象类有多个子类, 而又不需要使用<code>if-else</code>或者<code>switch</code>等来选择具体子类.</p>
</li>
<li><h4 id="模式范例-4"><a href="#模式范例-4" class="headerlink" title="模式范例"></a>模式范例</h4></li>
</ul>
</li>
</ul>
<p>最方便的记忆法就是记住, <code>策略模式</code>可以去掉<code>if-else</code>或者<code>switch</code>. 语句, 即使后续会扩展通过接口来进行扩展, 不会对源代码进行修改. 满足了<code>OCP开闭原则</code>.</p>
<p>看一下范例代码: –&gt; 对于交通费用的计算, 计算的算法可能会有公交, 地铁等…</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/strategy" target="_blank" rel="external">代码地址</a></p>
<p>范例类图:</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Strategy.png" alt="img"></p>
<p>在看一下代码的使用以及结果–&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void main (String arg[])&#123;</div><div class="line">   // 创建操作策略的环境类</div><div class="line">   TranficCalculator calculator = new TranficCalculator();</div><div class="line">   // 设置公交车的策略, 并准备计算</div><div class="line">   calculator.setStrategy(new BusStrategy());</div><div class="line">   System.out.println(&quot;公交车--&gt;计算9公里价格: &quot;+calculator.calculatePrice(9));</div><div class="line"></div><div class="line">   // 设置地铁的策略, 并准备计算</div><div class="line">   calculator.setStrategy(new SubwayStrategy());</div><div class="line">   System.out.println(&quot;地铁--&gt;计算9公里价格: &quot;+calculator.calculatePrice(9));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果--&gt;</div><div class="line">公交车--&gt;计算9公里价格: 1</div><div class="line">地铁--&gt;计算9公里价格: 4</div></pre></td></tr></table></figure>
<p>你应该可以发现, 这种方式在隐藏实现的同时, <strong>可扩展性</strong>变得很强, 如果此时需要增加一个出租车的计算策略, 那么只需要添加一个实现了<code>计算策略接口</code>即可. 对原始代码的修改进行了<code>关闭</code>, 并对扩展<code>开放</code>.</p>
<h4 id="Android源码对应实现-3"><a href="#Android源码对应实现-3" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>动画里面的<code>插值器Interpolator</code>利用了策略模式, 利用<code>Interpolator</code>策略的抽象, <code>LinearInterpolator</code>,<code>CycleInterpolator</code>等插值器为具体的实现策略, 通过注入不同的插值器实现不同的动态效果.</p>
<p>看一下大概的类图</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Animation.png" alt="img"></p>
<ul>
<li><p>动画中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TimeInterpolator</div></pre></td></tr></table></figure>
<p>时间插值器, 它的作用是根据时间流逝的百分比计算出当前属性值改变的百分比, 内置的插值器有如下几种</p>
<ul>
<li><code>线性插值器(LinearInterpolator)</code>用于匀速动画</li>
<li><code>加速减速插值器(AccelerateDecelerateInterpolator)</code>:起始时动画加速, 结尾时动画减速</li>
<li><code>减速插值器(DecelerateInterpolator)</code>: 用于随着时间的推移动画越来越慢.</li>
</ul>
</li>
<li><p>动画中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypeEvalutor</div></pre></td></tr></table></figure>
<p>类型估值器: 根据当前属性改变的百分比来计算改变后的属性值. 内置的类型估值器有如下几种</p>
<ul>
<li><code>整型估值器(IntEvalutor)</code></li>
<li><code>浮点型估值器(FloatEvalutor)</code></li>
<li><code>Color估值器(ArgbEvalutor)</code></li>
</ul>
</li>
</ul>
<p>接下来就开始回忆一下从一个动画开始后, 代码究竟做了什么?</p>
<p>对于源码的起始点入口就是调用<code>View的startAnimation()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void startAnimation(Animation animation) &#123;</div><div class="line">    // 1.初始化动画的开始时间</div><div class="line">   animation.setStartTime(Animation.START_ON_FIRST_FRAME);</div><div class="line">   // 2.对View设置动画</div><div class="line">   setAnimation(animation);</div><div class="line">   // 3.刷新父类缓存</div><div class="line">   invalidateParentCaches();</div><div class="line">   // 4.刷新View本身及子View</div><div class="line">   invalidate(true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先设置了动画的起始时间, 然后将该动画设置到<code>View</code>中, 最后再向<code>ViewGroup</code>请求刷新视图, 随后<code>ViewGroup</code>会调用<code>dispatchDraw()</code>方法对这个<code>View</code>所在的区域进行重绘. 其实对于某一个<code>View</code>的重绘最终是调用其<code>ViewGroup</code>的<code>drawChild(...)</code>方法. 跟入一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;</div><div class="line">   // 简单的转发</div><div class="line">   return child.draw(canvas, this, drawingTime);</div><div class="line">&#125;</div><div class="line"></div><div class="line">boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123;</div><div class="line">    // ....</div><div class="line">    // 查看是否需要清除动画信息</div><div class="line">    final int flags = parent.mGroupFlags;</div><div class="line">    // 省略无关代码</div><div class="line">    </div><div class="line">    // 获取设置的动画信息</div><div class="line">    final Animation a = getAnimation();</div><div class="line">        </div><div class="line">    if (a != null) &#123;</div><div class="line">            // 绘制动画</div><div class="line">           more = drawAnimation(parent, drawingTime, a, scalingRequired);</div><div class="line">           //...</div><div class="line">       &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>父类会调用子类的<code>draw</code>方法, 其中会先判断是否设置了清除动画的标记, 然后再获取该<code>View</code>动画信息, 如果设置了动画, 就会调用<code>View#drawAnimation()</code>方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private boolean drawAnimation(ViewGroup parent, long drawingTime,</div><div class="line">       Animation a, boolean scalingRequired) &#123;</div><div class="line">   Transformation invalidationTransform;</div><div class="line">   final int flags = parent.mGroupFlags;</div><div class="line">   final boolean initialized = a.isInitialized();</div><div class="line">   // 1. 判断动画是否已经初始化过</div><div class="line">   if (!initialized) &#123;</div><div class="line">       a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</div><div class="line">       a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop);</div><div class="line">       if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler);</div><div class="line">       // 如果设置了动画的监听, 则触发对应的回调</div><div class="line">       onAnimationStart();</div><div class="line">   &#125;</div><div class="line">   // 获取Transformation对象, 存储动画的信息</div><div class="line">   final Transformation t = parent.getChildTransformation();</div><div class="line">   // 2. 调用Animation#getTransformation, 通过计算获取动画的相关值</div><div class="line">   boolean more = a.getTransformation(drawingTime, t, 1f);</div><div class="line">    </div><div class="line"></div><div class="line">   if (more) &#123;</div><div class="line">        // 3. 根据具体实现, 判断当前动画类型是否需要进行调整位置大小, 然后刷新不同的区域</div><div class="line">       if (!a.willChangeBounds()) &#123;</div><div class="line">           // ...</div><div class="line">       &#125; else &#123;</div><div class="line">           // 获取重绘区域</div><div class="line">           a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region,</div><div class="line">                   invalidationTransform);</div><div class="line">           parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class="line"></div><div class="line">            // 更新计算有效区域</div><div class="line">           final int left = mLeft + (int) region.left;</div><div class="line">           final int top = mTop + (int) region.top;</div><div class="line">           </div><div class="line">           // 进行区域更新</div><div class="line">           parent.invalidate(left, top, left + (int) (region.width() + .5f),</div><div class="line">                   top + (int) (region.height() + .5f));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return more;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>drawAnimation</code>中主要操作是动画的初始化, 动画操作, 界面刷新. 动画的回调监听<code>onStart()</code>会在动画进行初始化的时候调用, 动画的具体实现是通过<code>Animation#getTransformation()</code>方法.这个方法主要获取了<code>缩放系数</code>和调用<code>Animation.getTransformation(long, Transformation)</code>来计算和应用动画效果.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public boolean getTransformation(long currentTime, Transformation outTransformation) &#123;</div><div class="line">   //...</div><div class="line">   float normalizedTime;</div><div class="line">   // 1.计算当前时间的流逝百分比</div><div class="line">   if (duration != 0) &#123;</div><div class="line">       normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) /</div><div class="line">               (float) duration;</div><div class="line">   &#125; else &#123;</div><div class="line">       // time is a step-change with a zero duration</div><div class="line">       normalizedTime = currentTime &lt; mStartTime ? 0.0f : 1.0f;</div><div class="line">   &#125;</div><div class="line">   // 动画是否完成标记</div><div class="line">   final boolean expired = normalizedTime &gt;= 1.0f;</div><div class="line">   mMore = !expired;</div><div class="line"></div><div class="line">   if ((normalizedTime &gt;= 0.0f || mFillBefore) &amp;&amp; (normalizedTime &lt;= 1.0f || mFillAfter)) &#123;</div><div class="line">        // 2.通过插值器获取动画执行百分比  , 这里获取的方法就是通过策略模式</div><div class="line">       final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</div><div class="line">       // 3.应用动画效果</div><div class="line">       applyTransformation(interpolatedTime, outTransformation);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // 4. 如果动画执行完毕, 那么触发动画完成的回调或者执行重复动画等操作</div><div class="line">   // ...</div><div class="line">   if (!mMore &amp;&amp; mOneMoreTime) &#123;</div><div class="line">       mOneMoreTime = false;</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">   return mMore;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码, 先计算已经流逝的的时间百分比, 然后再通过<code>具体的插值器</code>重新计算这个百分比, 也就是上面的第二步. 而具体是哪一个插值器是通过之前说的策略模式来实现的.</p>
<p>第3步调用了<code>applyTransformation</code>, 这个方法在基类<code>Animation</code>中是空实现, 可以在子类查看实现如<code>ScaleAnimation</code>,<code>AlphaAnimation</code>等查看. 当这个方法内部主要通过<code>矩阵</code>来实现动画. 当这个方法执行完毕之后, View的属性也就发生了变化, 不断地重复这个过程, 动画就随之产生.</p>
<h4 id="实战场景-2"><a href="#实战场景-2" class="headerlink" title="实战场景"></a>实战场景</h4><p>当我们自己组装了一个队列请求, 对于这个队列的处理方式默认可能是<code>先处理进入队列的</code>, 但是如果想实现一个可以<code>先处理后入队的</code>, 和<code>随机读取队列元素</code>. 那么为了以后的扩展不影响源代码, 那么可以通过<code>策略模式</code>在代码中通过对<code>策略抽象</code>面向接口,抽象编程. 是具体的实现有后续的传入的子类来决定.</p>
<h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h3><h4 id="模式介绍-5"><a href="#模式介绍-5" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>状态模式中的行为是由状态来决定的, 不同的状态有不同的行为, 状态模式和策略模式的结构几乎一模一样, 但他们的目的, 本质却完全不一样. 状态模式的行为是平行的不可替换的. 策略模式的行为是彼此独立, 可相互替换的. 总结一句话表述: 状态模式是把对象的行为包装在不同的状态对象里, 每一个状态对象都有一个共同的抽象状态基类, 状态模式的意图是让一个对象在其内部状态改变的时候, 其行为也随之改变</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 当一个对象的内在状态改变时允许改变其行为, 这个对象看起来像是改变了其类.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ol>
<li>一个代码的行为取决于它的装填, 并且必须在运行时根据其状态改变它的行为</li>
<li>代码中包含大量与对象状态有关的条件语句, 同样可以去除分支语句的效果</li>
</ol>
</li>
</ul>
<h4 id="模式范例-5"><a href="#模式范例-5" class="headerlink" title="模式范例"></a>模式范例</h4><p>例如电视开关机状态下的<strong>频道切换</strong>或者<strong>音量调节</strong>, 不同的状态下的各种功能行为是不同的. <code>关机</code>: 功能音量频道切换是无效的, <code>开机</code>: 却可以实现. 实现这样一个关系, 如果最简单暴力的方法就是一个类实现, 里面充斥了各种条件判断来实现不同场景的功能.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/state" target="_blank" rel="external">范例代码实现</a></p>
<p>范例类图:</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_State.png" alt="img"></p>
<p>客户端的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static void main(String arg[])&#123;</div><div class="line">        TvController tvController = new TvController();</div><div class="line"></div><div class="line">        // 开机</div><div class="line">        tvController.powerOn();</div><div class="line"></div><div class="line">        // 下一个频道</div><div class="line">        tvController.nextChannel();</div><div class="line"></div><div class="line">        // 调高音量</div><div class="line">        tvController.turnUp();</div><div class="line"></div><div class="line">        // 关机</div><div class="line">        tvController.powerOff();</div><div class="line"></div><div class="line">        // 关机状态下调低音量</div><div class="line">        tvController.turnDown();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/** 输出结果--&gt;</div><div class="line"> *  开机了--</div><div class="line"> *  下一个频道</div><div class="line"> *  调高音量</div><div class="line"> *  关机了--</div><div class="line">**/</div></pre></td></tr></table></figure>
<p>其实有多重行为, 但代码中却不存在了<code>条件分支语句</code></p>
<h4 id="Android源码对相应实现"><a href="#Android源码对相应实现" class="headerlink" title="Android源码对相应实现"></a>Android源码对相应实现</h4><p><code>WiFi</code>管理 其中的实现就使用了<code>状态模式</code></p>
<p>在<code>WiFi</code>复杂的调用中, 存在一个<code>State</code>的状态类, 它代表了<code>WiFi</code>的某个状态, 定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class State implements IState &#123;</div><div class="line">    // 进入当前状态之后调用该函数</div><div class="line">    @Override</div><div class="line">    public void enter() &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 退出该状态后改用该函数</div><div class="line">    @Override</div><div class="line">    public void exit() &#123;</div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    // 处理消息</div><div class="line">    @Override</div><div class="line">    public boolean processMessage(Message msg) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>状态之间并不是可以随意切换的, 他们有一种层级关系, 这些层级关系<code>StateMachine</code>的构造函数中被定义的, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// WiFiStateMachine</div><div class="line">public WifiStateMachine(Context context, String wlanInterface,</div><div class="line">            WifiTrafficPoller trafficPoller)&#123;</div><div class="line">        super(&quot;WifiStateMachine&quot;);</div><div class="line">        </div><div class="line">        addState(mDefaultState);</div><div class="line">        addState(mInitialState, mDefaultState);</div><div class="line">        addState(mSupplicantStartingState, mDefaultState);</div><div class="line">        addState(mSupplicantStartedState, mDefaultState);</div><div class="line">        addState(mDriverStartingState, mSupplicantStartedState);</div><div class="line">        addState(mDriverStartedState, mSupplicantStartedState);</div><div class="line">        addState(mScanModeState, mDriverStartedState);</div><div class="line">        addState(mConnectModeState, mDriverStartedState);</div><div class="line">        addState(mL2ConnectedState, mConnectModeState);</div><div class="line">        addState(mObtainingIpState, mL2ConnectedState);</div><div class="line">        addState(mVerifyingLinkState, mL2ConnectedState);</div><div class="line">        addState(mConnectedState, mL2ConnectedState);</div><div class="line">        addState(mRoamingState, mL2ConnectedState);</div><div class="line">        addState(mDisconnectingState, mConnectModeState);</div><div class="line">        addState(mDisconnectedState, mConnectModeState);</div><div class="line">        addState(mWpsRunningState, mConnectModeState);</div><div class="line">        addState(mWaitForP2pDisableState, mSupplicantStartedState);</div><div class="line">        addState(mDriverStoppingState, mSupplicantStartedState);</div><div class="line">        addState(mDriverStoppedState, mSupplicantStartedState);</div><div class="line">        addState(mSupplicantStoppingState, mDefaultState);</div><div class="line">        addState(mSoftApStartingState, mDefaultState);</div><div class="line">        addState(mSoftApStartedState, mDefaultState);</div><div class="line">        addState(mTetheringState, mSoftApStartedState);</div><div class="line">        addState(mTetheredState, mSoftApStartedState);</div><div class="line">        addState(mUntetheringState, mSoftApStartedState);</div><div class="line">        // 初始化模式为mInitialState</div><div class="line">        setInitialState(mInitialState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构造函数中调用了<code>addState()</code>函数, 这些函数最终会调用<code>SmHandler#addState()</code>函数. 这个函数就是在状态之间建立一个层级关系, 这是一个树形的层级关系. 状态之间并不是跨越式的转换, 当前状态只能转换到上一个状态或者下一个状态.</p>
<p>上面说的比较抽象, 列举书中的例子. 一个电梯的状态有<code>停止</code>, <code>运行</code>, <code>开门</code>, <code>关门</code>. 在运行状态只能到停止状态. 不会直接开门状态,这会出人命的, 关门状态也是不合乎常理的. 所以就如下关系图片:</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/elevator_sequence.png" alt="img"></p>
<p>正如上图, 不同状态对于不同的指令的反应是完全不一样的, <code>WiFi</code>工作状态机制也是同理, 除了对状态之间的转换进行控制之外, 还通过状态模式来对不同的命令进行不同的处理. <code>State</code>类就是状态的基类, 它与<code>Wifi</code>相关的子类都定义在<code>WifiStateMachine</code>中.</p>
<p><code>State</code>的类有<code>enter</code>,<code>exit</code>,<code>processMessage</code>三个函数, 进入状态之后会调用<code>enter()</code>, 退出时调用<code>exit()</code>, 处理具体消息时调用<code>processMessage()</code>. 而<code>状态模式的核心就是当一个对象的内在状态改变时允许改变其行为</code>, 所以我们关注<code>processMessage()</code>不同的状态下就是依赖这个函数实现不同行为的.</p>
<p>例如: 在请求扫描Wifi时, 如果在<code>初始化状态(InitialState)</code>下, 说明Wifi驱动还没有进行加载和启动, 扫描的请求会被会被忽略. 而在<code>驱动加载状态下</code>, 请求会被添加到延迟处理的消息队列中, 等待驱动加载完毕进行扫描请求.</p>
<p>总结起来: 就是将请求的处理封装到状态类中, 在不同的状态类中对同一个请求进行不同的处理. 它能够消除一些重复的<code>if-else</code>逻辑, 使得程序的结构更加清晰, 可扩展性和稳定性也有了一定的提高</p>
<h4 id="实战场景-3"><a href="#实战场景-3" class="headerlink" title="实战场景"></a>实战场景</h4><p>例如新浪微博首页, 任何状态下可以看微博, 当点击转发后, 如果是<code>登录状态</code>那么就可以直接调转转发页面, 如果是<code>未登录状态</code>那么需要调转到登录界面. 这就可以使用状态模式进行逻辑的分离.</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="模式介绍-6"><a href="#模式介绍-6" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>行为型设计模式, 将每一个对象看做一个节点, 并把所有节点串成一条链式, 从链头开始传递事件, 如果无法处理交给节点的下一个节点位置上, 直到有节点处理了这个事件.</p>
</blockquote>
<ul>
<li><code>定义</code>: 使多个对象都有机会处理请求, 从而避免了请求的发送者和接收者之间的耦合关系. 将这些对象连成一条链, 并沿着这条链传递该请求, 直到对象处理它为止</li>
<li><code>场景</code>: 多个对象都可以处理一个请求时, 但具体由哪个对象处理是在运行时决定.</li>
</ul>
<h4 id="模式范例-6"><a href="#模式范例-6" class="headerlink" title="模式范例"></a>模式范例</h4><p>出差是需要经费的, 那么肯定需要找领导签字才会批下钱, 但是如果经费较多, 你的上一级可能无权签字,这个时候上一级领导就会把这个审批带向他的上级提交.. 直到有可以批准的为止. 从始至终出差人只需要知道自己的上一级即可. 不需要知道其他的审批人.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/iterator" target="_blank" rel="external">范例代码</a></p>
<p>范例类图</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Iterator.png" alt="img"></p>
<p>看一下客户端的调用–&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[])&#123;</div><div class="line"></div><div class="line">        // 构造3个处理者对象</div><div class="line">        Handler1 handler1 = new Handler1();</div><div class="line">        Handler2 handler2 = new Handler2();</div><div class="line">        Handler3 handler3 = new Handler3();</div><div class="line"></div><div class="line">        // 构造3个请求者对象</div><div class="line">        Request1 re1 = new Request1(&quot;请求1&quot;);</div><div class="line">        Request2 re2 = new Request2(&quot;请求2&quot;);</div><div class="line">        Request3 re3 = new Request3(&quot;请求3&quot;);</div><div class="line"></div><div class="line">        // 设置当前处理者对象下一个节点的处理者对象</div><div class="line">        handler1.nextHandler = handler2;</div><div class="line">        handler2.nextHandler = handler3;</div><div class="line"></div><div class="line">        // 准备开始请求</div><div class="line">        // 总是从链式的首端发起请求</div><div class="line">        handler1.handleRequest(re1);</div><div class="line">        handler1.handleRequest(re2);</div><div class="line">        handler1.handleRequest(re3);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 执行结果===================&gt; </div><div class="line">处理者 1 处理请求, 请求的等级为: 1</div><div class="line">处理者 2 处理请求, 请求的等级为: 2</div><div class="line">处理者 3 处理请求, 请求的等级为: 3</div></pre></td></tr></table></figure>
<p>对于每个处理者其内部的逻辑是完全灵活的, 比如可以进行跳级传递等…</p>
<h4 id="Android源码对应实现-4"><a href="#Android源码对应实现-4" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>责任链模式在<code>Android</code>中比较类似的就是事件的分发处理, 每当用户接触屏幕时, <code>Android</code>就会将对应的事件包装成一个事件对象从<code>ViewTree</code>的顶部之上而下地分发传递.</p>
<p><code>ViewGroup</code>事件投递的递归调用就类似一条责任链, 一旦其寻到责任者, 那么就由责任者持有并消费掉该次事件 具体的体现在<code>View#onTouchEvent()</code>方法返回值的设置, 如果返回false, 那么就意味着当前<code>View</code>不会是该次事件的责任人, 将不会对其持有, 如果返回<code>true</code>, 则相反, 此时<code>View</code>会持有该事件并不在向外传递.</p>
<h3 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h3><h4 id="模式介绍-7"><a href="#模式介绍-7" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>这是较少使用的行为型模式, 其提供了一种解释语言的语法或表达式的方式, 该模式定义了一个表达式接口, 通过该接口解释一个特定的上下文.</p>
</blockquote>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">定义</div></pre></td></tr></table></figure>
<p>: 给定一个语言, 定义它的文法的一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中的句子.</p>
<ul>
<li>文法? 如<code>他很高</code>,<code>他很胖</code>,<code>他很瘦</code>. 这三个语句可以看做一个<code>他很[形容词]</code>这样的结构, 可以看做是一条文法</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ol>
<li>如果某个简单的语言需要解释执行而且可以将该语言中的语句表示为一个抽象语法树时可以考虑使用解释器模式</li>
<li>在某些特定的领域出现不断重复的问题时, 可以将该领域的问题转化为一种语法规则下的语句, 然后构建解释器来解释该语句.</li>
</ol>
</li>
</ul>
<h4 id="模式范例-7"><a href="#模式范例-7" class="headerlink" title="模式范例"></a>模式范例</h4><p>不好理解看看是通过代码形式的表示是否可以清楚一些?</p>
<p>比如一个场景是算术表达式的解释, 如<code>m + n + p</code>, 如果使用解释器模式对该表达式进行解释, 那么代表数字的<code>mnp</code>3个字母我们可以看成是<code>终结符号</code>, 而<code>+</code>这个算术运算符则可以当做非终结符号.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/interpreter" target="_blank" rel="external">代码范例</a></p>
<p>如最终调用方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(String arg[])&#123;</div><div class="line">   Calculator calculator = new Calculator(&quot;12 + 11 + 13 + 14&quot;);</div><div class="line">   System.out.println(calculator.calculate());</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果如下:</div><div class="line">50</div></pre></td></tr></table></figure>
<p>这个例子只是先了对加减法的解释计算, 如果要实现更多的运算规则, 乘除取余, 只需要创建对应解释器即可, 但是混合运算的复杂是要考虑各种符号的优先级的问题,这个就比较麻烦.</p>
<p>将一个具体的文法通过一个解释器解释, 把复杂的文法规则分离为简单的功能进行解释, 最后将其组合成一颗抽象的语法树解释执行, 至此, 可以看到解释器模式的原理和本质: 将复杂的问题简单化, 模块化, 分离实现, 解释执行</p>
<h4 id="Android源码对应实现-5"><a href="#Android源码对应实现-5" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>Android源码中</code>的解释器模式并不多见, 虽然没有经典实现, 但是可以在一些地方看到对解释器模式原理的应用. <code>AndroidManifest.xml</code>这个清单文件</p>
<p>整理一下大体过程. 关于读取配置文件, 那么就需要一个很重要的类<code>PackageParser</code>. 该类对<code>AndroidManifest.xml</code>中每一个组件标签创建了对应的类, 用于存储相应的消息.</p>
<p><code>PackageParser</code>为<code>Activity</code>,<code>Service</code>,<code>Provider</code>,<code>Permission</code>等构件在其内部以内部类的方式创建了对应的类, 按照解释器模式的定义, 这些类其实都对应<code>AndroidManifest.xml</code>中的一个标签, 也就是一条文法, 其在对该配置文件解析时充分运用了解释器模式分离实现, 解释器执行的特性.</p>
<p>对一个<code>APK</code>文件的解析会调用<code>PackageManagerService#scanPackageLI()</code>方法, 这个方法有两种实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,long currentTime, UserHandle user);</div><div class="line"> </div><div class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,int scanFlags, long currentTime, UserHandle user)</div></pre></td></tr></table></figure>
<p>两者的唯一区别是第一个参数, 第一种实现为<code>File</code>第二种为<code>PackageParser.Package</code>. 在具体解析某个文件时会先调用第一种实现解析<code>apk</code>文件, 在调用第二种实现将解析后的信息保存至<code>PMS</code>中. 而这两种方法中同样会调用一个函数名相同但参数不同的函数. <code>ParserPackage(...)</code>. 对于参数1为<code>File</code>类型的其中主要逻辑就是为了第二种<code>参数为Resources</code>实现准备好需要的参数, 然后可以调用第二种<code>ParserPackage(Resource ...)</code>.</p>
<p>而<code>ParserPackage</code>的第二种实现逻辑比较复杂, 内部主要对整个<code>AndroidManifest.xml</code>配置文件的每个子节点进行具体的解析.</p>
<p>例如<code>parseApplication</code>方法的会对<code>application</code>节点进行解析, 对于不同的子标签会调用不同的解析方法来对其内部进行解析. 如碰到了<code>activity</code>标签, 那么会调用<code>parseActivity()</code>进行内部解析. 而<code>parseActivity()</code>不仅承担着对<code>Activity</code>的解析, 其同样承担着<code>Broadcast</code>的解析. 并会继续调用方法对内部标签进行解析如<code>parseIntent</code>和<code>parseMetaData</code>等.</p>
<h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h3><h4 id="模式介绍-8"><a href="#模式介绍-8" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>行为型设计模式, 如当我们点击关机键的时候, 系统就会执行一系列的操作, 保存程序的进度, 结束程序, 调用内核命令关机. 用户不关心命令做了什么, 只需要点击关机即可达到效果.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 将一个请求封装成一个对象, 从而让用户使用不同的请求把客户端参数化; 对请求排队或者记录请求日志, 以及支持可撤销操作.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>需要抽象出待执行的操作, 然后以参数的形式提供出来– 类似于过程设计中的回调机制, 而命令模式正式回调机制的一个面向对象的替代品</li>
<li>在不同的时刻指定, 排列和执行请求. 一个命令对象可以有与初始请求无关的生存期</li>
<li>需要支持取消操作</li>
<li>支持修改日志的功能, 这样当系统崩溃的时候, 这些修改可以重做一遍</li>
<li>需要支持事务的操作</li>
</ul>
</li>
</ul>
<h4 id="模式范例-8"><a href="#模式范例-8" class="headerlink" title="模式范例"></a>模式范例</h4><p>把俄罗斯方块的大体逻辑模拟成代码, 向左,向右,变形,加速下落这四个按钮相当于<code>请求者</code>, 执行具体按钮命令的逻辑方法可以看做是命令角色.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/command" target="_blank" rel="external">范例代码</a></p>
<p>范例类图</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Command.png" alt="img"></p>
<p>代码测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static void main(String arg[])&#123;</div><div class="line"></div><div class="line">   // 创建游戏</div><div class="line">   TetrisMachine machine = new TetrisMachine();</div><div class="line"></div><div class="line">   // 根据游戏构造四个命令</div><div class="line">   LeftCommand leftCommand = new LeftCommand(machine);</div><div class="line">   RightCommand rightCommand = new RightCommand(machine);</div><div class="line">   FastCommand fastCommand = new FastCommand(machine);</div><div class="line">   TransformCommand transformCommand = new TransformCommand(machine);</div><div class="line"></div><div class="line">   // 按钮可以执行不同的命令</div><div class="line">   Buttons buttons = new Buttons();</div><div class="line">   buttons.setmLeftCom(leftCommand);</div><div class="line">   buttons.setmRightCom(rightCommand);</div><div class="line">   buttons.setmFastCom(fastCommand);</div><div class="line">   buttons.setmTransformCom(transformCommand);</div><div class="line"></div><div class="line">   // 具体按下那个按钮玩家说的算</div><div class="line">   buttons.toLeft();</div><div class="line">   buttons.toRight();</div><div class="line">   buttons.fast();</div><div class="line">   buttons.transform();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实调用逻辑做的很复杂, 完全可以直接创建<code>TetrisMachine</code>类直接调用的. 这样做的主要原因是后续开发方便, 比如如果需要增加或修改游戏功能只需要修改<code>TetrisMachine</code>类就可以. 然后修改一下<code>Player</code>类. 但是事物是相对的对开发者方便了, 但是如果别人负责了这个项目看到这个功能可能会花更多时间去理解,反而简单的事情没有很直接的表达.</p>
<p>除此之外, 使用命令模式的另一个好处是可以实现命令记录的功能, 如上面代码中, 如果要<code>Button</code>请求者角色中使用一个数据结构来存储执行过的命令对象, 以此可以很方便地知道刚刚执行过哪些命令动作, 并可以在需要时恢复</p>
<h4 id="Android源码对应实现-6"><a href="#Android源码对应实现-6" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>Android</code>中关于命令模式的使用虽然不少, 但都不是典型, 很多方面的应用与其他大多数设计模式一样都有一定的变种, 一个比较经典的例子是<code>Android的事件机制中底层逻辑对事件的转发处理</code>, <code>Android</code>的每一种事件在屏幕上产生后都会经过底层逻辑将其封装转换为一个<code>NotifiArgs</code>对象.</p>
<h4 id="实战场景-4"><a href="#实战场景-4" class="headerlink" title="实战场景"></a>实战场景</h4><p>很好的一个场景就是, 对画板模块的使用, 可以很方便的实现重画,撤销等功能.</p>
<h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h3><h4 id="模式介绍-9"><a href="#模式介绍-9" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>一个使用率非常高的模式, 常用的地方GUI系统, 订阅–发布系统. 最明显的特点就是解耦, 将被观察者和观察者进行解耦, 使得依赖性更小.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 定义对象间一种一对多的依赖关系,使得每当一个对象改变状态, 则所有依赖于它的对象都会得到通知并被自动更新.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>关联行为场景, 需要注意的是, 关联行为是可拆分的, 而不是<code>组合</code>的关系</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景, 如消息队列,事件总线的处理机制</li>
</ul>
</li>
</ul>
<h4 id="模式范例-9"><a href="#模式范例-9" class="headerlink" title="模式范例"></a>模式范例</h4><p>例如一个简单的订阅, 订阅者可以在被观察者更新的时候收到通知.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/observer" target="_blank" rel="external">范例源码</a></p>
<p>类图就不需要了, 因为<code>JDK</code>已经内置了此模式的实现, 看一下范例的调用方式和结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public  static void main(String arg[])&#123;</div><div class="line">   // 创建被观察对象</div><div class="line">   DecTechFrontier decTechFrontier = new DecTechFrontier();</div><div class="line"></div><div class="line">   // 创建几个观察者</div><div class="line">   Coder co1 = new Coder(&quot;张飞&quot;);</div><div class="line">   Coder co2 = new Coder(&quot;李逵&quot;);</div><div class="line">   Coder co3 = new Coder(&quot;关羽&quot;);</div><div class="line">   Coder co4 = new Coder(&quot;孙悟空&quot;);</div><div class="line"></div><div class="line">   // 将观察者注册到被观察的对象</div><div class="line">   decTechFrontier.addObserver(co1);</div><div class="line">   decTechFrontier.addObserver(co2);</div><div class="line">   decTechFrontier.addObserver(co4);</div><div class="line">   decTechFrontier.addObserver(co3);</div><div class="line"></div><div class="line">   // 发布消息</div><div class="line">   decTechFrontier.postNewPublication(&quot;葵花宝典&quot;);</div><div class="line">&#125;</div><div class="line">// =====&gt; 输出结果</div><div class="line">你好, 关羽, 你订阅的东西有更新了: 葵花宝典 </div><div class="line">你好, 孙悟空, 你订阅的东西有更新了: 葵花宝典 </div><div class="line">你好, 李逵, 你订阅的东西有更新了: 葵花宝典 </div><div class="line">你好, 张飞, 你订阅的东西有更新了: 葵花宝典</div></pre></td></tr></table></figure>
<p><code>Observer</code>和<code>Observable</code>是<code>JDK</code>中的内置类型, 可见观察者模式是非常重要的, 这里<code>Observer</code>是抽象观察者角色, <code>范例Coder</code>类扮演的是具体观察者角色; <code>Observable</code>对应的是抽象主题角色, <code>范例DecTechFrontier</code>是具体的主题角色. <code>主题角色</code>通过<code>setChange()</code>标识主题发生改变,并通过<code>notifyObservable()</code>通知所有的<code>观察者角色</code>. 而<code>观察者</code>都过复写<code>update()</code>方法来实现主题更新时需要做的事情 . 至此这两个角色并没有耦合.</p>
<h4 id="Android源码对应实现-7"><a href="#Android源码对应实现-7" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>ListView</code>中的<code>Adapter#notifyDataSetChange()</code>就是通过观察者模式实现的子View的更新.</p>
<p>首先是<code>notifyDataSetChange()</code>方法为入口. 这个方法定义在<code>BaseAdapter</code>中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter &#123;</div><div class="line">    // 数据集观察者</div><div class="line">    private final DataSetObservable mDataSetObservable = new DataSetObservable();</div><div class="line">    public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">        mDataSetObservable.registerObserver(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">        mDataSetObservable.unregisterObserver(observer);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 数据发生改变是, 调用所有观察者</div><div class="line">    **/</div><div class="line">    public void notifyDataSetChanged() &#123;</div><div class="line">        mDataSetObservable.notifyChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显的<code>BaseAdapter</code>是一个观察者模式, 那么接着看一下如何运作, 以及这个观察者是什么.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    // 调用每个观察者的onChange函数来通知他们被观察者发生了改变</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized(mObservers) &#123;</div><div class="line">            // 调用所有的观察者onChange()</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我们调用的<code>notifyDataSetChanged()</code>会遍历所有的观察者中的<code>onChange()</code>.</p>
<p>这些观察者就是在<code>ListView</code>通过<code>setAdapter()</code>方法设置<code>Adapter</code>产生的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">   // 如果已经有了一个Adapter, 那么先注销该Adapter对应的观察者</div><div class="line">   if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">           mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">       &#125;</div><div class="line">   super.setAdapter(adapter);</div><div class="line"></div><div class="line">   if (mAdapter != null) &#123;</div><div class="line">       mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">       mOldItemCount = mItemCount;</div><div class="line">       // 获取数据的数量</div><div class="line">       mItemCount = mAdapter.getCount();</div><div class="line">       checkFocus();</div><div class="line">       // *** 创建一个数据集观察者</div><div class="line">       mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">       // 将这个观察者注册到Adapter中, 实际上注册到了 DataSetObservable中</div><div class="line">       mAdapter.registerDataSetObserver(mDataSetObserver);</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出, 在设置<code>Adapter</code>时会构建一个<code>AdapterDataSetObserver</code>, 这就是之前说的观察者, 最后将这个观察者注册到<code>Adapter</code>中</p>
<p>那么<code>AdapterDataSetObserver</code>是什么? 是如何运作的? 首先这个这个类定义在了<code>ListView</code>的父类<code>AbsListView</code>中, 而这个类又继承了<code>AbsListView</code>的父类<code>AdapterView的AdapterDataSetObserver</code>.如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line"></div><div class="line">   private Parcelable mInstanceState = null;</div><div class="line"></div><div class="line">   // 核心方法</div><div class="line">   @Override</div><div class="line">   public void onChanged() &#123;</div><div class="line">       mDataChanged = true;</div><div class="line">       mOldItemCount = mItemCount;</div><div class="line">       // 获取adapter的数量</div><div class="line">       mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">       if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">               &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">           AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">           mInstanceState = null;</div><div class="line">       &#125; else &#123;</div><div class="line">           rememberSyncState();</div><div class="line">       &#125;</div><div class="line">       checkFocus();</div><div class="line">       // 重新布局</div><div class="line">       requestLayout();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这回应该很清楚了, 当<code>ListView</code>的数据发生变化时, 调用了<code>Adapter#notifyDataSetChanged()</code>函数, 这个函数又会调用<code>DataSetObserver#notifyChange()</code>函数, 这个函数会遍历所有的观察者<code>AdapterDataSetObserver#onChange()</code> 在<code>onChange()</code>方法中又会调用<code>ListView</code>重新布局, 使得<code>ListView</code>刷新界面</p>
<h4 id="实战场景-5"><a href="#实战场景-5" class="headerlink" title="实战场景"></a>实战场景</h4><p>事件总线!</p>
<h3 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 Memento"></a>备忘录模式 Memento</h3><h4 id="模式介绍-10"><a href="#模式介绍-10" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>一种行为模式, 该模式用于保存对象, 并且在之后可以再次恢复到此状态</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 在不破坏封闭的前提下, 捕获一个对象的内部状态,并在该对象之外保存这个状态, 以后就可将该对象恢复到原先保存的状态.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ol>
<li>需要保存一个对象在某一个时刻的状态或部分状态</li>
<li>如果用一个接口来让其他对象得到这些状态, 将会暴露对象的实现细节并破坏对象的封装性, 一个对象不希望外界直接访问其内部状态, 通过中间对象可以间接访问其内部状态.</li>
</ol>
</li>
</ul>
<h4 id="模式范例-10"><a href="#模式范例-10" class="headerlink" title="模式范例"></a>模式范例</h4><p>比如一个游戏, 在退出时候保存进度, 在进入的时候恢复进度的场景</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/memento" target="_blank" rel="external">范例源码</a></p>
<p>范例类图</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Memento.png" alt="img"></p>
<p>范例的使用–&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public static void main(String arg[])&#123;</div><div class="line"></div><div class="line">   // 构建游戏对象</div><div class="line">   CallOfDuty game = new CallOfDuty();</div><div class="line"></div><div class="line">   // 1 打游戏</div><div class="line">   game.play();</div><div class="line"></div><div class="line">   Caretaker caretaker = new Caretaker();</div><div class="line">   // 2 游戏存档</div><div class="line">   caretaker.archive(game.createMemo());</div><div class="line"></div><div class="line">   // 3 退出游戏</div><div class="line">   game.quit();</div><div class="line"></div><div class="line">   // 4 恢复游戏</div><div class="line">   CallOfDuty newGame = new CallOfDuty();</div><div class="line">   newGame.restore(caretaker.getMemo());</div><div class="line">&#125;</div><div class="line"></div><div class="line">// =======&gt; 运行结果</div><div class="line">玩游戏: 第1关 奋战杀敌中</div><div class="line">进度升级中</div><div class="line">到达 第2关</div><div class="line">-----</div><div class="line">退出前的游戏属性: 当前游戏信息: checkpoint=2 ,mLifeValue=90 ,mWeapon=沙漠之鹰</div><div class="line">退出游戏</div><div class="line">-----</div><div class="line">恢复后的游戏属性--&gt; 当前游戏信息: checkpoint=2 ,mLifeValue=90 ,mWeapon=沙漠之鹰</div></pre></td></tr></table></figure>
<p>可以看到<code>CallOfDuty</code>在这里为<code>Originator</code>角色, 也就是需要存储的对象, 在这里并没有直接存储对象, 而是通过<code>Memo</code>对<code>CallOfDuty</code>对象的数据进行存储, 然后在存储<code>Memo</code>对象, 最终对<code>Memo</code>的存储操作交给<code>Caretaker</code>对象. 在这个过程中, 各个角色职责清晰, 单一, 即对外屏蔽了对<code>CallOfDuty</code>角色的直接访问, 在满足了对象状态存取功能的同时也使得该模块的结构清晰, 整洁.</p>
<h4 id="Android源码对应实现-8"><a href="#Android源码对应实现-8" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>在<code>Android</code>源码中的状态模式应用是<code>Activity</code>中的状态保存.</p>
<p>在这里, <code>Activity</code>扮演了<code>Caretaker</code>角色, 负责存储和恢复UI的状态信息; <code>Activity</code>,<code>Fragment</code>,<code>View</code>,<code>ViewGroup</code>等对象为<code>Originator</code>角色, 也就是需要存储状态的角色. <code>Memo</code>则由<code>Bundle</code>类扮演.</p>
<h3 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h3><h4 id="模式介绍-11"><a href="#模式介绍-11" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>也成为游标模式, 行为性设计模式. 源于对容器的访问.</p>
</blockquote>
<ul>
<li><code>定义</code>: 提供了一种方法顺序访问一个容器对象中的各个元素, 而不需要暴露该对象的内部表示</li>
<li><code>场景</code>: 遍历一个容器对象</li>
</ul>
<h4 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h4><p>场景: 如两个部门, 老板想要对两个部门的统计数据, 但是如果两个部门的内部实现存储如果是一个用数组, 一个集合, 那么老板访问就需要了解其内部的数据结构. 使得老板的职责过多, 这个时候如果用迭代器模式实现,统一遍历方式, 那么就会很方便,也不会对外暴露内部的实现细节. 如下:</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/cursor" target="_blank" rel="external">范例代码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Cursor.png" alt="img"></p>
<p>使用情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[])&#123;</div><div class="line">   CompanSu companSu = new CompanSu();</div><div class="line">   check(companSu.iterator());</div><div class="line"></div><div class="line">   CompanLi companLi = new CompanLi();</div><div class="line">   check(companLi.iterator());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void check(Iterator iterator) &#123;</div><div class="line">   while (iterator.hasNext())&#123;</div><div class="line">       System.out.println(iterator.next().toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ======&gt; 结果</div><div class="line">Employee&#123;name=&apos;小敏&apos;, age=99, sex=&apos;男&apos;, position=&apos;程序员&apos;&#125;</div><div class="line">Employee&#123;name=&apos;小李&apos;, age=98, sex=&apos;男&apos;, position=&apos;程序员&apos;&#125;</div><div class="line">Employee&#123;name=&apos;小往&apos;, age=11, sex=&apos;女&apos;, position=&apos;程序员&apos;&#125;</div><div class="line">Employee&#123;name=&apos;小爱&apos;, age=9, sex=&apos;女&apos;, position=&apos;程序员&apos;&#125;</div><div class="line">Employee&#123;name=&apos;大敏&apos;, age=66, sex=&apos;妖&apos;, position=&apos;未知&apos;&#125;</div><div class="line">Employee&#123;name=&apos;大李&apos;, age=66, sex=&apos;妖&apos;, position=&apos;未知&apos;&#125;</div></pre></td></tr></table></figure>
<p>这个例子只是列举个思想, 可以看到通过迭代器实现, 就可以对外通过一个统一的接口, 来对不同的内部细节不一样的容器进行访问. 这也是<code>List</code>,<code>Map</code>都实现迭代器的意义.</p>
<h4 id="Android源码对应实现-9"><a href="#Android源码对应实现-9" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>几乎开发者不会自己去实现一个迭代器, 例如<code>Android</code>中, 除了各种数据结构体, 最典型的就是数据库查询使用了<code>Cursor</code>. 当使用<code>SQLiteDatabase#query()</code>方法查询数据时, 会返回一个<code>Cursor</code>对象. 该对象实质就是一个迭代器.</p>
<p>所以可以看出迭代器模式, 特点很明显也很单一, 支持以不同的方式去遍历一个容器对象, 也可以有多个遍历, 弱化了容器与遍历算法之间的关系. 几乎每一种高级语言都有对应的内置迭代器实现.</p>
<h3 id="模板模式-Template"><a href="#模板模式-Template" class="headerlink" title="模板模式 Template"></a>模板模式 Template</h3><h4 id="模式介绍-12"><a href="#模式介绍-12" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>某一个算法所需要的关键步骤是已知的, 但是某一步的具体实现是未知的需要子类去实现</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 定义一个操作中的算法框架, 而将一些步骤延迟到子类中, 使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>多个子类有共有的方法, 并且逻辑基本相同</li>
<li>重要, 复杂的算法, 可以把核心算法设计为模板方法, 周边的相关细节由子类去实现</li>
<li>重构时, 模板方法模式是一个经常使用的模式, 把相同的代码抽取到父类, 然后通过钩子函数约束其行为</li>
</ul>
</li>
</ul>
<h4 id="模式范例-11"><a href="#模式范例-11" class="headerlink" title="模式范例"></a>模式范例</h4><p>模板方式实际上是封装一个固定流程, 然后暴露某一个步骤方法, 这里以计算机开机为例子,</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/template" target="_blank" rel="external">范例代码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Template.png" alt="img"></p>
<p>代码使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String arg[])&#123;</div><div class="line"></div><div class="line">   CodeComputer codeComputer = new CodeComputer();</div><div class="line">   codeComputer.startUp();</div><div class="line"></div><div class="line">   MilitaryComputer militaryComputer = new MilitaryComputer();</div><div class="line">   militaryComputer.startUp();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ========&gt; 运行结果</div><div class="line">--------- 开机 start -----------</div><div class="line">开启电源</div><div class="line">硬件检测</div><div class="line">载入操作系统</div><div class="line">需要密码</div><div class="line">---------- 关机 end ---------------</div><div class="line">--------- 开机 start -----------</div><div class="line">开启电源</div><div class="line">硬件检测</div><div class="line">&gt;&gt; 需要检测防火墙</div><div class="line">载入操作系统</div><div class="line">需要进行眼膜验证</div><div class="line">---------- 关机 end ---------------</div></pre></td></tr></table></figure>
<p>上面代码不管什么情况四个步骤是必须的, 开启电源是刚需,不需要子类实现, <code>startUp()</code>设置方法是<code>final</code>因为调用流程是必须的. 而其余的方法根据不同的需求来进行改造.</p>
<h4 id="Android源码对应实现-10"><a href="#Android源码对应实现-10" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>Android</code>中<code>AsyncTask</code>就是一个比较明显的模板方法模式.</p>
<p>其内部调用顺序就是 <code>execute</code>–&gt;<code>onPreExecute</code>–&gt;<code>doInBackground</code>–&gt;<code>onPostExecute</code></p>
<p>或者比如<code>Activity</code>的声明周期方法.</p>
<h3 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式 Visitor"></a>访问者模式 Visitor</h3><h4 id="模式介绍-13"><a href="#模式介绍-13" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>访问者模式是一种将数据操作与数据结构分离的设计模式,它是23种设计模式最复杂的一个, 但使用率不高. 大体思想, 软件系统中拥有一个由许多对象构成的, 比较稳定的对象结构, 这些对象的类都拥有一个<code>accept</code>方法用来接收访问者对象的访问. 访问者是一个接口, 他拥有<code>visit</code>方法, 这个方法对访问到的对象结构中不同的类型元素做出不同的处理.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 封装一些作用于某种数据结构中的各个元素的操作, 它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>对象结构比较稳定, 但经常需要在此对象结构上定义新的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作, 而需要避免这些操作污染这些对象的类, 也不希望在增加新操作时修改这些类</li>
</ul>
</li>
</ul>
<h4 id="模式范例-12"><a href="#模式范例-12" class="headerlink" title="模式范例"></a>模式范例</h4><p>场景: 公司的年度考核, 评定员工分别是<code>CEO</code>和<code>CTO</code>, 而<code>CEO</code>只关注工程师的代码量和经理的新产品数; <code>CTO</code>关注的是工程师的<code>KPI</code>和经理的<code>KPI</code>. 这时<code>CEO</code>和<code>CTO</code>对于不同员工的关注点是不一样的. 这就需要对不同的员工类型进行不同的处理. 访问者模式此时可以派上用场了.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/visitor" target="_blank" rel="external">范例代码</a></p>
<p>代码使用结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[])&#123;</div><div class="line">   // 构建报表</div><div class="line">   BusinessReport report = new BusinessReport();</div><div class="line"></div><div class="line">   System.out.println(&quot;----------给CEO看的报表----------&quot;);</div><div class="line">   // 设置访问者, 这里是CEO</div><div class="line">   report.showReport(new CEOVisitor());</div><div class="line"></div><div class="line">   System.out.println(&quot;----------给CTO看的报表----------&quot;);</div><div class="line">   // 注入另一访问者CTO</div><div class="line">   report.showReport(new CTOVisitor());</div><div class="line">&#125;</div><div class="line">// ======&gt; 结果</div><div class="line">----------给CEO看的报表----------</div><div class="line">CEO访问--&gt; 经理王经理 . KPI : 9 , 新产品数量: 0</div><div class="line">CEO访问--&gt; 工程师工程师-jake . KPI : 2</div><div class="line">CEO访问--&gt; 工程师工程师-小李 . KPI : 5</div><div class="line">CEO访问--&gt; 工程师工程师-小张 . KPI : 0</div><div class="line">----------给CTO看的报表----------</div><div class="line">CTO访问--&gt; 经理 王经理 , 新产品数量: 0</div><div class="line">CTO访问--&gt; 工程师 工程师-jake . 代码行数 : 14290</div><div class="line">CTO访问--&gt; 工程师 工程师-小李 . 代码行数 : 2183</div><div class="line">CTO访问--&gt; 工程师 工程师-小张 . 代码行数 : 83422</div></pre></td></tr></table></figure>
<p>范例中<code>Staff</code>扮演了<code>Element</code>角色, 而<code>Enginner</code>和<code>Manager</code>都是<code>ConcreteElement</code>; <code>CEOVisitor</code>和<code>CTOVistor</code>都是具体的<code>Vistor</code>对象, 而<code>BusinessReport</code>就是<code>ObjectStructure</code>; <code>Client</code>就是客户端</p>
<p>访问者最大的优点就是增加访问者非常容易, 如果要增加一个访问者, 只需要创建一个实现了<code>Visitor</code>接口的类, 然后实现两个<code>visi</code>函数来对不同的元素进行不同的操作, 从而达到数据对象与数据操作相分离的效果.</p>
<h4 id="Android源码对应实现-11"><a href="#Android源码对应实现-11" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>APT</code>的注解. 简单记录一下. 首先编译器将代码抽象成一个代码元素的树, 然后在编译时对整棵树进行遍历访问, 每个元素都有一个<code>accept()</code>接收访问者的访问, 每个访问者中都有对应的<code>visit()</code>函数, 例如<code>visitType()</code>函数就是对类型元素的访问, 在每个<code>visit</code>函数中对不同的类型进行不同的处理, 这样就达到了差异处理效果, 同时将数据结构与数据操作分离, 使得每个类型的职责单一, 易于升级维护. <code>JDK</code>还特意预留了<code>visitUnknown()</code>接口应对<code>Java</code>语言后续发展可能添加的元素类型问题, 灵活的将访问者模式的缺点化解.</p>
<h3 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h3><h4 id="模式介绍-14"><a href="#模式介绍-14" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>也称为调节者模式或者调停者模式</p>
</blockquote>
<ul>
<li><code>定义</code>: 包装了一系列对象互相作用的方式, 使得这些对象不必互相明显作用. 从而使他们可以松散耦合. 当某些对象之间的作用发生改变时, 不会立即影响其他的一些对象之间的作用. 保证这些作用可以彼此独立的变化. 中介者模式将多对多的关系转化为一对多的相互作用. 中介者模式将对象的行为和协作抽象化, 把对象在小尺度的行为上与其他对象的相互作用分开处理.</li>
<li><code>场景</code>: 当对象之间的交互操作很多且每个对象的行为都依赖彼此时, 为防止在修改一个对象的行为会涉及修改很多其他对象的行为, 可采用中介者模式, 来解决紧耦合问题. 该模式将对象之间的多对多关系变成了一对多关系, 中介者对象将系统从网状结构变成以调停者为中心的星形结构, 达到降低系统的复杂性, 提高可扩展的作用.</li>
</ul>
<h4 id="模式范例-13"><a href="#模式范例-13" class="headerlink" title="模式范例"></a>模式范例</h4><p>场景: 以电脑为例, 电脑主要部分为:CPU, 内存, 显卡, IO设备. 通常需要一个东西把这些组件连接起来共同工作,这就是主板的工作. 任何的两块模块之间的通信都会经过主板去协调. 这里以读取光盘为例.看主板是如何充当这个中介者角色的.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/mediator" target="_blank" rel="external">范例代码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Mediator.png" alt="img"></p>
<p>代码使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void main(String arg[])&#123;</div><div class="line"></div><div class="line">   // 构造主板对象</div><div class="line">   MainBoard mainBoard = new MainBoard();</div><div class="line"></div><div class="line">   // 构造各个零件同事</div><div class="line">   CDDevice cdDevice = new CDDevice(mainBoard);</div><div class="line">   CPU cpu = new CPU(mainBoard);</div><div class="line">   GraphicsCard graphicsCard = new GraphicsCard(mainBoard);</div><div class="line">   SoundCard soundCard = new SoundCard(mainBoard);</div><div class="line"></div><div class="line">   // 将各个部件安装到主板</div><div class="line">   mainBoard.setCdDevice(cdDevice);</div><div class="line">   mainBoard.setCpu(cpu);</div><div class="line">   mainBoard.setGraphicsCard(graphicsCard);</div><div class="line">   mainBoard.setSoundCard(soundCard);</div><div class="line"></div><div class="line">   // 完成后开始放片</div><div class="line">   cdDevice.load();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从图片可以看出, 虽然彼此间会互相交互, 但是通过中介者模式, 会让一个网状的关系, 转成一个以<code>中介者</code>为中心的星状图.</p>
<h4 id="Android源码对应实现-12"><a href="#Android源码对应实现-12" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>中介者模式在<code>Android</code>源码中比较好的例子是<code>Keyguard</code>锁屏的实现.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class KeyguardViewMediator extends SystemUI &#123;</div><div class="line">    private AlarmManager mAlarmManager;</div><div class="line">    private AudioManager mAudioManager;</div><div class="line">    private StatusBarManager mStatusBarManager;</div><div class="line">    private boolean mSwitchingUser;</div><div class="line"></div><div class="line">    private boolean mSystemReady;</div><div class="line">    private boolean mBootCompleted;</div><div class="line">    private boolean mBootSendUserPresent;</div><div class="line">    // ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到类中存在很多<code>XXManager</code>的变量, 这些各种各样的管理器就是各个具体的实现类, <code>Android</code>使用<code>KeyguardViewMediator</code>充当这个中介者协调这些管理器的状态改变, 同样也会定义很多方法来处理这些管理器的状态, 以解锁或锁屏时声音的播放为例, 对应的方法<code>playSounds()</code>来协调音频这一状态.</p>
<p>而其他管理器的协调同样可以在此类找到.</p>
<hr>
<p>而另一个中介者模式的例子就是<code>Binder</code>机制, 在<code>Binder</code>机制中有3个非常重要的组件<code>ServiceManager</code>,<code>Binder Driver</code>和<code>Bp Binder</code>. 其中<code>Bp Binder</code>是<code>Binder</code>的一个代理角色, 其提供了<code>IBinder</code>接口给各个客户端服务使用, 这三者就扮演了一个中介者角色</p>
<p>当手机启动后, <code>ServiceManager</code>会先向<code>Binder Driver</code>进行注册, 同样<code>ServiceManager</code>也是一个服务, 但特殊性在于, 它在<code>Binder Driver</code>中是最先被注册的, 其注册<code>ID</code>为0, 当其他的服务想要注册到<code>Binder Driver</code>时, 会先通过这个<code>0号ID获取到ServiceManager</code>所对应的<code>IBinder</code>接口, 该接口实质上的实现逻辑是由<code>Bp Binder</code>实现的, 获取到对应的接口后就回调其中的<code>transact()</code>方法, 此后就会在<code>Binder Driver</code>中注册一个<code>ID 1</code>来对应这个服务, 如果客户端想要使用这个服务, 那么他会先获取<code>ID 0</code>的接口, 也就是<code>ServiceManager</code>所对应的接口, 并调用其<code>transact()</code>要求连接到刚才的服务, 这个时候<code>Binder Driver</code>就会将<code>ID 1</code>的服务回传给客户端并将相关信息反馈给<code>ServiceManager</code>完成连接. 这里<code>ServiceManger</code>和<code>Binder Driver</code>就相当于一个中介者, 协调各个服务器和客户端.</p>
<h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h3><h4 id="模式介绍-15"><a href="#模式介绍-15" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>也称委托模式, 结构性设计模式. 生活中也是有很多常见的代理例子, 代理上网, 叫外卖, 通过律师打官司都是一种代理</p>
</blockquote>
<ul>
<li><code>定义</code>: 为其他对象提供一种代理以控制对这个对象的访问</li>
<li><code>场景</code>: 当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问, 为了保证客户端使用的透明性, 委托对象与代理对象需要实现相同的接口.</li>
</ul>
<h4 id="模式范例-14"><a href="#模式范例-14" class="headerlink" title="模式范例"></a>模式范例</h4><p>场景: 公司拖欠工资, 员工通过律师来间接的和公司要钱.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/proxy" target="_blank" rel="external">范例源码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Proxy.png" alt="img"></p>
<p>使用时代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[])&#123;</div><div class="line">   // 构造一个起诉者</div><div class="line">   ConcreteLawsuit concreteLawsuit = new ConcreteLawsuit();</div><div class="line"></div><div class="line">   // 构造一个律师, 被代理者</div><div class="line">   Lawyer lawyer = new Lawyer(concreteLawsuit);</div><div class="line"></div><div class="line">   // 律师代理</div><div class="line">   lawyer.submit();</div><div class="line">   lawyer.burden();</div><div class="line">   lawyer.defend();</div><div class="line">   lawyer.finish();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代理模式大致分为两个部分, 一个是<code>静态代理</code>,还有一个是<code>动态代理</code>.</p>
<ul>
<li><code>静态代理</code>如上述示例那样, 代理者的代码由程序员自己或者通过自动化工具生成固定的代码再对其进行编译, 也就是说在我们的代码运行前<code>代理类class</code>编译文件就已经存在</li>
<li><code>动态代理</code>则与静态代理相反, 通过反射机制动态生成代理者对象, 也就是说我们在<code>code阶段</code>压根就不需要知道代理谁, 代理谁将会在执行阶段决定, 而<code>Java</code>也给我们提供了一个便捷的动态代理接口<code>InvocationHandler</code>, 并复写<code>invoke()</code></li>
</ul>
<p>动态代理最终的调用方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 构造一个动态代理</div><div class="line">DynamicProxy dynamicProxy = new DynamicProxy(concreteLawsuit);</div><div class="line"></div><div class="line">// 获取被代理者的ClassLoader</div><div class="line">ClassLoader classLoader = concreteLawsuit.getClass().getClassLoader();</div><div class="line"></div><div class="line">// 动态构造一个代理者律师</div><div class="line">ILawsuit law = (ILawsuit) Proxy.newProxyInstance(classLoader, new Class[]&#123;ILawsuit.class&#125;, dynamicProxy);</div><div class="line"></div><div class="line">// 动态调用</div><div class="line">law.submit();</div><div class="line">law.burden();</div><div class="line">law.defend();</div><div class="line">law.finish();</div></pre></td></tr></table></figure>
<h4 id="Android源码对应实现-13"><a href="#Android源码对应实现-13" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>Android</code>源码中的代理模式实现有很多, 如源码中的<code>ActivityManagerProxy</code>代理类, 其具体代理的是<code>ActivityManagerNative</code>的子类<code>ActivityManagerService</code>. <code>ActivityManagerProxy</code>与<code>ActivityManagerNative</code>处于同一个文件.</p>
<p>而<code>ActivityManagerProxy</code>和<code>ActivityManagerNative</code>都继承了<code>IActivityManager</code></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/proxy-ams.png" alt="img"></p>
<p>可以很明显的看出这三个类构成的<code>代理模式</code>, 但是由于<code>AMN</code>是抽象类, 所以具体的实现交由了子类<code>AMS</code>去实现. 而<code>AMS</code>是系统级的<code>Service</code>并且运行于独立的进程空间中, 可以通过<code>ServiceManager</code>来获取它. 而<code>AMP</code>也运行于自己所处的进程空间中, 两者并不相同, 因此<code>AMS</code>和<code>AMP</code>的通信必定是通过跨进程来进行的, 所以此处源码中所实现的实质为远程代理.</p>
<p><code>AMP</code>在实际的逻辑处理中并未过多地被外部类使用, 因为在<code>Android</code>中管理与维护<code>Activity</code>相关信息的是另一个叫做<code>ActivityManager</code>的类, <code>ActivityManager</code>虽说管理着相关信息, 但是实质上其大多数逻辑都是由<code>AMP</code>承担的.</p>
<h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h3><h4 id="模式介绍-16"><a href="#模式介绍-16" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>结构性设计模式, 比较简单, 把一组相似的对象看做一个对象来处理, 并根据一个树状结构来组合对象, 然后提供一个统一的方法去访问相应的对象, 以此忽略掉对象与对象集合之间的差别.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 将对象组合成树形结构以表示<code>整体-部分</code>的层次结构, 使得用户对单个对象和组合对象的使用一致性</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>表示对象的部分-整体层次结构</li>
<li>从一个整体中能够独立出部分模块或功能的场景</li>
</ul>
</li>
</ul>
<h4 id="模式范例-15"><a href="#模式范例-15" class="headerlink" title="模式范例"></a>模式范例</h4><p>一个很好的组合例子就是文件夹和文件之间的关系. 以此为例, 看看一个简单文件系统是如何构成的.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/composite" target="_blank" rel="external">范例源码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Composite.png" alt="img"></p>
<p>使用代码和结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static void main(String arg[])&#123;</div><div class="line">   // 构造一个目录对象表示c盘目录</div><div class="line">   Folder diskC = new Folder(&quot;C&quot;);</div><div class="line"></div><div class="line">   // C盘根目录下有一个文件 Log.txt</div><div class="line">   diskC.addDir(new File(&quot;Lag.txt&quot;));</div><div class="line"></div><div class="line">   // C盘下还有3个子目录</div><div class="line">   diskC.addDir(new Folder(&quot;目录1&quot;));</div><div class="line"></div><div class="line">   Folder dirs = new Folder(&quot;目录2&quot;);</div><div class="line">   dirs.addDir(new File(&quot;null.txt&quot;));</div><div class="line">   diskC.addDir(dirs);</div><div class="line"></div><div class="line">   diskC.addDir(new Folder(&quot;目录3&quot;));</div><div class="line"></div><div class="line">   // 打印文件结构</div><div class="line">   diskC.print();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// =========&gt; 结果</div><div class="line">C (Lag.txt,目录1 (),目录2 (null.txt),目录3 ())</div></pre></td></tr></table></figure>
<p>从根节点依次延伸可以很明显看出这是一个树状的嵌套结构. 这就是组合模式</p>
<h4 id="Android源码对应实现-14"><a href="#Android源码对应实现-14" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>这个模式在<code>Android</code>有一个很经典的表示, 我们一直再使用, 就是<code>View</code>和<code>ViewGroup</code>结构.</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/composite-view.png" alt="img"></p>
<p>由于<code>View</code>的视图层级中使用的是<code>安全的设计模式</code>, 所以只能是<code>ViewGroup</code>才可以包含<code>View</code>,反之则不可以, 而上面的范例使用的是<code>透明的组合模式</code>. 可以观察一下具体有哪些不同.</p>
<h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h3><h4 id="模式介绍-17"><a href="#模式介绍-17" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>这也是一个我们从始至终都在使用的模式, <code>ListView</code>,<code>GridView</code>,<code>RecycleView</code>. 适器就是将两个不兼容的类融合在一起, 有点像粘合剂.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 把一个类的接口转换成客户端所期待的另一个接口, 从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>系统需要使用现有的类, 而此类的接口不符合系统的需要, 即接口不兼容</li>
<li>想要建立一个可以重复使用的类, 用于与一些比起之间没有太大关联的一些类, 包括一些可能在将来引进的类一起工作</li>
<li>需要一个统一的输出接口, 而输入端的类型不可预知</li>
</ul>
</li>
</ul>
<h4 id="模式范例-16"><a href="#模式范例-16" class="headerlink" title="模式范例"></a>模式范例</h4><p>软件开发有一句话: <code>任何问题都可以加一个中间层来解决</code>. 正式对适配器模式的描述, 最常见的就是笔记本电脑一般用的5V电压, 但是生活中的电压都是标准的220V. 所以我们笔记本都通过一个电源适配器来解决此问题.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/adapter" target="_blank" rel="external">范例代码</a></p>
<p>类图关系很简单就不贴出来了</p>
<p>代码中有两种实现:</p>
<ul>
<li><code>类适配器模式</code> : 主要是<code>Adapter</code>角色是<strong>继承需要适配</strong>的角色.</li>
<li><code>对象适配器模式</code>: 通过在构造适配器的时候<strong>传入适配对象</strong>. 使用组合的形式实现接口兼容.</li>
</ul>
<p>相比较, 使用<code>对象适配器</code>更加的灵活, 另一个好处就是被适配对象的方法不会暴露出来, 而<code>类适配器</code>由于继承了被适配的对象, 因此被适配对象类在<code>Adapter</code>类中同样存在, 这就使得<code>Adapter</code>出现了一些奇怪的方法, 用户的使用成本也较高.</p>
<h4 id="Android源码对应实现-15"><a href="#Android源码对应实现-15" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>不用说<code>Adapter</code>大家都知道. <code>Android</code>的做法增加了个<code>Adapter</code>层来隔离变化, 将<code>ListView</code>需要的关于<code>Item View</code>接口抽象到<code>Adapter</code>对象中, 并且在<code>ListView</code>内部调用了<code>Adapter</code>这些接口完成布局等操作. 这样只要用户实现了<code>Adapter</code>的接口, 并且将该<code>Adapter</code>设置给<code>ListView</code>, <code>ListView</code>就可以按照用户设定的<code>UI</code>效果, 数量, 数据来显示每一项数据.</p>
<h3 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h3><h4 id="模式介绍-18"><a href="#模式介绍-18" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>也称包装模式, 结构性设计模式, 使用一种对客户端透明的方式来动态的扩展对象的功能, 同时他也是继承关系的一种替代方案之一</p>
</blockquote>
<ul>
<li><code>定义</code>: 动态地给一个对象添加一些额外的职责. 就增加功能来说, 装饰模式相比生成子类更加灵活.</li>
<li><code>场景</code>: 需要透明且动态地扩展类的功能时</li>
</ul>
<h4 id="模式范例-17"><a href="#模式范例-17" class="headerlink" title="模式范例"></a>模式范例</h4><p>人穿衣服的例子</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/decorator" target="_blank" rel="external">范例源码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Decorator.png" alt="img"></p>
<p>其实可以这种扩展并非是直接修改原有方法逻辑或者结构, 更恰当的说, 仅仅是在另一个类中将原有方法和逻辑进行封装整合.</p>
<p><code>装饰模式</code>和<code>代理模式</code>有点类似, 比较容易混淆的是会把装饰模式当成代理模式. <code>装饰模式</code>是以对客户端透明的方式扩展对象的功能, 是继承关系的一个替代方案. 而<code>代理模式</code>则是给一个对象提供一个对象代理, 并由代理对象来控制对原有对象的引用. <code>装饰模式</code>应该为所装饰的对象增强功能; <code>代理模式</code>对代理的对象施加控制, 但不对对象本身的功能增强.</p>
<h4 id="Android源码对应实现-16"><a href="#Android源码对应实现-16" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>Context</code>, 是不是熟悉的不能再熟悉了. 它的本质就是一个抽象类. 在装饰模式中相当于<code>抽象组件</code>. 虽然<code>Activity</code>继承了<code>Context</code>但是其中的<code>startActivity()</code>,<code>startService()</code>这些都是由另一个继承者来处理的的. 这个<code>Context</code>的另一个继承者就是<code>ContextImpl</code>.</p>
<p><code>ContextImpl</code>内部实现了<code>Context</code>的抽象方法. 而<code>Activity</code>等组件只是将其中的方法进行了转发调用.</p>
<h3 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h3><h4 id="模式介绍-19"><a href="#模式介绍-19" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>用尽可能减少内存使用量, 它适合用于可能存在大量重复对象的场景, 来缓存可共享的对象, 达到对象共享, 避免创建过多对象的效果. 就可以提升性能, 避免内存抖动</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 使用共享对象可有效地支持大量的相似对象</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>系统中存在大量的相似对象</li>
<li>细粒度的对象都具备比较接近的外部状态, 而且内部状态与环境无关, 也就是说对象没有特定身份</li>
<li>需要缓冲池的场景</li>
</ul>
</li>
</ul>
<h4 id="模式范例-18"><a href="#模式范例-18" class="headerlink" title="模式范例"></a>模式范例</h4><p>通过售票口的出票来为例</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/flyweight" target="_blank" rel="external">范例代码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Flyweight.png" alt="img"></p>
<p>代码使用和结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">    public static void main(String arg[])&#123;</div><div class="line">        Ticket ticket = TicketFactory.getTicket(&quot;青岛&quot;, &quot;北京&quot;);</div><div class="line">        ticket.showTicketInfo(&quot;上铺&quot;);</div><div class="line"></div><div class="line">        Ticket ticket1 = TicketFactory.getTicket(&quot;青岛&quot;, &quot;上海&quot;);</div><div class="line">        ticket1.showTicketInfo(&quot;上铺&quot;);</div><div class="line"></div><div class="line">        Ticket ticket2 = TicketFactory.getTicket(&quot;青岛&quot;, &quot;北京&quot;);</div><div class="line">        ticket2.showTicketInfo(&quot;上铺&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ========&gt; </div><div class="line">创建对象--&gt; 青岛-北京</div><div class="line">购买 从青岛 到 上铺 的北京火车票, 价格: 293</div><div class="line">创建对象--&gt; 青岛-上海</div><div class="line">购买 从青岛 到 上铺 的上海火车票, 价格: 20</div><div class="line">使用缓存--&gt; 青岛-北京</div><div class="line">购买 从青岛 到 上铺 的北京火车票, 价格: 141</div></pre></td></tr></table></figure>
<p>其实主要思想就是: 让可复用的对象实现复用, 减少无用的重复创建的步骤.</p>
<h4 id="Android源码对应实现-17"><a href="#Android源码对应实现-17" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>Message</code>对象. 在使用<code>Handler</code>传递数据的时候. 不可避免的需要使用<code>Message</code>. 即使你通过<code>Handler.post(Runnable)</code>传递一个接口, 在源码内部同样会通过<code>Message</code>为载体挂到<code>callback</code>变量上传递. 看一下. 源码中是如何维护一个频繁需要使用对象的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">private static Message sPool;  // 静态!</div><div class="line"></div><div class="line">// 获取一个Message</div><div class="line">public static Message obtain() &#123;</div><div class="line">   synchronized (sPoolSync) &#123;</div><div class="line">       if (sPool != null) &#123;</div><div class="line">           Message m = sPool;</div><div class="line">           sPool = m.next;</div><div class="line">           m.next = null;</div><div class="line">           m.flags = 0; // clear in-use flag</div><div class="line">           sPoolSize--;</div><div class="line">           return m;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return new Message();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 回收, 实现缓存的方法</div><div class="line">public void recycle() &#123;</div><div class="line">   if (isInUse()) &#123;</div><div class="line">       if (gCheckRecycle) &#123;</div><div class="line">           throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</div><div class="line">                   + &quot;is still in use.&quot;);</div><div class="line">       &#125;</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line">   recycleUnchecked();</div><div class="line">&#125;</div><div class="line"></div><div class="line">void recycleUnchecked() &#123;</div><div class="line">   flags = FLAG_IN_USE;</div><div class="line">   what = 0;</div><div class="line">   arg1 = 0;</div><div class="line">   arg2 = 0;</div><div class="line">   obj = null;</div><div class="line">   replyTo = null;</div><div class="line">   sendingUid = -1;</div><div class="line">   when = 0;</div><div class="line">   target = null;</div><div class="line">   callback = null;</div><div class="line">   data = null;</div><div class="line"></div><div class="line">   synchronized (sPoolSync) &#123;</div><div class="line">       if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">           next = sPool;</div><div class="line">           sPool = this;</div><div class="line">           sPoolSize++;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Android</code>是在调用了<code>recycle()</code>方法的时候实现了缓存, 在<code>obtain()</code>的时候取缓存如果没有, 那么就会创建新的对象. 缓存实现的方式是一个<code>单向链表</code>, 每次调用<code>recycle()</code>会把这个对象挂在<code>链表头</code>.看一下如下的图.</p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/fly-message.png" alt="img"></p>
<h3 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h3><h4 id="模式介绍-20"><a href="#模式介绍-20" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>使用频率很高, 也可以说是第三方SDK都会使用, 本质就是加上一个中间层的传递, 既可以做到统一一个高层类, 降低用户的使用成本, 也能屏蔽一些实现细节. 可能你不经意间使用很多次此模式, 只是没有在理论层面认知它的存在.</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行. 门面模式也就是<code>Facade模式</code>提供了一个高层次的接口.</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>为一个复杂子系统提供一个简单接口.</li>
<li>当需要构建一个层次结构的子系统时. 使用外观模式定义子系统的每层的入口点. 如果子系统相互依赖可以仅通过<code>facade</code>进行通信.</li>
</ul>
</li>
</ul>
<h4 id="模式范例-19"><a href="#模式范例-19" class="headerlink" title="模式范例"></a>模式范例</h4><p>以手机的外观模式为例</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/facade" target="_blank" rel="external">范例代码</a></p>
<p><img src="http://szysky.com/2016/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/UML_Facade.png" alt="img"></p>
<h4 id="Android源码对应实现-18"><a href="#Android源码对应实现-18" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>还是<code>Context</code>, <code>Context</code>对于开发者来说是最重要的高层接口. <code>Context</code>只是定义了很多接口的抽象类, 这些接口的功能实现并不是在<code>Context</code>以及子类中, 而是通过其他的子系统来完成的, 例如<code>startActivity()</code>的真正实现是通过<code>AMS</code>, 获取应用包信息是通过<code>PMS</code>. 而<code>Centext</code>只是做了一个高层次的统一封装.</p>
<p>好处显而易见, 对于开发者, 你只要知道这个高层类即可. 不需要知道太多的子系统就能完成开发.</p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="模式介绍-21"><a href="#模式介绍-21" class="headerlink" title="模式介绍"></a>模式介绍</h4><blockquote>
<p>结构性设计模式</p>
</blockquote>
<ul>
<li><p><code>定义</code>: 将抽象部分与实际部分分离, 使他们都可以独立地进行变化</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">场景</div></pre></td></tr></table></figure>
<p>:</p>
<ul>
<li>一个类存在两个独立变化的维度, 且这两个维度都需要进行扩展</li>
<li>对于那些不想使用继承或者因为多层次继承导致系统类的个数的急剧增加的系统, 也可以考虑使用此模式</li>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间更加灵活, 避免在两个层次之间建立静态的继承联系, 可以通过桥接模式使他们在抽象层建立一个关联关系</li>
</ul>
</li>
</ul>
<h4 id="模式范例-20"><a href="#模式范例-20" class="headerlink" title="模式范例"></a>模式范例</h4><p>以喝咖啡为例子, 一个咖啡馆中咖啡有四种, 分别是大杯加糖, 小杯加糖, 大杯无糖, 小杯无糖. 但是对于一杯咖啡来说这4种状态中实际上就是<code>两种变化</code>. 糖的状态和杯的状态.</p>
<p><a href="https://github.com/suzeyu1992/AlgorithmTraining/tree/master/src/design/bridge" target="_blank" rel="external">范例代码</a></p>
<p>代码使用以及结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[])&#123;</div><div class="line"></div><div class="line">   // 原汁原味</div><div class="line">   Ordinary ordinary = new Ordinary();</div><div class="line"></div><div class="line">   // 准备糖类</div><div class="line">   Sugar sugar = new Sugar();</div><div class="line"></div><div class="line">   // 大杯咖啡原味</div><div class="line">   LargeCoffee largeCoffee = new LargeCoffee(ordinary);</div><div class="line">   largeCoffee.makeCoffee();</div><div class="line"></div><div class="line">   // 小杯咖啡 原味</div><div class="line">   SmallCoffee smallCoffee = new SmallCoffee(ordinary);</div><div class="line">   smallCoffee.makeCoffee();</div><div class="line"></div><div class="line">   // 大杯咖啡 加糖</div><div class="line">   LargeCoffee larSugar = new LargeCoffee(sugar);</div><div class="line">   larSugar.makeCoffee();</div><div class="line"></div><div class="line">   // 小杯咖啡 加糖</div><div class="line">   LargeCoffee smallSugar = new LargeCoffee(sugar);</div><div class="line">   smallSugar.makeCoffee();</div><div class="line">&#125;</div><div class="line">//=========&gt;结果</div><div class="line">大杯的 原味 咖啡</div><div class="line">小杯的 原味 咖啡</div><div class="line">大杯的 加糖 咖啡</div><div class="line">大杯的 加糖 咖啡</div></pre></td></tr></table></figure>
<p>这里<code>CoffeeAdditives</code>相当于作为了<code>实现部分</code>, 而<code>Coffee</code>则对应抽象部分, 模式中定义所谓的<code>抽象</code>和<code>实现</code>实质上对应的是两个独立变化的维度. 也就是说<strong>任何多维度变化或者说多个树状类之间的耦合都可以使用桥接模式来解耦</strong>. 范例中的这两个基类, 并不一定就是所谓的对应的角色, 两者各自为一维度,独立变化.</p>
<p>如果需要增加口味的种类, 只需要继承<code>CoffeeAdditives</code>实现不同的子类即可完成加奶,加盐的新功能的添加. 不管是这两个角色谁变化了, 相对于对方而言都是独立的没有过多的交际.</p>
<h4 id="Android源码对应实现-19"><a href="#Android源码对应实现-19" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>桥接模式</code>在<code>Android</code>中应用的比较广泛. 一般都是作用于大范围.</p>
<ul>
<li><code>View</code>的具体控件都定义了不同类型控件的所拥有的基本属性和行为, 但是将它们绘制到屏幕上的部分是与<code>View</code>相关的功能类<code>DisplayList</code>,<code>Hardwarelayer</code>,<code>Canvas</code>负责. 这俩个部分可以看做桥接</li>
<li><code>Adapter</code>与<code>AdapterView</code>之间也可以看做是桥接</li>
<li><code>Window</code>和<code>WindowManager</code>之间的关系. <code>Window</code>和<code>PhoneWindow</code>构成窗口的抽象部分; <code>WindowManager</code>和<code>WindowManagerImpl</code>为实现部分; 实现部分的具体实现类<code>WMI</code>使用<code>WindowManagerGlobal</code>通过<code>IWindowManager</code>接口与<code>WMS</code>进行交互. 并由<code>WMS</code>完成具体的窗口工作.</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/java/设计模式之路/" data-id="cj7hnifcz000p6opj7qoqbsfj" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/java/设计模式之路/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-java/面试之Java篇" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/java/面试之Java篇/">面试之Java篇</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/java/面试之Java篇/">
            <time datetime="2017-09-12T00:04:44.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/java/">java</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/java/面试/">面试</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="关键字transient-volatile"><a href="#关键字transient-volatile" class="headerlink" title="关键字transient volatile"></a>关键字transient volatile</h3><p><strong>transient</strong></p>
<blockquote>
<p>加了该关键字的属性，不会被序列化。</p>
</blockquote>
<p>换句话说，这个字段仅存于调用者内存，而不会写到磁盘里持久化。<br>序列化原理：将待续列化的对象中的信息写入到磁盘或网络流中。序列化中的引用会进行“深度复制”，并且如果两个对象有共同的引用对象，且两个对象都写入同一个流，那么该引用对象不会重复创建，只会创建一次，并还原到虚拟机后引用的还是同一个对象。但是，如果写入不同的流中，那么两次创建的是完全不同还原对象。</p>
<p><strong>volatile</strong></p>
<p>每个线程访问堆中对象时，将堆中对象<code>load</code>到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆变量值有任何关系，而是直接修改副本变量值。<br>修改完之后，自动把线程变量副本的值写到对象在堆变量中。这样堆中对象的值就产生了变化。这些操作不是原子性的。<br>使用volatile修饰变量，JVM只是保证从内存加载到线程工作内存中的值是最新的。因此，即使使用volatile还是会存在并发情况。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">volatile static int a=0;</div><div class="line">//线程A和线程B同时执行</div><div class="line">a++;</div></pre></td></tr></table></figure>
<p>此时线程A拿到a的最新值0，线程B也拿到最新值0；但是，A执行a++后，值为1，B也同样计算得到a=1，它们再同时写回到堆内存，使得最后a的值为1，并不为2.</p>
<h3 id="Java1-7-1-8新特性"><a href="#Java1-7-1-8新特性" class="headerlink" title="Java1.7 1.8新特性"></a>Java1.7 1.8新特性</h3><p><strong>Java1.7</strong></p>
<p>（1）所有整数int， short，long，byte都可以用二进制表示，用0b开头。<br>（2）switch支持String类型。<br>（3）try-with-resource语句：在try()里面（括号里面）语句中声明一个或多个资源，try括号中的资源在最后会自动关闭.<br>（4）catch多个异常<br>（5）数字类型的下划线表示 更友好的表示方式，不过要注意下划线添加的一些标准，如:<br><code>long creditCardNumber = 1234_5678_9012_3456L;</code><br>(6)泛型实例的创建可以通过类型推断来简化 可以去掉后面new部分的泛型类型，只用&lt;&gt;就可以了</p>
<hr>
<p><strong>Java1.8</strong></p>
<p>(1)lambda表达式，最大的新增的特性<br>(2)允许给接口添加非抽象（即子类可以不用去实现）的方法，需要在方法前加default<br>(3)函数式接口。每个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所有也可以给函数式接口添加默认方法。我们可以将lambda表达式当成任意一个只包含一个抽象方法的接口类型。为确保你的接口满足这个要求，可以添加@FuntionalInterface注解。<br>(4)方法与构造函数引用。Java8允许使用<code>::</code>关键字来传递方法或者构造函数的引用。<br>(5) ……</p>
<h3 id="interface和abstract类区别"><a href="#interface和abstract类区别" class="headerlink" title="interface和abstract类区别"></a>interface和abstract类区别</h3><ol>
<li>继承方面: <code>abstract class</code>在Java中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个<code>interface</code>。</li>
<li>成员变量方面: 在<code>abstract class</code>中可以有自己的数据成员，也可以有<code>非abstarct</code>的方法，而在<code>interface</code>中，<strong>只能够有静态的不能被修改的数据成员</strong>（也就是必须是<code>static final</code>的，不过在<code>interface</code>中一般不定义数据成员），所有的方法都是<code>public abstract</code>的。</li>
<li>抽象方法方面: 实现抽象类和接口的类必须实现其中的所有抽象方法。抽象类中可以有非抽象方法，而接口中所有方法为抽象方法。</li>
<li>访问权限方面: 抽象类中的变量默认是<code>friendly</code>型，其值可以在子类中重新定义，也可以重新赋值。接口中定义的变量默认是<code>public static final</code>型，且必须给其赋初值，所以实现类中不能重新定义，也不能改变其值。</li>
<li>设计理念方面: <code>abstract class</code>和<code>interface</code>所反映出的设计理念不同。其实<code>abstract class</code>表示的是”<code>is-a</code>“关系，<code>interface</code>表示的是”<code>like-a</code>“关系。</li>
</ol>
<h3 id="XML解析方式DOM-SAX-PULL"><a href="#XML解析方式DOM-SAX-PULL" class="headerlink" title="XML解析方式DOM,SAX,PULL"></a>XML解析方式DOM,SAX,PULL</h3><p><strong>DOM</strong></p>
<p>通过DOM解析xml的好处就是:<br>我们可以随时访问到某个节点的相邻节点，并且对xml文档的插入也非常的方便</p>
<p>不好的地方就是:<br>其会将整个xml文档加载到内存中，这样会大大的占用我们的内存资源<br>对于手机来说，内存资源是非常非常宝贵的，所以在手机当中，通过DOM这种方式来解析xml是用的比较少的。使用DOM方式，类似JS，可以调用getElementsByTagName()、getChildNodes()等等方法。</p>
<hr>
<p><strong>SAX</strong></p>
<p><code>SAX</code>解析<code>xml</code>是基于事件流的处理方式的。因此每解析到一个标签，它并不会记录这个标签之前的信息，而我们只会知道当前这个标签的名字和它的属性，至于标签里面的嵌套，上层标签的名字这些都是无法知道的。SAX解析xml最重要的步骤就是定义一个我们自己的<code>Handler</code>处理类，我们可以让其继承 <code>DefaultHandler</code>这个类，然后在里面重写5个回调方法，分别是：</p>
<ul>
<li>startDocument</li>
<li>startElement</li>
<li>characters</li>
<li>endElement</li>
<li>endDocument</li>
</ul>
<hr>
<p><strong>PULL</strong></p>
<p><code>Pull</code>解析和<code>SAX</code>解析类似，都是基于事件流的方式，在<code>Android</code>中自带了<code>Pull</code>解析的jar包，所以我们不需要导入第三方的jar包了。Pull解析器和SAX解析器虽有区别但也有相似性。</p>
<p><strong>他们的区别为：</strong><br><code>SAX</code>解析器的工作方式是自动将事件推入注册的事件处理器进行处理，因此你不能控制事件的处理主动结束；而<code>Pull</code>解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。</p>
<p><strong>他们的相似性在运行方式上:</strong></p>
<blockquote>
<p>Pull解析器也提供了类似SAX的事件（开始文档<code>START_DOCUMENT</code>和结束文档<code>END_DOCUMENT</code>，开始 元素 <code>TART_TAG</code>和结束元素<code>END_TAG</code>，遇到元素内容<code>TEXT</code>等），但需要调用<code>next()</code>方法提取它们（主动提取事件）。调用parser.nextText();方法获取标签内的文本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); </div><div class="line">XmlPullParser xmlPullParser = factory.newPullParser(); </div><div class="line">xml.setInput(new StringReader(xmlData)); </div><div class="line"> </div><div class="line">int eventType = xmlPullParser.getEventType(); </div><div class="line"> </div><div class="line">while(eventType!=XmlPullParser.END_DOCUMENT)&#123; </div><div class="line">    String nodeName = xmlPullParser.getName(); </div><div class="line">    switch(eventType)&#123; </div><div class="line">        case XmlPullParser.START_DOCUMENT:&#123;&#125; </div><div class="line">        case XmlPullParser.START_TAG:&#123;&#125; </div><div class="line">        case XmlPullParser.END_TAG:&#123;&#125;  </div><div class="line">    &#125;  </div><div class="line">    eventType = parser.next(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="foreach和for循环"><a href="#foreach和for循环" class="headerlink" title="foreach和for循环"></a>foreach和for循环</h3><p><strong>foreach</strong></p>
<p>foreach本质是通过迭代器遍历，有如下特点：</p>
<ul>
<li>无需获取容器大小</li>
<li>需要创建额外的迭代器变量</li>
<li>遍历期间得到的是对象，没有索引位置信息，因此没办法将指定索引位置对象替换为新对象</li>
</ul>
<hr>
<p><strong>for</strong></p>
<ul>
<li>for需要获取容器大小，如果计算大小比较耗时，那么for循环效率肯定低下</li>
<li>for循环是根据容器大小防止越界，因此每次循环需要进行一次比较</li>
</ul>
<p><strong>效率</strong></p>
<p>由于每次循环时，使用<code>for</code>循环都得计算容器大小并且还需要比较，因此，在对容器里面的每个元素进行遍历时，<code>foreach</code>效率更高。</p>
<p>这个结论也不是绝对的，在选择<code>for</code>，<code>foreach</code>的时候，应该考虑以下几点：</p>
<ul>
<li>如果只是读数据，优先选择foreach，因为效率高，而且代码简单，方便；</li>
<li>如果要写数据，即替换指定索引位置处的对象，就只能选择for了，而且选择第二个for效率更高！</li>
</ul>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><blockquote>
<p>NIO是非阻塞的IO，Java NIO由一下几个核心部分组成：<code>Channels</code>、<code>Buffers</code>、<code>Selectors</code>。</p>
</blockquote>
<p>虽然Java NIO中除此之外还有很多类和组件，但是Channel，Buffer和Selector构成了核心的API。其他组件如Pipe和FileLock,只不过是与其他三个核心组件共同使用的工具类。</p>
<ul>
<li><code>Channel</code>：基本上所有的IO在NIO中都从一个Channel开始，Channel有点像流。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。Channel和Buffer有好多类型，Channel主要有：FileChannel、DataGramChannel、SocketChannel、ServerSocketChannel。涵盖了UDP和TCP网络的IO以及文件IO。</li>
<li><code>Buffer：</code>NIO主要的Buffer有：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer这些Buffer涵盖了你能通过IO发送的基本数据类型。</li>
<li><code>Selector</code>：允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如一个聊天服务器中。要使用Selector，得先向Selector注册Channel然后调用它的select()方法。这个方法会一直堵塞知道某个注册的通道有事件就绪。一旦这个方法返回线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</li>
</ul>
<hr>
<p><strong>NIO的使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// 注册</div><div class="line">// 创建Selector对象   </div><div class="line">Selector sel = Selector.open();   </div><div class="line">// 创建可选择通道，并配置为非阻塞模式   </div><div class="line">ServerSocketChannel server = ServerSocketChannel.open();   </div><div class="line">server.configureBlocking(false);   </div><div class="line"> </div><div class="line">// 绑定通道到指定端口   </div><div class="line">ServerSocket socket = server.socket();   </div><div class="line">InetSocketAddress address = new InetSocketAddress(port);   </div><div class="line">socket.bind(address);   </div><div class="line"> </div><div class="line">// 向Selector中注册感兴趣的事件   </div><div class="line">server.register(sel, SelectionKey.OP_ACCEPT);    </div><div class="line">return sel;</div><div class="line"></div><div class="line"></div><div class="line">// 处理</div><div class="line">try &#123;    </div><div class="line">    while(true) &#123; </div><div class="line">        // 该调用会阻塞，直到至少有一个事件发生 </div><div class="line">        selector.select(); </div><div class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); </div><div class="line">        Iterator&lt;SelectionKey&gt; iter = keys.iterator(); </div><div class="line">        while (iter.hasNext()) &#123; </div><div class="line">            SelectionKey key = (SelectionKey) iter.next(); </div><div class="line">            iter.remove(); </div><div class="line">            process(key); </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125; catch (IOException e) &#123;    </div><div class="line">    e.printStackTrace();   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>ByteBuffer使用</strong></p>
<p>创建ByteBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//（1）使用allocate()静态方法</div><div class="line">ByteBuffer buffer=ByteBuffer.allocate(256);</div><div class="line">//以上方法将创建一个容量为256字节的ByteBuffer,如果发现创建的缓冲区容量太小,唯一的选择就是重新创建一个大小合适的缓冲区.</div><div class="line"></div><div class="line">//（2）通过包装一个已有的数组来创建如下,通过包装的方法创建的缓冲区保留了被包装数组内保存的数据.</div><div class="line">ByteBuffer buffer=ByteBuffer.wrap(byteArray);</div><div class="line">// 如果要将一个字符串存入ByteBuffer,可以如下操作:</div><div class="line">String sendString=&quot;你好,服务器. &quot;; </div><div class="line">ByteBuffer sendBuffer=ByteBuffer.wrap(sendString.getBytes(&quot;UTF-16&quot;));</div></pre></td></tr></table></figure>
<p>缓冲区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">buffer.flip();</div><div class="line">//这个方法用来将缓冲区准备为数据传出状态,执行以上方法后,输出通道会从数据的开头而不是末尾开始.回绕保持缓冲区中的数据不变,只是准备写入而不是读取.</div><div class="line">buffer.clear();</div><div class="line">//这个方法实际上也不会改变缓冲区的数据,而只是简单的重置了缓冲区的主要索引值.不必为了每次读写都创建新的缓冲区,那样做会降低性能.相反,要重用现在的缓冲区,在再次读取之前要清除缓冲区.</div></pre></td></tr></table></figure>
<p>3.3 一个简单例子<br>使用通道和ByteBuffer实现文件复制功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public void copy(String from, String to) throws IOException &#123; </div><div class="line">    // 分配缓存 </div><div class="line">    ByteBuffer buff = ByteBuffer.allocate(128); </div><div class="line">    // 输入、输出通道 </div><div class="line">    FileChannel fin = null; </div><div class="line">    FileChannel fout = null; </div><div class="line">    try &#123; </div><div class="line">        // 初始化输入输出通道 </div><div class="line">        fin = new FileInputStream(from).getChannel(); </div><div class="line">        fout = new FileOutputStream(to).getChannel(); </div><div class="line">        // 从输入通道循环读取数据到缓存，并把缓存数据写入到输出通道 </div><div class="line">        while (fin.read(buff) != -1) &#123; </div><div class="line">            buff.flip(); </div><div class="line">            fout.write(buff); </div><div class="line">            buff.clear(); </div><div class="line">        &#125; </div><div class="line">    &#125; catch (FileNotFoundException e) &#123; </div><div class="line"> </div><div class="line">    &#125; finally &#123; </div><div class="line">        try &#123; </div><div class="line">            if (fin != null) &#123; </div><div class="line">                fin.close(); </div><div class="line">            &#125; </div><div class="line">            if (fout != null) &#123; </div><div class="line">                fout.close(); </div><div class="line">            &#125; </div><div class="line">        &#125; catch (IOException e) &#123; </div><div class="line">            throw e; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line">//如果需要将ByteBuffer转为FloatBuffer，则可以通过调用：</div><div class="line">ByteBuffer buff = ByteBuffer.allocate(128); </div><div class="line">buff.asFloatBuffer()</div><div class="line">//ByteBuffer转为其他的Buffer，如:CharBuffer、DoubleBuffer、IntBuffer、LongBuffer、ShortBuffer，都有对应的asXXXBuffer()方法。</div></pre></td></tr></table></figure>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p><strong>什么是反射</strong></p>
<p>反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，容许程序在运行时加载、探知、使用编译期间未知的class。即Java的反射机制可以加载一个运行时才得知名称的class，获得其完整结构。所谓的反射机制就是Java语言在运行时拥有一项自观的能力，即程序可以在运行时访问、检测和修改它本身状态或行为的一种能力。通过这种能力可以彻底的了解自身的情况为下一步的动作做准备。</p>
<p><strong>反射操作的对象</strong></p>
<p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息保存着每个对象所属的类足迹。虚拟机利用运行时信息选择相应的方法执行。然而，可以通过专门的Java类访问这些信息。保存这些信息的类称为Class，泛型形式为Class。Class是反射机制的基础，反射API通过操作Class来获取其完整结构。</p>
<p>Java的反射机制的实现要借助于4个类：<code>Class</code>，<code>Constructor</code>，<code>Field</code>，<code>Method</code>，通过这四个对象我们可以粗略的看到一个类的各个组成部分</p>
<p><strong>反射提供的功能</strong></p>
<p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<p>两种编译：</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象,即通过。</li>
<li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</li>
</ul>
<p>反射机制优缺点:</p>
<ul>
<li>优点：就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中 它的灵活性就表现的十分明显。</li>
<li>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。并且它饶过了源码，会干扰原来的内部逻辑。</li>
</ul>
<p>反射机制中常用API函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">// getClass()方式：</div><div class="line">/** </div><div class="line">* Object类中的getClass()方法返回一个Class类型的实例 </div><div class="line">*/ </div><div class="line">Boolean var1 = true; </div><div class="line">Class&lt;?&gt; classType1 = var1.getClass(); </div><div class="line">//输出：class java.lang.Boolean  </div><div class="line">System.out.println(classType1);</div><div class="line"></div><div class="line">//（2）T.class方式：</div><div class="line">/** </div><div class="line">*  </div><div class="line">* 运用T.class 语法(T是任意的Java类型) </div><div class="line">*/ </div><div class="line">Class&lt;?&gt; classType2 = Boolean.class; </div><div class="line">//输出：class java.lang.Boolean  </div><div class="line">System.out.println(classType2);</div><div class="line"></div><div class="line">//（3）Class.forName()方式：</div><div class="line">/** </div><div class="line">*  </div><div class="line">* 运用static method Class.forName()（使用时应该提供异常处理器） </div><div class="line">*/ </div><div class="line">Class&lt;?&gt; classType3 = Class.forName(&quot;java.lang.Boolean&quot;); </div><div class="line">//输出：class java.lang.Boolean  </div><div class="line">System.out.println(classType3);</div><div class="line"></div><div class="line">//（4）TYPE语法方式：</div><div class="line">/** </div><div class="line">*  </div><div class="line">* 运用primitive wrapper classes的TYPE语法 </div><div class="line">* 这里返回的是原生类型,和Boolean.class返回的不同 </div><div class="line">*/ </div><div class="line"> </div><div class="line">Class&lt;?&gt; classType4 = Boolean.TYPE; </div><div class="line">//输出：boolean  </div><div class="line">System.out.println(classType4);</div><div class="line">//注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。虚拟机为每个类型管理一个Class对象。因此，可以用==运算符实现两个类对象比较的操作。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// Class常用的方法：</div><div class="line">/** </div><div class="line"> * 返回类的名字 </div><div class="line"> * 如：java.lang.String </div><div class="line"> */ </div><div class="line">String getName(); </div><div class="line"> </div><div class="line">/** </div><div class="line"> * 快速地创建一个类的实例 </div><div class="line"> * 调用默认构造器，如果该类没有默认构造器，抛出异常 </div><div class="line"> * 如果要为构造器提供参数， </div><div class="line"> * 使用java.lang.reflect.Constructor中的newInstance方法 </div><div class="line"> */ </div><div class="line">Object newInstance(); </div><div class="line"> </div><div class="line">/** </div><div class="line">*  返回超类 </div><div class="line">*/ </div><div class="line">getSuperclass(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 给定名称的形式分别返回类支持的public域、方法和构造器数组， </div><div class="line">* 其中包括超类的公有成员 </div><div class="line">*/ </div><div class="line">Field[] getFields(); </div><div class="line">Method[] getMethods(); </div><div class="line">Constructor&lt;?&gt;[] getConstructors(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 获取指定的域、方法、构造函数 </div><div class="line">*/ </div><div class="line">Field getField(String name) </div><div class="line">Method getMethod(String name, Class&lt;?&gt;... parameterTypes) </div><div class="line">Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</div></pre></td></tr></table></figure>
<hr>
<p>使用反射分析类</p>
<p>一个类主要由修饰符，域，构造器，方法组成，而Field、Method、Constructor类，分别用于描述类的域、方法和构造器。另外java.lang.reflect包中的Modifier类可以分析访问修饰符。那么用它们就可以分析类。</p>
<ul>
<li>Class getDeclaringClass() 返回一个用于描述类中定义的构造器、方法或域的Class对象</li>
<li>String getName() 返回相应条目的名称</li>
<li>int getModifiers() 返回整型数值，用不同的位开关描述访问修饰符的使用状况</li>
<li>Constructor Class[] getExceptionTypes() 返回一个用于描述方法抛出的异常类型的Class对象数组</li>
<li>Class[] getParameterTypes() 返回一个用于描述参数类型的Class对象数组</li>
<li>Field Class getType() 用于返回描述域所属类型的Class类型对象</li>
<li>static String toString(int modifiers) 返回对应modifiers位设置的修饰符的字符串表示</li>
<li>static boolean isXXX(int modifiers) 检测方法名中对应的修饰符在modifiers中的值</li>
</ul>
<p>访问权限问题：</p>
<p>由于反射机制的默认行为受限于Java的访问控制，比如，访问私有的方法，字段，除非拥有访问权限，否则Java安全机制允许查看任意对象有哪些域，而不允许读它们的值（读取将抛异常）。然而如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，就需要调用Field、Method、Constructor对象的<code>setAccessible()</code>方法。</p>
<ul>
<li>void setAccessible(boolean flag) 为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置</li>
<li>boolean isAccessible() 返回反射对象的可访问标志的值</li>
<li>static void setAccessible(AccessibleObject[] array, boolean flag) 一种设置对象数组可访问标志的快捷方法</li>
</ul>
<h3 id="Object的公用方法"><a href="#Object的公用方法" class="headerlink" title="Object的公用方法"></a>Object的公用方法</h3><p>Object的共有方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//创建并返回此对象的一个副本。 </div><div class="line">protected  Object    clone() ; </div><div class="line"> </div><div class="line">//指示其他某个对象是否与此对象“相等” </div><div class="line">boolean    equals(Object obj) ; </div><div class="line"> </div><div class="line">/** </div><div class="line">* 当垃圾回收器确定不存在对该对象的更多引用时， </div><div class="line">* 由对象的垃圾回收器调用此方法 </div><div class="line">*/ </div><div class="line">protected void finalize() ; </div><div class="line"> </div><div class="line">//返回此 Object 的运行时类 </div><div class="line">Class getClass(); </div><div class="line"> </div><div class="line">//返回该对象的哈希码值 </div><div class="line">int hashCode(); </div><div class="line"> </div><div class="line">//唤醒在此对象监视器上等待的单个线程 </div><div class="line">void notify(); </div><div class="line"> </div><div class="line">//唤醒在此对象监视器上等待的所有线程 </div><div class="line">void notifyAll(); </div><div class="line"> </div><div class="line">//返回该对象的字符串表示 </div><div class="line">String toString(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 在其他线程调用此对象的 notify() </div><div class="line">* 方法或 notifyAll() 方法前，导致当前线程等待 </div><div class="line">*/ </div><div class="line">void wait(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法， </div><div class="line">* 或者超过指定的时间量前，导致当前线程等待 </div><div class="line">*/ </div><div class="line">void wait(long timeout); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法， </div><div class="line">* 或者其他某个线程中断当前线程，或者已超过某个实际时间量前， </div><div class="line">* 导致当前线程等待 </div><div class="line">*/ </div><div class="line">void wait(long timeout, int nanos);</div></pre></td></tr></table></figure>
<h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><p><strong>父类方面</strong></p>
<p>这两个方法来自不同的类分别是：<code>sleep</code>来自<code>Thread</code>类；<code>wait</code>来自<code>Object</code>类。</p>
<p>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</p>
<p><strong>锁方面</strong></p>
<p>最主要是<code>sleep</code>方法没有释放锁，而<code>wait</code>方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br><code>sleep</code>不出让系统资源；<code>wait</code>是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般<code>wait</code>不会加时间限制，因为如果<code>wait</code>线程的运行资源不够，再出来也没用，要等待其他线程调用<code>notify/notifyAll</code>唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。<code>sleep(milliseconds)</code>可以用时间指定使它自动唤醒过来，如果时间不到只能调用<code>interrupt()</code>强行打断。<br><code>Thread.sleep(0)</code>的作用是“触发操作系统立刻重新进行一次CPU竞争”。</p>
<p><strong>使用范围方面</strong></p>
<p>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">synchronized(x)&#123;  </div><div class="line">      x.notify()  </div><div class="line">     //或者wait()  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BlockingQueue-CountDownLatch"><a href="#BlockingQueue-CountDownLatch" class="headerlink" title="BlockingQueue CountDownLatch"></a>BlockingQueue CountDownLatch</h3><p><code>BlockingQueue</code></p>
<p><code>BlockingQueue</code>接口定义了一种阻塞的<code>FIFO queue</code>，每一个<code>BlockingQueue</code>都有一个容量：<br>当容量满时，往<code>BlockingQueue</code>中添加数据时会造成阻塞,当容量为空时，取元素操作会阻塞。<br><code>BlockingQueue</code>有两个实现类：<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>。</p>
<p><code>ArrayBlockingQueue</code></p>
<ul>
<li>一个由数组支持的有界阻塞队列</li>
<li>按先进先出原则排序</li>
<li>一旦创建好这个数组，就不能再增加其容量</li>
<li>试图向已满的队列中放入元素会导致操作受阻塞</li>
<li>试图从空的队列中提取元素将导致类似的阻塞。</li>
</ul>
<p><code>LinkedBlockingQueue</code></p>
<ul>
<li>LinkedBlockingQueue是一个基于已链接节点的、范围任意的blocking queue的实现</li>
<li>此队列按FIFO（先进先出）排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素</li>
<li>新元素插入到队列的尾部，并且队列检索操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低.</li>
<li>可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。</li>
<li>如果未指定容量，则它等于Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点 ，容量范围可以在构造方法参数中指定作为防止队列过度扩展。</li>
<li>此对象是 线程阻塞-安全的</li>
<li>不接受null元素</li>
<li>实现了Collection和Iterator接口的所有可选 方法</li>
<li>在JDK5/6中，LinkedBlockingQueue和ArrayBlocingQueue等对象的poll(long timeout, TimeUnit unit)存在内存泄露Leak的对象AbstractQueuedSynchronizer.Node，据称JDK5会在Update12里Fix，JDK6会在Update2里Fix</li>
</ul>
<p><strong>ArrayBlockingQueue和LinkedBlockingQueue的区别</strong></p>
<ul>
<li>队列中锁的实现不同<br><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；<br><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock<br>在生产或消费时操作不同</li>
<li><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；<br><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为Node进行插入或移除，会影响性能</li>
<li>队列大小初始化方式不同<br><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小；<br><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></li>
</ul>
<hr>
<p><code>CountDownLatch</code></p>
<p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。主要方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public CountDownLatch(count); </div><div class="line">public void countDown(); </div><div class="line">public void await() ;</div></pre></td></tr></table></figure>
<p>构造方法指定了计数的次数。countDown方法，当前线程调用此方法则计数减一。await方法，调用该方法会一直阻塞当前线程，直到计时器的值为0.</p>
<h3 id="锁的等级"><a href="#锁的等级" class="headerlink" title="锁的等级"></a>锁的等级</h3><p><code>synchronized</code>在修饰代码块的时候需要一个<code>reference</code>对象作为锁的对象. 在修饰实例方法的时候默认是当前实例对象作为锁的对象. 在修饰类方法（静态方法）时候默认是当前类的<code>Class</code>对象作为锁的对象.</p>
<p><code>synchronized</code>使用总结如下</p>
<ul>
<li>对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性</li>
<li>在静态方法上的锁，和实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。</li>
<li>关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单例的，就能互斥。</li>
<li>静态方法加锁，能和所有其他静态方法加锁的 进行互斥</li>
<li>静态方法加锁，和xx.class 锁效果一样，直接属于类的</li>
</ul>
<h3 id="synchronized-lock-reentrantLock"><a href="#synchronized-lock-reentrantLock" class="headerlink" title="synchronized lock reentrantLock"></a>synchronized lock reentrantLock</h3><p><strong>synchronized</strong></p>
<p>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，它是在 软件层面依赖JVM实现同步。</p>
<p><code>synchronized 方法的缺陷：</code></p>
<blockquote>
<p>若将一个大的方法声明为synchronized将会大大影响效率，典型地，若将线程类的方法run()声明为synchronized，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何synchronized方法的调用都永远不会成功。</p>
</blockquote>
<p>解决方案: 通过 synchronized关键字来声明synchronized 块。</p>
<hr>
<p><strong>Lock</strong></p>
<p><code>Lock</code>接口实现提供了比使用<code>synchronized</code>方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的<code>Condition</code>对象。在硬件层面依赖特殊的CPU指令实现同步更加灵活。</p>
<p><strong>什么是Condition</strong></p>
<p><code>Condition</code>接口将<code>Object</code>监视器方法（<code>wait</code>、<code>notify</code> 和 <code>notifyAll</code>）分解成截然不同的对象，以便通过将这些对象与任意 Lock实现组合使用，为每个对象提供多个等待<code>set</code>（wait-set）。其中，<code>Lock</code>替代了<code>synchronized</code>方法和语句的使用，<code>Condition</code>替代了 <code>Object</code>监视器方法的使用。</p>
<p>虽然<code>synchronized</code>方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁。例如，某些遍历并发访问的数据结果的算法要求使用”hand-over-hand”或”chain locking”：获取节点 A的锁，然后再获取节点B的锁，然后释放A并获取C，然后释放B并获取D，依此类推。Lock接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用这种技术。</p>
<p>随着灵活性的增加，也带来了更多的责任。不使用块结构锁就失去了使用<code>synchronized</code>方法和语句时会出现的锁自动释放功能。在大多数情况下，应该使用以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lock l = ...; //lock接口的实现类对象 </div><div class="line">l.lock(); </div><div class="line">try &#123; </div><div class="line">    // access the resource protected by this lock </div><div class="line">&#125; finally &#123; </div><div class="line">    l.unlock(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>java.util.concurrent.locks</code>包中有很多<code>Lock</code>的实现类，常用的有<code>ReentrantLock</code>、<code>ReadWriteLock</code>（实现类ReentrantReadWriteLock）.它们是具体实现类，不是Java语言关键字。</p>
<hr>
<p><strong>ReentrantLock</strong></p>
<p>一个可重入的互斥锁<strong>Lock</strong>，它具有与使用<code>synchronized</code>方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p>
<p>最典型的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class X &#123; </div><div class="line">   private final ReentrantLock lock = new ReentrantLock(); </div><div class="line">   // ... </div><div class="line"> </div><div class="line">   public void m() &#123;  </div><div class="line">     lock.lock();  // block until condition holds </div><div class="line">     try &#123; </div><div class="line">       // ... method body </div><div class="line">     &#125; finally &#123; </div><div class="line">       lock.unlock() </div><div class="line">     &#125; </div><div class="line">   &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>重入性：指的是同一个线程多次试图获取它所占有的锁，请求会成功。当释放锁的时候，直到重入次数清零，锁才释放完毕。</p>
</blockquote>
<p><code>ReentrantLock</code>的<code>lock</code>机制有2种，<strong>忽略中断锁</strong>和<strong>响应中断锁</strong>，这给我们带来了很大的灵活性。比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候<code>ReentrantLock</code>就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（<code>synchronized</code>原语就是如此）；第二，B线程中断自己（或者别的线程中断它），<code>ReentrantLock</code> 处理了这个中断，并且不再等待这个锁的到来，完全放弃。</p>
<p><strong>ReentrantLock相对于synchronized多了三个高级功能</strong></p>
<ol>
<li>等待可中断: 在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.<code>tryLock(long timeout, TimeUnit unit)</code></li>
<li>公平锁: 按照申请锁的顺序来依次获得锁称为公平锁.<code>synchronized</code>的是非公平锁,<code>ReentrantLock</code>可以通过构造函数实现公平锁.<code>new RenentrantLock(boolean fair)</code>公平锁和非公平锁。这2种机制的意思从字面上也能了解个大概：即对于多线程来说，公平锁会依赖线程进来的顺序，后进来的线程后获得锁。而非公平锁的意思就是后进来的锁也可以和前边等待锁的线程同时竞争锁资源。对于效率来讲，当然是非公平锁效率更高，因为公平锁还要判断是不是线程队列的第一个才会让线程获得锁。</li>
<li>绑定多个<code>Condition</code>: 通过多次<code>newCondition</code>可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过<code>await()</code>，<code>signal()</code></li>
</ol>
<hr>
<p><strong>synchronized和lock的用法与区别</strong></p>
<ol>
<li><code>synchronized</code>是托管给JVM执行的，而<code>Lock</code>是<code>Java</code>写的控制锁的代码。</li>
<li><code>synchronized</code>原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。　</li>
<li><code>Lock</code>用的是乐观锁方式。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li>
<li><code>ReentrantLock</code>必须在<code>finally</code>中释放锁，否则后果很严重，编码角度来说使用<code>synchronized</code>更加简单，不容易遗漏或者出错。</li>
<li><code>ReentrantLock</code>提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而<code>synchronized</code>一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。</li>
<li><code>synchronized</code>的话，锁的范围是整个方法或<code>synchronized</code>块部分；而<code>Lock</code>因为是方法调用，可以跨方法，灵活性更大</li>
</ol>
<p>一般情况下都是用<code>synchronized</code>原语实现同步，除非下列情况使用<code>ReentrantLock</code>:</p>
<ul>
<li>某个线程在等待一个锁的控制权的这段时间需要中断</li>
<li>需要分开处理一些wait-notify，<code>ReentrantLock</code>里面的<code>Condition</code>应用，能够控制<code>notify</code>哪个线程</li>
<li>具有公平锁功能，每个到来的线程都将排队等候</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>线程池基础</strong></p>
<p>配置线程池一般如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor( </div><div class="line">                    CORE_POOL_SIZE,MAXIMUM_POOL_SIZE,KEEP_ALIVE,TimeUnit.SECONDS, </div><div class="line">                      sPoolWorkQueue,sThreadFactory </div><div class="line">                      );</div></pre></td></tr></table></figure>
<p>当一个任务加入到线程池时:</p>
<ol>
<li>如果此时线程池中的数量小于<code>corePoolSize</code>，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量等于 <code>corePoolSize</code>，但是缓冲队列 <code>workQueue</code>未满，那么任务被放入缓冲队列。</li>
<li>如果此时线程池中的数量大于<code>corePoolSize</code>，缓冲队列<code>workQueue</code>满，并且线程池中的数量小于<code>maximumPoolSize</code>，新建线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量大于<code>corePoolSize</code>，缓冲队列<code>workQueue</code>满，并且线程池中的数量等于<code>maximumPoolSize</code>，那么通过 <code>handler</code>所指定的策略来处理此任务。</li>
<li>当线程池中的线程数量大于 <code>corePoolSize</code>时，如果某线程（非核心线程）空闲时间超过<code>keepAliveTime</code>，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li>
</ol>
<p>也就是,处理任务的优先级为：</p>
<ul>
<li>核心线程corePoolSize</li>
<li>任务队列workQueue</li>
<li>最大线程maximumPoolSize</li>
</ul>
<p>如果三者都满了，使用handler处理被拒绝的任务（一般为抛出java.util.concurrent.RejectedExecutionException异常）</p>
<hr>
<p><strong>线程池类型</strong></p>
<p>线程池主要有以下4种：</p>
<ol>
<li><code>FixedThreadPool</code>：线程数量固定的线程池，线程处于空闲状态时不会被回收，除非线程被关闭。当所有线程都处于活动状态时，新的任务都会处于等待状态，直到有线程空闲出来。</li>
<li><code>CachedThreadPool</code>：线程数量不固定，只有非核心线程，可以放任意多个线程（Integer.MAX_VALUE）,线程池里所有线程处于活动状态时，创建新的线程处理新来的任务。否则利用闲置的线程处理新任务。线程池里空闲线程有超时机制，时长为60秒。</li>
<li><code>ScheduledThreadPool</code>：核心线程数量是固定的，非核心线程是没有限制。当非核心线程闲置时会被立即回收。</li>
<li><code>SingleThreadExector</code>：内部只有一个核心线程，确保所有任务在同一个线程中按顺序执行。</li>
</ol>
<hr>
<p><strong>线程池使用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Runnable task=new Runnable()&#123; </div><div class="line">     Public void run()&#123; </div><div class="line">       //TODO ....... </div><div class="line">    &#125; </div><div class="line">&#125;; </div><div class="line"> </div><div class="line">//FixedThreadPool使用 </div><div class="line">ExecutorService fixedThreadPool=Executors.newFixedThreadPool(4); </div><div class="line">fixedThreadPool.execute(task); </div><div class="line"> </div><div class="line">//CachedThreadPool的使用 </div><div class="line">ExecutorService cachedThreadPool=Executors.newCachedThreadPool(); </div><div class="line">cachedThreadPool.execute(task);  </div><div class="line"> </div><div class="line">//ScheduledThreadPool的使用 </div><div class="line">ExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(4); </div><div class="line">//2000ms后执行task </div><div class="line">scheduledThreadPool.schedule(task,2000,TimeUnit.MILLISECONDS); </div><div class="line">//延迟10ms后，每隔1000ms执行一次task </div><div class="line">scheduledTheadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);  </div><div class="line"> </div><div class="line">//SingleThreadExector的使用 </div><div class="line">ExecutorService sigleThreadPool=Executors.newSingleThreadExecutor(); </div><div class="line">fixedThreadPool.execute(task);</div></pre></td></tr></table></figure>
<hr>
<p><strong>线程池的优点</strong></p>
<ul>
<li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销</li>
<li>能有效控制线程池的最大并发数，避免大量线程之间因互相抢占系统资源而导致阻塞。</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ul>
<h3 id="线程-ThreadLocal"><a href="#线程-ThreadLocal" class="headerlink" title="线程 ThreadLocal"></a>线程 ThreadLocal</h3><p>创建新线程的两种方法:</p>
<ul>
<li>通过实现<code>Runable</code>接口,再将<code>Runnable</code>作为<code>Thread</code>的构造函数参数创建Thread对象</li>
<li>通过继承Thread类本身。</li>
</ul>
<p>其实，Java中真正能创建新线程的只有Thread对象，通过Runnable的方式，最终还是需要通过Thread对象来创建线程。</p>
<p>当<code>JVM</code>启动时，通常都会有单个非守护线程（它通常会调用某个指定类的main方法）。<code>JVM</code>会继续执行线程，直到下列任一情况出现时为止：</p>
<ul>
<li>调用了Runtime类的<code>exit</code>方法，并且安全管理器允许退出操作发生。</li>
<li>非守护线程的所有线程都已停止运行，无论是通过从对run方法的调用中返回，还是通过抛出一个传播到run方法之外的异常。</li>
</ul>
<hr>
<p><strong>ThreadLocal设计理念和作用</strong></p>
<p><strong>设计理念</strong></p>
<p>为每个线程创造一个资源的复本。将每一个线程存取数据的行为加以隔离，实现的方法就是给予每个线程一个特定空间来保管该线程所独享的资源。</p>
<p><strong>作用</strong></p>
<p>为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。</p>
<p><strong>ThreadLocal使用</strong></p>
<p><code>ThreadLocal</code>实例通常是类中的<code>private static</code>字段，它们希望将状态与某一个线程相关联。每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且<code>ThreadLocal</code>实例是可访问的，在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 首先创建ThreadLocal对象：</div><div class="line">ThreadLocal&lt;Integer&gt; mValue=new ThreadLocal&lt;Integer&gt;();</div><div class="line">// 然后在线程中调用set和get方法来设置和获取值，例如：</div><div class="line">mValue.set(1); </div><div class="line">int value=mValue.get();</div></pre></td></tr></table></figure>
<p><strong>实现原理</strong></p>
<p>简单地说，就是在<code>ThreadLocal</code>类中有一个<code>Map</code>，用于存储每一个线程的变量的副本。<code>Map</code>的<code>Key</code>是<code>Thread</code>，<code>value</code>就是副本的值。</p>
<p>深入源码去看，<code>ThreadLocal</code>把线程和线程局部变量存在<code>ThreadLocalMap</code>中，而<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类，我们来看看<code>ThreadLocalMap</code>的部分源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; </div><div class="line"> </div><div class="line">    Object value; </div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; </div><div class="line">        super(k); </div><div class="line">        value = v; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>Map</code>的<code>key</code>是<code>ThreadLocal</code>对象的弱引用，当要抛弃掉<code>ThreadLocal</code>对象时，垃圾收集器会忽略这个<code>key</code>的引用而清理掉<code>ThreadLocal</code>对象 。</p>
<p>那么到底是<code>ThreadLocal</code>还是<code>Thread</code>持有<code>ThreadLocalMap</code>对象的引用呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* ThreadLocal values pertaining to this thread.  </div><div class="line"> * This map is maintained by the ThreadLocal class. </div><div class="line"> */ </div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure>
<p><code>ThreadLocalMap</code>变量属于<code>Thread</code>的内部属性,不同的<code>Thread</code>拥有完全不同的<code>ThreadLocalMap</code>变量.<code>Thread</code>中的<code>ThreadLocalMap</code>变量的值是在<code>ThreadLocal</code>对象进行set或者get操作时创建的.　 　　 在创建<code>ThreadLocalMap</code>之前,会首先检查当前<code>Thread</code>中的<code>ThreadLocalMap</code>变量是否已经存在,如果不存在则创建一个；如果已经存在,则使用当前<code>Thread</code>已创建的<code>ThreadLocalMap</code>.　</p>
<p><strong>ThreadLocal的接口方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * 返回此线程局部变量的初始值 </div><div class="line"> * </div><div class="line"> * 线程第一次使用 get() 方法访问变量时将调用此方法，但如果线程之前调用 </div><div class="line"> * 了 set(T) 方法，则不会对该线程再调用 initialValue 方法。通常，此 </div><div class="line"> * 方法对每个线程最多调用一次，但如果在调用 get() 后又调用了  </div><div class="line"> * remove()，则可能再次调用此方法。 </div><div class="line"> *  </div><div class="line"> * 该实现返回 null；如果程序员希望线程局部变量具有 null 以外的值，则 </div><div class="line"> * 必须为 ThreadLocal 创建子类，并重写此方法。通常将使用匿名内部类完 </div><div class="line"> * 成此操作。 </div><div class="line">*/ </div><div class="line">protected T initialValue(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 返回此线程局部变量的当前线程的值 </div><div class="line">*  </div><div class="line">* 如果变量没有用于当前线程的值，则先 </div><div class="line">* 将其初始化为调用initialValue() 方法返回的值。 </div><div class="line">*/ </div><div class="line">public T get(); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 将此线程局部变量的当前线程副本中的值设置为指定值 </div><div class="line">*  </div><div class="line">* 大部分子类不需要重写此方法，它们只依靠 initialValue() 方法 </div><div class="line">* 来设置线程局部变量的值 </div><div class="line">*/ </div><div class="line">public void set(T value); </div><div class="line"> </div><div class="line">/** </div><div class="line">* 移除此线程局部变量当前线程的值 </div><div class="line">*  </div><div class="line">* 如果此线程局部变量随后被当前线程 读取，且这期间当前线程没有 </div><div class="line">* 设置其值，则将调用其 initialValue() 方法重新初始化其值。 </div><div class="line">* 这将导致在当前线程多次调用 initialValue 方法。 </div><div class="line">*/ </div><div class="line">public void remove();</div></pre></td></tr></table></figure>
<p>如果希望线程局部变量初始化其它值，那么需要自己实现ThreadLocal的子类并重写该方法，通常使用一个内部类对ThreadLocal进行实例化。</p>
<p><strong>ThreadLocal如何做到线程安全</strong></p>
<p>从上面的分析我们可以得出：</p>
<ul>
<li>因为每个<code>Thread</code>在进行对象访问时,访问的都是各自线程自己的<code>ThreadLocalMap</code>，所以保证了<code>Thread</code>与<code>Thread</code>之间的数据访问隔离。</li>
<li>不同的<code>ThreadLocal</code>实例操作同一<code>Thread</code>时，<code>ThreadLocalMap</code>在存储时采用当前<code>ThreadLocal</code>的实例作为<code>key</code>来保证数据访问隔离（上面源码Entry处可以看出）。　</li>
</ul>
<p><strong>TheadLocal模式与同步机制的区别</strong></p>
<ol>
<li>实现机制: 同步机制采用了“以时间换空间”的方式,提供一份变量,让不同的线程排队访问.而ThreadLocal采用了“以空间换时间”的方式,为每一个线程都提供一份变量的副本,从而实现同时访问而互不影响。</li>
<li>同步共享方面: Java中的synchronized是一个保留字,它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性.在同步机制中,通过对象的锁机制保证同一时间只有一个线程访问变量.此时,被用作“锁机制”的变量是多个线程共享的；而ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本，从而隔离了多个线程的数据，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。　 　 3.使用场合同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式。而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制。如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal。</li>
</ol>
<h3 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h3><blockquote>
<p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
</blockquote>
<p><strong>强引用(StrongReference)</strong></p>
<p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如代码String s=”abc”中变量s就是字符串对象”abc”的一个强引用。只要你给强引用对象s赋空值null,该对象就可以被垃圾回收器回收。因为该对象此时不再含有其他强引用。</p>
<p><strong>软引用（SoftReference）</strong></p>
<p>如果内存足够，不回收；如果内存不足，则回收。软引用可用来实现内存敏感的高速缓存。软引用可以和引用队列<code>ReferenceQueue</code>联合使用，如果软引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">String str=new String(&quot;Test&quot;);</div><div class="line">ReferenceQueue&lt;String&gt; rq=new ReferenceQueue&lt;String&gt;(); </div><div class="line">SoftReference&lt;String&gt; sr=new SoftReference&lt;String&gt;(str,rq); </div><div class="line">str = null;         // 将强引用撤销</div><div class="line"></div><div class="line">// 或者</div><div class="line">SoftReference&lt;String&gt; sr=new SoftReference&lt;String&gt;(str); </div><div class="line">str=null;//将强引用撤掉</div><div class="line"></div><div class="line">// 取出对象</div><div class="line">String s = sr.get();</div></pre></td></tr></table></figure>
<p>如果被回收，则s为null，否则，s即为str所指引的对象”Test”</p>
<p><strong>弱引用(WeakReference)</strong></p>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象，弱引用非常适合存储元数据。另一个使用弱引用的例子是<code>WeakHashMap</code>，它是除<code>HashMap</code>和<code>TreeMap</code>之外，Map接口的另一种实现。<code>WeakHashMap</code>有一个特点：<code>Map</code>中的键值(keys)都被封装成弱引用，也就是说一旦强引用被删除，<code>WeakHashMap</code>内部的弱引用就无法阻止该对象被垃圾回收器回收。弱引用的使用跟软引用使用方式相同，只是将<code>SoftReference</code>替换为<code>WeakReference</code>。</p>
<p><strong>虚引用(PhantomReference)</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用 必须 和引用队列 （<code>ReferenceQueue</code>）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p><strong>static静态修饰符</strong></p>
<p>在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的。<code>static</code>修饰符表示静态的，在类加载时<code>JVM</code>会把它放到<strong>方法区</strong>，被本类以及本类的所有实例所共用。在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间。如果一个被所有实例共用的方法被申明为<code>static</code>，那么就可以节省空间，不用每个实例初始化的时候都被分配到内存。</p>
<p>我们比较常见的<code>static</code>修饰是在静态变量和静态方法中。它们可以直接通过类名来访问。下面我们看看关于静态代码块和静态类。</p>
<hr>
<p><strong>静态代码块</strong></p>
<p>说起静态代码块，就不得不说类初始化。类初始化是类加载的最后一步，前面类加载过程中，除了加载阶段用户可以通过自定义类加载器参与以外，其余动作都是虚拟机主导和控制。到了初始化阶段，才是真正执行类中定义Java程序代码。</p>
<p>准备阶段中，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划初始化类变量。初始化过程其实是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是按照语句在源文件中出现的顺序。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。</p>
<p><code>&lt;clinit&gt;()</code>方法与类构造函数（或者说实例构造器()）不同，他不需要显式地调用父类构造器，虚拟机会保证子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</p>
<hr>
<p><strong>静态类</strong></p>
<ul>
<li>只能在内部类中定义静态类</li>
<li>静态内部类与外层类绑定，即使没有创建外层类的对象，它一样存在。</li>
<li>静态类的方法可以是静态的方法也可以是非静态的方法，静态的方法可以在外层通过静态类调用，而非静态的方法必须要创建类的对象之后才能调用。</li>
<li>只能引用外部类的static成员变量（也就是类变量）。</li>
<li>如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态的。</li>
</ul>
<h3 id="集合的区别"><a href="#集合的区别" class="headerlink" title="集合的区别"></a>集合的区别</h3><p><strong>Map</strong></p>
<blockquote>
<p>键映射到值的对象。</p>
</blockquote>
<p>有如下特点:</p>
<ul>
<li>一个映射不能包含重复的键</li>
<li>每个键最多只能映射到一个值。</li>
<li>某些映射实现可明确保证其顺序，如TreeMap类</li>
<li>另一类映射实现则不保证顺序如HashMap</li>
</ul>
<p><code>Map</code>可以将<code>key</code>序列、<code>value</code>序列单独抽取出来。使用<code>keySet()</code>抽取key序列，将所有<code>key</code>生成一个<code>Set</code>。使用<code>values</code>抽取<code>value</code>序列，将所有value生成一个<code>Collection</code>，为什么key生成<code>Set</code>，而value生成<code>Collection</code>？因为key总是独一无二，<code>value</code>允许重复。</p>
<p>Map接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Set&lt;K&gt; keySet(); </div><div class="line">Collection&lt;V&gt; values(); </div><div class="line"> </div><div class="line">V remove(Object key); </div><div class="line">V get(Object key); </div><div class="line">V put(K key, V value); </div><div class="line">void putAll(Map&lt;? extends K, ? extends V&gt; m); </div><div class="line"> </div><div class="line">boolean containsKey(Object key); </div><div class="line">boolean containsValue(Object value); </div><div class="line"> </div><div class="line">void clear(); </div><div class="line">int size(); </div><div class="line">boolean isEmpty();</div></pre></td></tr></table></figure>
<p><strong>Set</strong></p>
<p>不能包含重复元素的<code>Collection</code>。如下特征：</p>
<ul>
<li>Set不包含满足e1.euqals(e2)</li>
<li>最多包含一个null元素(这里是指HashSet,TreeSet不支持插入null)</li>
<li>不可随机访问包含的元素</li>
<li>Set没有同步方法。</li>
</ul>
<p>Set接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">boolean add(E e); </div><div class="line">boolean remove(Object o); </div><div class="line"> </div><div class="line">boolean addAll(Collection&lt;? extends E&gt; c); </div><div class="line">boolean removeAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">boolean contains(Object o); </div><div class="line">boolean containsAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">boolean retainAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">Object[] toArray(); </div><div class="line">T[] toArray(T[] a); </div><div class="line"> </div><div class="line">void clear(); </div><div class="line">int size(); </div><div class="line">boolean isEmpty();</div></pre></td></tr></table></figure>
<hr>
<p><strong>List</strong></p>
<p>如下特征：</p>
<ul>
<li>可随机访问包含的元素</li>
<li>元素是有序的</li>
<li>可在任意位置增、删元素</li>
<li>允许重复元素。</li>
</ul>
<p>List接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">E get(int index); </div><div class="line">E set(int index, E element); </div><div class="line"> </div><div class="line">boolean add(E e); </div><div class="line">boolean remove(Object o); </div><div class="line"> </div><div class="line">boolean addAll(Collection&lt;? extends E&gt; c); </div><div class="line">boolean removeAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">boolean contains(Object o); </div><div class="line">boolean containsAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">int indexOf(Object o); </div><div class="line">int lastIndexOf(Object o); </div><div class="line"> </div><div class="line">boolean retainAll(Collection&lt;?&gt; c); </div><div class="line"> </div><div class="line">Object[] toArray(); </div><div class="line"> </div><div class="line">void clear(); </div><div class="line">int size(); </div><div class="line">boolean isEmpty();</div></pre></td></tr></table></figure>
<p><strong>Queue</strong></p>
<p>队列，特点是先进先出。</p>
<p><code>Queue</code>在使用时尽量避免<code>Collection</code>的<code>add()</code>和<code>remove()</code>方法，而是要使用<code>offer()</code>来加入元素，使用<code>poll</code>来获取并移出元素。他们的优点是通过返回值可以判断成功与否。<code>add()</code>和<code>remove()</code>方法在失败的时候会抛出异常。</p>
<p>如果使用而不移出该元素，使用<code>element()</code>或者<code>peek()</code>方法。值得注意的是<code>LinkedList</code>类实现了<code>Queue</code>接口，因此我们可以把<code>LinkedList</code>当初<code>Queue</code>来用。</p>
<p><code>Queue</code>实现通常不允许插入<code>null</code>元素。尽管某些实现（如LinkedList）并不禁止将null插入到Queue中，即使在允许null的实现中，也不应将null插入到Queue中，因为<code>null</code>也作<code>poll</code>方法的一个特殊返回值，表明队列不包含元素。</p>
<p>Queue接口的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//插入新元素到队列，如果插入成功，返回true， </div><div class="line">//如果队列已满，抛出IllegalStateException异常 </div><div class="line">boolean add(E e); </div><div class="line"> </div><div class="line">//插入新元素到队列，如果插入成功返回true </div><div class="line">//如果队列已满，返回false，但不抛出异常 </div><div class="line">boolean offer(E e); </div><div class="line"> </div><div class="line">//返回第一个元素，并将该元素从队列中删除 </div><div class="line">//如果队列为空，抛出异常 </div><div class="line">E remove(); </div><div class="line"> </div><div class="line">//返回第一个元素，并将该元素从队列中删除 </div><div class="line">//如果队列为空，返回null </div><div class="line">E poll(); </div><div class="line"> </div><div class="line">//返回队列的第一个元素， </div><div class="line">//如果队列为空，抛异常 </div><div class="line">E element(); </div><div class="line"> </div><div class="line">//返回队列的第一个元素， </div><div class="line">//如果队列为空，返回null </div><div class="line">E peek();</div></pre></td></tr></table></figure>
<p><code>Queue</code>接口有子接口<code>BlockingQueue</code>和<code>Deque</code>，<code>BlockingQueue</code>表示阻塞队列；<code>Deque</code>是双向队列，即可以从两端插入元素。<code>BlockingQueue</code>有如下几个实现类：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
</ul>
<p>主要看看BlockingQueue的两个新方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//插入一个新元素，如果队列已满，则一直等待（阻塞） </div><div class="line">void put(E e) throws InterruptedException; </div><div class="line"> </div><div class="line">//返回队列的第一个元素并将该元素从队列里删除，如果队里为空，则一直等待（阻塞） </div><div class="line">E take() throws InterruptedException;</div></pre></td></tr></table></figure>
<p><code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>是阻塞队列的不同实现，即一个是通过数组方式，一个是通过链表的方式实现的阻塞队列。</p>
<p>有个特殊的接口<code>BlockingDeque</code>，<code>BlockingDeque</code>既实现了<code>BlockingQueue</code>又实现了<code>Deque</code>,而<code>BlockingDeque</code>的实现类有</p>
<ul>
<li>LinkedBlockingDeque</li>
<li>前面我们说到，接口Deque是双向队列。接口Deque添加了如下新方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void addFirst(E e); </div><div class="line">void addLast(E e); </div><div class="line">boolean offerFirst(E e); </div><div class="line">boolean offerLast(E e); </div><div class="line">E removeFirst(); </div><div class="line">E removeLast(); </div><div class="line">E pollFirst(); </div><div class="line">E pollLast(); </div><div class="line">E getFirst(); </div><div class="line">E getLast(); </div><div class="line">E peekFirst(); </div><div class="line">E peekLast();</div></pre></td></tr></table></figure>
<hr>
<p><strong>Stack</strong></p>
<p><code>Stack</code>继承自<code>Vector</code>（可增长的对象数组），也是同步的。他通过五个操作对类Vector进行了扩展，允许将向量视为堆栈。他提供了通常的<code>push</code>和<code>pop</code>操作，以及取堆栈顶点的<code>peek</code>方法。测试堆栈是否为空的<code>empty</code>方法、在堆栈中查找项并确定对堆栈顶距离的<code>search</code>方法。</p>
<p>Stack类的部分函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public E push(E item); </div><div class="line">public synchronized E pop(); </div><div class="line"> </div><div class="line">//返回栈顶的元素，但不将其出栈 </div><div class="line">public synchronized E peek(); </div><div class="line">public synchronized int search(Object o); </div><div class="line">public boolean empty();</div></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常类继承关系图:</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/throwable.png" alt="img"></p>
<p><strong>Throwable</strong></p>
<p><code>Throwable</code>类是所有错误或异常的超类。只有当对象是此类或其子类之一的实例时，才能通过<code>JVM</code>或者是通过<code>throw</code>语句抛出；另外<code>catch</code>子句中的参数类型也必须是该类型。</p>
<p><code>Throwable</code>类及其子类有两个构造方法:</p>
<ul>
<li>不带参数</li>
<li>带有 String 参数，此参数可用于生成详细消息。</li>
</ul>
<p><code>Throwable</code>包含了其线程创建时线程执行堆栈的快照。它还包含了给出有关错误更多信息的消息字符串。<code>Java</code>将可抛出(Throwable)的结构分为三种类型：</p>
<ul>
<li>错误(Error)</li>
<li>运行时异常(RuntimeException)</li>
<li>被检查的异常(Checked Exception)</li>
</ul>
<hr>
<p><strong>Error</strong></p>
<p><code>Error</code>是<code>Throwable</code>的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。和<code>RuntimeException</code>一样， 编译器也不会检查<code>Error</code>。当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误，程序本身无法修复这些错误的。 　</p>
<hr>
<p><strong>Exception</strong></p>
<p><code>Exception</code>类及其子类是<code>Throwable</code>的一种形式，它指出了合理的应用程序想要捕获的条件。对于可以恢复的条件使用被检查异常（Exception的子类中除了<code>RuntimeException</code>之外的其它子类），对于程序错误使用运行时异常。　</p>
<p><code>ClassNotFoundException</code></p>
<p>当应用程序试图使用以下方法通过字符串名加载类时：</p>
<ul>
<li>Class 类中的 forName 方法。</li>
<li>ClassLoader 类中的 findSystemClass 方法。</li>
<li>ClassLoader 类中的 loadClass 方法。</li>
</ul>
<p>但是没有找到具有指定名称的类的定义，抛出该异常。</p>
<p><code>CloneNotSupportedException</code></p>
<p>当调用<code>Object</code>类中的<code>clone</code>方法复制对象，但该对象的类无法实现<code>Cloneable</code>接口时，抛出该异常。重写<code>clone</code>方法的应用程序也可能抛出此异常，指示不能或不应复制一个对象。</p>
<p><code>IOException</code></p>
<p>当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</p>
<ul>
<li>EOFException: 当输入过程中意外到达文件或流的末尾时，抛出此异常。此异常主要被数据输入流用来表明到达流的末尾。注意：其他许多输入操作返回一个特殊值表示到达流的末尾，而不是抛出异常。</li>
<li>FileNotFoundException: 当试图打开指定路径名表示的文件失败时，抛出此异常。在不存在具有指定路径名的文件时，此异常将由 <code>FileInputStream</code>、<code>FileOutputStream</code>和<code>RandomAccessFile</code>构造方法抛出。如果该文件存在，但是由于某些原因不可访问，比如试图打开一个只读文件进行写入，则此时这些构造方法仍然会抛出该异常。</li>
<li>MalformedURLException: 抛出这一异常指示出现了错误的URL。或者在规范字符串中找不到任何合法协议，或者无法解析字符串。　</li>
<li>UnknownHostException: 指示主机IP地址无法确定而抛出的异常。</li>
</ul>
<hr>
<p><strong>RuntimeException</strong></p>
<p>是那些可能在Java虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的<code>RuntimeException</code>的任何子类都无需在<code>throws</code>子句中进行声明。<code>Java</code>编译器不会检查它。当程序中可能出现这类异常时，还是会编译通过。虽然<code>Java</code>编译器不会检查运行时异常，但是我们也可以通过<code>throws</code>进行声明抛出，也可以通过<code>try-catch</code>对它进行捕获处理。</p>
<ul>
<li><p><code>ArithmeticException</code>：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</p>
</li>
<li><p><code>ClassCastException</code>：当试图将对象强制转换为不是实例的子类时，抛出该异常。例如：Object x = new Integer(0);</p>
</li>
<li><p><code>IllegalArgumentException</code>：抛出的异常表明向方法传递了一个不合法或不正确的参数。</p>
</li>
<li><p><code>IllegalStateException</code>：在非法或不适当的时间调用方法时产生的信号。换句话说，即Java环境或Java应用程序没有处于请求操作所要求的适当状态下。</p>
</li>
<li><p><code>IndexOutOfBoundsException</code>：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 应用程序可以为这个类创建子类，以指示类似的异常。</p>
</li>
<li><p><code>NoSuchElementException</code>：由<code>Enumeration</code>的<code>nextElement</code>方法抛出，表明枚举中没有更多的元素。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NullPointerException</div></pre></td></tr></table></figure>
<p>：当应用程序试图在需要对象的地方使用null时，抛出该异常。这种情况包括：</p>
<ol>
<li>调用null对象的实例方法。</li>
<li>访问或修改null对象的字段。</li>
<li>将null作为一个数组，获得其长度。</li>
<li>将null作为一个数组，访问或修改其时间片。</li>
<li>将null作为Throwable值抛出。</li>
<li>应用程序应该抛出该类的实例，指示其他对null对象的非法使用。</li>
</ol>
</li>
</ul>
<hr>
<p><strong>SOF（堆栈溢出 StackOverflow）</strong></p>
<blockquote>
<p>当应用程序递归太深而发生堆栈溢出时，抛出StackOverflowError错误。</p>
</blockquote>
<p>程序中一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过默认大小而导致溢出。我在8G的内存下，用eclipse进行递归调用测试，递归11410次后抛SOF异常</p>
<p>栈溢出的原因：</p>
<ul>
<li>递归调用</li>
<li>大量循环或死循环</li>
<li>全局变量是否过多</li>
<li>数组、List、map数据过大</li>
</ul>
<hr>
<p><strong>Android的OOM（Out Of Memory）</strong></p>
<blockquote>
<p>当内存占有量超过了虚拟机的分配的最大值时就会产生内存溢出（VM里面分配不出更多的page）</p>
</blockquote>
<p>一般出现情况：</p>
<ul>
<li>加载的图片太多或图片过大时</li>
<li>分配特大的数组</li>
<li>内存相应资源过多没有来不及释放。</li>
</ul>
<p>解决方法：</p>
<ol>
<li>在内存引用上做处理</li>
<li>对图片进行边界压缩, 配合软引用使用</li>
<li>显示的调用GC来回收内存例如<code>if(bitmapObject.isRecycled()==false) //如果没有回收 bitmapObject.recycle();</code></li>
<li>优化Dalvik虚拟机的堆内存分配<ul>
<li>增强堆内存的处理效率<code>VMRuntime.getRuntime().setTargetHeapUtilization(0.75);</code></li>
<li>设置堆内存的大小: <code>VMRuntime.getRuntime().setMinimumHeapSize(6 * 1024 * 1024);</code> 设置最小heap内存为6MB大小</li>
</ul>
</li>
<li>用LruCache和AsyncTask解决</li>
</ol>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">double floor(double a);     // 向下取整</div><div class="line"></div><div class="line">double random();            // 产生随机数取值范围[0,1)</div><div class="line"></div><div class="line">double ceil();              // 向上取整</div><div class="line"></div><div class="line">long round(double a);       // 四舍五入</div></pre></td></tr></table></figure>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>equals与==的区别</strong></p>
<ul>
<li><code>==</code>：对于基本类型，比较的是它们的值。对于复合类型（直接在堆中分配空间），比较的是它们在内存中的地址。</li>
<li><code>equals</code>：该方法属于Object，而所有类都继承于Object这个基类，因此每个类都有这个方法。Object类中equals的默认实现是return (this == obj);，即默认是比较对象的内存地址。但在库中的一些类会覆盖重写equals这个方法，如：<code>String</code>、<code>Integer</code>、<code>Date</code>这些类中equals有自身的实现，而不再是比较类在堆内存中的地址。String中的equals，首先判断==，如果地址相同，那一定是返回true；如果地址不相同，再比较字符串字面值是否相等。</li>
</ul>
<hr>
<p><strong>Switch能否用string做参数?</strong></p>
<p>在Java7之前，<code>switch</code>只支持<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>及其对应的封装类，以及<code>Enum</code>类型，在Java 7中，String类型被加上。</p>
<hr>
<p><strong>String、StringBuffer与StringBuilder的区别</strong></p>
<ol>
<li>字符串是否可变<ul>
<li>String: 使用字符数组保存字符串：private final char value[];关键字final决定了String对象不可变。</li>
<li>StringBuilder和StringBuffer继承自AbStractStringBuilder类，AbstractStringBuilder类也是使用字符数组保存字符串：char[] value;没有final，可知这两个对象都是可变的。</li>
</ul>
</li>
<li>线程安全<ul>
<li>String对象不可变，也就可以理解为常量，显然线程安全。</li>
<li>StringBuffer对方法加了同步锁，因此是线程安全的。</li>
<li>StringBuilder没有加锁，是非线程安全的。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>String 常用的函数</strong></p>
<p><strong>split</strong></p>
<p>split函数原型为：<code>String[] split(String regex)</code>。参数<code>regex</code>不是一个简单的字符串，而是一个正则表达式。因此，对于正则表达式中的关键字你需要使用转意符<code>\</code>，例如.和<code>|</code>都是转义字符,必须得加<code>&quot;\\&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如果用.作为分隔的话,必须写为String.split(&quot;\\.&quot;)，而不能直接这样String.split(&quot;.&quot;);</div><div class="line">如果用|作为分隔的话,必须写为String.split(&quot;\\|&quot;)，而不能直接这样String.split(&quot;|&quot;);</div><div class="line">如果在一个字符串中有多个分隔符,可以用|作为连字符，比如待分割的字符串为String s=&quot;my; name,is HuaChao&quot;，如果希望把单词提取出来（以标点符号和空格为分割字符），可以写为：s.split(&quot;,| |;&quot;);注意， 两个|之间有空格，&quot;,| |;&quot;表示，以,或空格以及;分割字符串。</div></pre></td></tr></table></figure>
<p><strong>replace、replaceAll、replaceFirst</strong></p>
<ul>
<li>replace:原型为String replace(char oldChar, char newChar) ，即将所有的oldChar字符替换为newChar字符</li>
<li>replace:原型为String replace(CharSequence target, CharSequence replacement) ，即将所有的target字符串替换为replacement字符串</li>
<li>replaceAll：原型为String replaceAll(String regex, String replacement)，参数regex从名称可以看出，它是一个正则表达式。replacement为替换的新字符串，即将原字符串中，所有满足正则表达式regex的部分替换为replacement</li>
<li>replaceFirst：原型为String replaceFirst(String regex, String replacement) ，跟replaceAll很像，只不过replaceFirst是替换第一个满足正则表达式regex的部分。</li>
</ul>
<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws Exception &#123; </div><div class="line">    String s=&quot;my.name.is.HuaChao&quot;;  </div><div class="line">    System.out.println(s.replace(&apos;.&apos;, &apos;*&apos;));  </div><div class="line">    System.out.println(s.replace(&quot;.&quot;, &quot;*&quot;));  </div><div class="line">    System.out.println(s.replaceAll(&quot;.&quot;, &quot;*&quot;));  </div><div class="line">    System.out.println(s.replaceFirst(&quot;.&quot;, &quot;*&quot;));  </div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">my*name*is*HuaChao </div><div class="line">my*name*is*HuaChao </div><div class="line">****************** </div><div class="line">*y.name.is.HuaChao</div></pre></td></tr></table></figure>
<p>运行结果中，很好理解，第1个replace里面的参数是字符，不是正则表达式，replace会把所有的.字符替换为<code>*</code>；同样，第二个replace里面的参数是字符串，不是正则表达式；而replaceAll中，第一个参数是正则表达式，第二个参数是字符串，而正则表达式中的<code>.</code>是表示任意字符，因此，会把所有的字符替换为<code>*</code>；最后replaceFirst，只替换第一个字符。</p>
<hr>
<p><strong>正则表达式</strong></p>
<p>如果我们需要从字符串中匹配出满足我们自定义的正则表达式的部分，就可以通过使用Pattern这个类。我们先看一个实际应用，假设我们要取出一个字符串中所有的字母，并显式出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123; </div><div class="line">    String dataStr = &quot;---&gt;我是干扰字符&lt;---M12v,L23f,d34&quot;; </div><div class="line">    Pattern pattern = Pattern.compile(&quot;[a-zA-Z]&quot;); </div><div class="line">    Matcher matcher = pattern.matcher(dataStr); </div><div class="line">    // 遍历匹配正则表达式的字符串 </div><div class="line">    while (matcher.find()) &#123; </div><div class="line">        // s为匹配的字符串 </div><div class="line">        String s = matcher.group(); </div><div class="line">        System.out.println(s);  </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">//  M v L f d</div></pre></td></tr></table></figure>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><strong>ArrayList</strong></p>
<p>ArrayList类的定义为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;,RandomAccess,Cloneable,Serializable</div></pre></td></tr></table></figure>
<p>特性:</p>
<ul>
<li>可变大小的数组</li>
<li>非线程安全</li>
<li>当更多的元素加入到ArrayList时，其大小会动态的增长。每次增长的空间是其size的50%。初始容量是10.</li>
<li>允许null元素</li>
</ul>
<hr>
<p><strong>LinkedList</strong></p>
<p>LinkedList类定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<p>LinkedList有如下特性：</p>
<ul>
<li>是一个双链表</li>
<li>非线程安全</li>
<li>在添加和删除元素元素时具有比ArrayList更好的性能</li>
<li>LinkedList还实现了Queue接口（非直接实现，是通过实现Queue的子接口Deque间接实现Queue），该接口比List提供了更多方法。包括从尾部添加元素：<code>offer(E)</code>、返回第一个元素但不出队:<code>peek()</code>、返回第一个元素并出队：<code>poll()</code>等。</li>
<li>允许null元素</li>
</ul>
<p>由于LinkedList不同步,可以通过如下方式转化为同步的List</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list= Collections.synchronizedList(new LinkedList());</div></pre></td></tr></table></figure>
<hr>
<p><strong>Vector</strong></p>
<p>Vector类定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable</div></pre></td></tr></table></figure>
<p>Vector类有如下特性：</p>
<ul>
<li>Vector和ArrayList类似，但属于强同步类。</li>
<li>比ArrayList多了线程安全。</li>
<li>默认每次动态增加空间是当前大小的2倍；如果在构造函数Vector(int initialCapacity, int capacityIncrement)中指定了capacityIncrement，每次动态增加的大小为capacityIncrement</li>
<li>初始容量是10.</li>
<li>允许null元素</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>首先各个子类的继承关系</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/map.png" alt="img"></p>
<p>类的定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//HashMap </div><div class="line">public class HashMap&lt;K,V&gt; </div><div class="line">    extends AbstractMap&lt;K,V&gt; </div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable&#123;&#125; </div><div class="line"> </div><div class="line">//Hashtable </div><div class="line">public class Hashtable&lt;K,V&gt; </div><div class="line">    extends Dictionary&lt;K,V&gt; </div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;&#125; </div><div class="line"> </div><div class="line">//ConcurrentHashMap </div><div class="line">public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; </div><div class="line">        implements ConcurrentMap&lt;K, V&gt;, Serializable &#123;&#125; </div><div class="line"> </div><div class="line">//TreeMap </div><div class="line">public class TreeMap&lt;K,V&gt; </div><div class="line">    extends AbstractMap&lt;K,V&gt; </div><div class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;&#125; </div><div class="line"> </div><div class="line">//LinkedHashMap </div><div class="line">public class LinkedHashMap&lt;K,V&gt; </div><div class="line">    extends HashMap&lt;K,V&gt; </div><div class="line">    implements Map&lt;K,V&gt;&#123;&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>HashMap内部实现</strong></p>
<p><code>HashMap</code>本质是数组加链表。根据<code>key</code>取得<code>hash</code>值，然后计算出数组下标，如果多个<code>key</code>对应到同一个下标，就用链表串起来。新插入的在前面。不保证映射顺序，特别是它不保证该顺序恒久不变。里面存放的是<code>Map.Entry</code>类，该类本质是个键值对。</p>
<ul>
<li><code>HashMap</code>数据结构：根据<code>key</code>的<code>hashCode</code>来计算<code>hash</code>值，只要<code>hashCode</code>相同，计算出来的<code>hash</code>值就一样。出现<code>hash</code>冲突，就采用链表的方式，将相同<code>hash</code>值的对象用链表连接。</li>
<li><code>HashMap</code>存取：<code>put</code>新元素时，首先根据<code>key</code>的<code>hashCode</code>重新计算<code>hash</code>值（二次hash），根据这个新的<code>hash</code>值得到这个元素在数组的位置（下标），如果数组已经存放其他元素，那么该位置元素以链表形式存放，新加入的放链头，最先加入的在链尾。根据Key的hashCode二次hash的算法函数hash（int h），此方法加入了高位计算，防止低位不变而高位变化时造成的<code>hash</code>冲突。函数的具体实现如下(<code>&gt;&gt;&gt;</code>表示右移1位并忽略符号位，空位以0补齐。而<code>&gt;&gt;</code>表示右移不忽略符号位，即相当于除以2)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static int hash(int h)&#123; </div><div class="line">    h ^= (h&gt;&gt;&gt;20)^(h&gt;&gt;&gt;12); </div><div class="line">    return h^(h&gt;&gt;&gt;7)^(h&gt;&gt;&gt;4); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时得到了二次hash，二次hash的主要目的就是将高位引入计算，使得计算出来的位置值与高位也有关。将二次hash值对数组长度取模运算这样一来元素的分布就比较均匀。但是，模运算的消耗比较大。在<code>HashMap</code>中这样做：调用<code>indexFor(int h,int length)</code>方法计算该对象应该保存在<code>table</code>数组的那个索引处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h,int length)&#123; </div><div class="line">    return h &amp; (length-1); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法非常巧妙，它通过<code>h&amp;(table.length-1)</code>来得到该对象的保存位，而<code>HashMap</code>底层数组的长度总是<code>2的n次方</code>（即只有一位上是1，其他位上是0），这是<code>HashMap</code>在速度上的优化。</p>
<p><code>HashMap</code>扩容（<code>resize</code>、<code>rehash</code>）：由上面可知，每次数组扩容为原来的两倍。扩容会带来一个性能上的问题，就是每次扩容需要重新计算每个元素的位置。那么<code>HashMap</code>什么时候进行扩容呢？这个跟<code>loadFactor</code>（加载因子）有关，默认情况下<code>loadFactor</code>为<code>0.75</code>.即当<code>HashMap</code>元素超过<code>length*0.75</code>时，需要<strong>扩大一倍</strong>，然后重新计算元素在数组的位置，这是一个非常消耗性能的操作，所以，如果已经预知<code>HashMap</code>中元素个数那么预设元素个数能够有效提高<code>HashMap</code>性能。</p>
<ul>
<li><code>Fail-Fast</code>(快速失败)机制： <code>HashMap</code>不是线程安全的，因此在使用迭代器过程中，其他线程修改了Map，那么将抛出<code>ConcurrentModificationException</code>异常，这就是<code>fail-fast</code>策略。实现原理为，通过<code>modCount</code>域，<code>modCount</code>顾名思义就是修改次数，对<code>HashMap</code>内容的修改都将增加这个值，在迭代器初始化过程会将这个值赋给迭代器的<code>expectedModCount</code>，迭代过程中，判断<code>modCount</code>跟<code>expectedModCount</code>是否相等，如果不相等就表示已经有其他的线程修改了Map。</li>
</ul>
<hr>
<p><strong>ConcurrentHashMap</strong></p>
<p>在HashMap的基础上,<code>ConcurrentHashMap</code>将数据分为多个<code>segment</code>，默认<code>16</code>个，然后每次操作对一个<code>segment</code>加锁，避免多线程锁的几率，提高并发效率。</p>
<hr>
<p><strong>HashTable和HashMap</strong></p>
<ul>
<li><code>HashMap</code>父类为<code>AbstractMap</code>，方法不同步，K，V可为null，添加新的kv，若k相同，则将新的v覆盖。</li>
<li><code>HashTable</code>父类为<code>Dictionary</code>，方法同步，k，v不可为null，添加新的kv，若k相同，则将新的v覆盖。</li>
</ul>
<hr>
<p><strong>TreeMap、HashMap、LinkedHashMap的区别</strong></p>
<ul>
<li><code>TreeMap</code> 实现<code>SortMap</code>接口，能够把它保存的记录根据键排序，默认是<strong>按键值升序排序</strong>，也可以指定排序的比较器（通过构造器传入<code>Comparator</code>对象），当用<code>Iterator</code>遍历<code>TreeMap</code>时，得到的记录是排过序的。</li>
<li><code>LinkedhashMap</code>，是<code>HashMap</code>子类，保存了记录的插入顺序，在用<code>iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的，如果需要输出的顺序和输入的相同，那么<code>LinkedHashMap</code>可以实现。LRU算法里面使用到<code>LinkedHashMap</code>,之所以用这个类而不用<code>LinkedList</code>，主要是<code>LinkedHashMap</code>取值速度快，免去了<code>LinkedList</code>遍历搜索过程。</li>
</ul>
<h3 id="Collections和Arrays"><a href="#Collections和Arrays" class="headerlink" title="Collections和Arrays"></a>Collections和Arrays</h3><p>由于<code>collections</code>主要针对<code>Collection</code>对象, 先看看<code>Collection</code>子类继承结构</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/collection.png" alt="img"></p>
<hr>
<p><strong>Collections</strong></p>
<p><code>Java.util.Collections</code>是一个包装类（工具类、帮助类），主要是针对集合类操作。它包含各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，有如下功能：</p>
<ol>
<li>二分搜索算法进行查找</li>
<li>为Collection添加不定数量参数作为子元素</li>
<li>将一个List所有元素复制到另一个</li>
<li>判断两个元素是否有相同的元素:</li>
<li>获取Collection最大、最小元素</li>
<li>用于对集合中的元素进行排序</li>
<li>将线程不安全的Map、Set转为线程安全的对象</li>
<li>返回单例</li>
</ol>
<p>部分函数原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">static boolean addAll(Collection&lt;? super T&gt; c, T... elements); </div><div class="line">static int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c); </div><div class="line">static void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src); </div><div class="line">//如果没有相同的元素返回true </div><div class="line">static boolean disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2); </div><div class="line">//最大最小值 </div><div class="line">static T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp); </div><div class="line">static T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp); </div><div class="line">//逆序 </div><div class="line">static Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp) </div><div class="line">//返回只包含指定对象的单例Set </div><div class="line">static Set&lt;T&gt; singleton(T o); </div><div class="line">//返回只包含指定对象的单例列表 </div><div class="line">static List&lt;T&gt; singletonList(T o); </div><div class="line">//返回只包含指定对象的单例Map </div><div class="line">static Map&lt;K,V&gt; singletonMap(K key, V value); </div><div class="line">//排序 </div><div class="line">static void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c); </div><div class="line">//交换指定位置的两个元素 </div><div class="line">static void swap(List&lt;?&gt; list, int i, int j) </div><div class="line">//将线程不安全的Collection转为线程安全的Collection </div><div class="line">static Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c); </div><div class="line">static List&lt;T&gt; synchronizedList(List&lt;T&gt; list); </div><div class="line">static Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m); </div><div class="line">static Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);</div></pre></td></tr></table></figure>
<hr>
<p><strong>Arrays</strong></p>
<p>这些方法都是静态方法。主要是针对数组操作。Arrays跟Collections很像，包含如下功能：</p>
<ul>
<li>二分搜索算法进行查找</li>
<li>将数组转List对象</li>
<li>复制数组指定范围的元素为一个新的数组</li>
<li>给数组指定范围的每个元素赋一个值，排序等等</li>
</ul>
<p>函数部分原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">//针对基本类型的查找 </div><div class="line">//如果查找的数组类型是int[],则函数如下 </div><div class="line">//其他的基本类型对应的二分搜索函数原型为把int替换指定的类型就好 </div><div class="line">static int binarySearch(int[] a, int key); </div><div class="line">//针对基本类型，在指定范围进行二分搜索 </div><div class="line">//其他基本类型类似 </div><div class="line">static int binarySearch(int[] a, int fromIndex, int toIndex, int key); </div><div class="line"> </div><div class="line">//针对类对象数组的二分搜索 </div><div class="line">static int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) </div><div class="line"> </div><div class="line">//针对一个数组，复制其元素到一个新的数组， </div><div class="line">//并将新的数组返回. </div><div class="line">//其他基本类型相似，将float替换掉即可 </div><div class="line">static float[] copyOf(float[] original, int newLength); </div><div class="line"> </div><div class="line">//复制数组指定范围的元素到一个新的数组， </div><div class="line">//并将新的数组返回 </div><div class="line">//其他基本类型类似，将byte替换即可 </div><div class="line">static byte[] copyOfRange(byte[] original, int from, int to); </div><div class="line">//复制指定范围的类对象数组 </div><div class="line">static  T[] copyOfRange(T[] original, int from, int to); </div><div class="line"> </div><div class="line">//判断两个基本类型数组里面的元素是否相等 </div><div class="line">//其他基本类型只需将char替换 </div><div class="line">static boolean equals(char[] a, char[] a2); </div><div class="line"> </div><div class="line">//判断两个类对象数组里面的元素是否相同 </div><div class="line">static boolean equals(Object[] a, Object[] a2); </div><div class="line"> </div><div class="line">//为基本类型数组里面的每一个元素赋相同的值 </div><div class="line">//其他基本类型将boolean替换 </div><div class="line">static void fill(boolean[] a, boolean val); </div><div class="line">//类数组一样 </div><div class="line">static void fill(Object[] a, Object val) </div><div class="line"> </div><div class="line">//返回hash码,基本类型替换long </div><div class="line">static int hashCode(long[] a); </div><div class="line">static int hashCode(Object[] a); </div><div class="line"> </div><div class="line">//排序,基本类型替换byte </div><div class="line">static void sort(byte[] a); </div><div class="line">static void sort(byte[] a, int fromIndex, int toIndex); </div><div class="line">//模板类型排序 </div><div class="line">static void sort(T[] a, Comparator&lt;? super T&gt; c); </div><div class="line">static void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c); </div><div class="line"> </div><div class="line">//toString，基本类型替换long </div><div class="line">static String toString(long[] a); </div><div class="line">static String toString(Object[] a);</div></pre></td></tr></table></figure>
<h3 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h3><p><strong>hashCode()方法</strong></p>
<p>因为<code>Object</code>类提供了<code>hashCode()</code>方法，因此，每个类对象都拥有<code>hashCode()</code>方法。而Object的 <code>hashCode</code>是一个<code>native</code>方法,我们就不去深究其具体的实现了。<br><code>hashCode</code>方法主要作用是为了配合散列的集合一起工作。散列集合包括<code>HashSet</code>、<code>HashMap</code>以及<code>HashTable</code>。</p>
<hr>
<p><strong>HashSet判断对象是否存在集合中</strong></p>
<p>我们知道，集合中是不允许重复元素存在的，当<code>HashSet</code>需要添加新的对象<code>obj</code>时，如何判断<code>obj</code>是否已经存在于集合中呢？</p>
<ul>
<li>调用<code>obj.hashCode()</code>，得到对应的<code>hashcode</code>值。</li>
<li>如果集合中没有存储这个<code>hashcode</code>对应的对象，则直接添加。</li>
<li>如果集合中已经存储了这个<code>hashcode</code>对应的对象，则调用equals判断是否对象相同。</li>
</ul>
<p>从上面过程可知，如果你重写<code>equals</code>方法，必须重写<code>hashCode</code>函数。因为：</p>
<p>如果只重写<code>equals</code>，根据你的规则将两个对象<code>equals</code>返回<code>true</code>，但是<code>hashCode</code>默认却不同，集合还是会添加新元素。</p>
<hr>
<p><strong>HashSet存取</strong></p>
<p><code>HashSet</code>是基于<code>HashMap</code>来实现的。<code>HashSet</code>相当于只利用<code>HashMap</code>的<code>Key</code>，而<code>value</code>使用一个 <code>static final</code>的<code>Object</code>对象标识。一次<code>HashSet</code>的存取相当于<code>HashMap</code>的一次存取，只不过<code>HashSet</code>只看重<code>Key</code>部分，不需要<code>Value</code>部分。因此，我们只需看接下来小节中的<code>HashMap</code>的put和get方法。</p>
<hr>
<p><strong>HashMap的put和get方法</strong></p>
<p>我们知道，<code>HashMap</code>里面的结构是<code>数组+链表</code>。链表里面存储的元素就是键值对<code>HashMap.Entry&lt;K,V&gt;</code>对象。在存放<code>Key-Value</code>时，过程如下：</p>
<ol>
<li>首先根据<code>key</code>的<code>hashCode</code>找到对应数组的位置</li>
<li>然后遍历该位置的链表，查找<code>key</code>是否已经存在</li>
<li>如果<code>key</code>已经存在，则直接更新<code>value</code>,并将旧的<code>value</code>作为函数返回</li>
<li>如果<code>key</code>不存在，则通过头插法，将新的键值对放入当前链表的第一个位置</li>
</ol>
<p><strong>注意，null key总是放入数组的第0个位置，因为null的哈希码为0</strong></p>
<p>put方法已经讲解完，get方法相对就比较简单了:</p>
<ol>
<li>首先根据key的hashCode找到对应数组的位置</li>
<li>然后遍历该位置的链表，查找key是否已经存在</li>
</ol>
<h3 id="return和finally执行顺序"><a href="#return和finally执行顺序" class="headerlink" title="return和finally执行顺序"></a>return和finally执行顺序</h3><p><strong>结论</strong></p>
<ol>
<li>不管有木有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>如果语句上的执行顺序是先return后finally，会先执行return后面的语句，这个语句的结果是最终的返回值result。result会被保存下来，再执行finally，待finally执行完成后，再结束函数，将result的值返回。这种情形的finally对变量的值修改不会影响最终的函数返回。</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li>
</ol>
<h3 id="Override与Overload区别"><a href="#Override与Overload区别" class="headerlink" title="Override与Overload区别"></a>Override与Overload区别</h3><p><strong>Override(重写、覆盖)</strong></p>
<p><code>Override</code>是子类对父类的允许访问的方法的实现过程进行重新编写，<code>Override</code>一个函数需要注意以下几点：</p>
<ul>
<li>返回值、函数名、形参都不能改变。即外壳不变，重写内在实现。</li>
<li>子类方法不能缩小父类方法的访问权限（反过来是可以的）</li>
<li><code>final</code>的方法不能被重写</li>
<li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明</li>
<li>子类和父类在同一个包中，子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li>
<li>子类和父类不在同一个包中，子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。</li>
<li>重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写</li>
<li>如果不能继承一个方法，则不能重写这个方法( 父类的private方法)。</li>
</ul>
<p>解释一下强制性异常和非强制性异常：</p>
<ul>
<li>除了<code>RuntimeException</code>外，都是强制性异常</li>
<li>所谓强制性异常就是在编写程序的过程中必需在抛出异常的部分<code>try catch</code> 或者向上<code>throws</code>异常</li>
<li>所谓非强制性异常就和上面相反了。不过你当然也可以<code>try catch</code>或者<code>thows</code>，只不过这不是强制性的。</li>
</ul>
<hr>
<p><strong>Overload(重载)</strong></p>
<p>重载是在同一个类里面，<strong>方法名字相同，而参数不同，返回类型可以相同也可以不同的多个方法</strong>。每个重载的方法都必须有一个独一无二的参数类型列表。</p>
<p>重载规则如下：</p>
<ul>
<li>被重载的方法必须改变参数列表；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
</ul>
<h2 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><blockquote>
<p>所谓CAS(Compare And Swap) 即比较并交换</p>
</blockquote>
<p>在<code>Intel</code>处理器中，比较并交换通过指令的 <code>cmpxchg</code> 系列实现。CAS有三个操作数：</p>
<ul>
<li>内存位置（V）</li>
<li>预期原值（A）</li>
<li>新值(B)</li>
</ul>
<p>如果内存位置<code>V</code>的值与预期<code>A</code>原值相匹配，那么处理器会自动将该位置值更新为新值<code>B</code>。否则，处理器不做任何操作。</p>
<p>无论哪种情况，它都会在 <code>CAS</code> 指令之前返回该位置的值。（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值。）CAS有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
<p><strong>CAS应用</strong></p>
<p>比较典型的应用就是<code>AtomicInteger</code>,可以看到，对<code>i++</code>和<code>i--</code>，都是通过<code>CAS</code>，并且通过一个死循环，<code>compareAndSet</code>函数内部就是通过<code>jni</code>操作<code>CAS</code>指令。直到<code>CAS</code>操作成功跳出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private volatile int value; </div><div class="line">    /** </div><div class="line">     * Gets the current value. </div><div class="line">     * </div><div class="line">     * @return the current value </div><div class="line">     */ </div><div class="line">    public final int get() &#123; </div><div class="line">        return value; </div><div class="line">    &#125; </div><div class="line">    /** </div><div class="line">     * Atomically increments by one the current value. </div><div class="line">     * </div><div class="line">     * @return the previous value </div><div class="line">     */ </div><div class="line">    public final int getAndIncrement() &#123; </div><div class="line">        for (;;) &#123; </div><div class="line">            int current = get(); </div><div class="line">            int next = current + 1; </div><div class="line">            if (compareAndSet(current, next)) </div><div class="line">                return current; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    /** </div><div class="line">     * Atomically decrements by one the current value. </div><div class="line">     * </div><div class="line">     * @return the previous value </div><div class="line">     */ </div><div class="line">    public final int getAndDecrement() &#123; </div><div class="line">        for (;;) &#123; </div><div class="line">            int current = get(); </div><div class="line">            int next = current - 1; </div><div class="line">            if (compareAndSet(current, next)) </div><div class="line">                return current; </div><div class="line">        &#125; </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="GC收集器"><a href="#GC收集器" class="headerlink" title="GC收集器"></a>GC收集器</h3><ul>
<li>Serial收集器</li>
<li>ParNew收集器</li>
<li>Parallel Scavenge收集器</li>
<li>Serial Old收集器</li>
<li>Parallel Old收集器</li>
<li>CMS收集器</li>
<li>G1收集器</li>
</ul>
<hr>
<p><strong>Serial收集器</strong></p>
<p>从名字可以看出，这个收集器是一个单线程的收集器。但是，它的“单线程”的意义并不仅仅说明它只会使用一个<code>CPU</code>或一条收集线程去完成垃圾收集工作，更重要的是，<strong>在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</strong>。</p>
<p><code>&quot;Stop The World&quot;</code>是在用户不可见的情况下，把用户正常工作的线程全部停掉，这对很多应用是难以接受的，试想一下，要是你的计算机每运行1小时就暂停响应5分钟，你会是什么样的心情！</p>
<p>运行示意图:</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/GC_Serial.png" alt="img"></p>
<p>对于<code>&quot;Stop The World&quot;</code>给用户带来的不良体验，虚拟机设计者表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间时候，肯定也会让你老老实实地在椅子上或房间外呆着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”</p>
<p>从<code>JDK1.3</code>开始，<code>HotSpot</code>虚拟机开发团队为消除或减少工作线程因内存回收而导致停顿的努力一直进行着。从<code>Serial</code>收集器到<code>Parallel</code>收集器，再到<code>Concurrent Mark Sweep（CMS）</code>乃至GC收集器的最前沿成功<code>Garbage First（G1）</code>收集器，用户线程停顿时间不短缩短，但是仍然无法完全消除！</p>
<p><strong>应用场景</strong></p>
<p>虽然<code>Serial收集器</code>看起来“老而无用、食之无味弃之可惜”，但实际上到目前为止，它依然是虚拟机运行在<code>Client模式下</code>的默认新生代收集器。它有着优于其他收集器的地方：简单高效（与其他收集器的单线程比）。</p>
<p>对于限定单个CPU的环境来说，<code>Serial收集器</code>由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</p>
<p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不是频繁发生，这点停顿还是可以接受的，所以Serial收集器对应运行<code>Client模式</code>下的虚拟机来说是一个很好的选择。</p>
<hr>
<p><strong>ParNew 收集器</strong></p>
<p><strong>运行过程:</strong></p>
<p><code>ParNew收集器</code>其实就是<code>Serial收集器</code>的<strong>多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SruvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在现实上，这两种收集器也共用了相当多代码。</p>
<p><code>ParNew收集器</code>工作示意图:</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/GC_ParNew.png" alt="img"></p>
<p><strong>应用场景</strong></p>
<p><code>ParNew收集器</code>除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在<code>Server模式下</code>的虚拟机中首选的新生代收集器。其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能<code>与CMS收集器</code>配合工作。</p>
<p><code>ParNew收集器</code>在单CPU的环境中绝对不会有比<code>Serial收集器</code>更好的效果。甚至由于存在线程交互的开销，该收集器在通过超线程技术实现两个CPU环境中都不能百分百地保证可以超越<code>Serial收集器</code>。当然，随着CPU数量增加，它对于GC时，系统资源的有效利用还是很有好处。它默认开启的收集线程数与CPU数量相同，在CPU非常多（例如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）环境下，可以使用<code>-XX:ParalleGCThreads</code>参数来限制垃圾收集的线程数。</p>
<hr>
<p><strong>Parallel Scavenge收集器</strong></p>
<p><code>Parallel Scavenge收集器</code>是一个新生代收集器，它也是使用<strong>复制算法</strong>的收集器，又是并行的多线程收集器….看上去和ParNew都一样，那它有啥特别的地方呢？</p>
<p><code>Parallel Scavenge收集器</code>的特点是它的关注点与其他收集器不同，<code>CMS</code>等收集器的关注点是<strong>尽可能第缩短垃圾收集时用户线程停顿时间</strong>，而<code>Parallel Scavenge收集器</code>的目标则是<strong>达到一个可控制的吞吐量</strong>。所谓的吞吐量就是：</p>
<blockquote>
<p>CPU用于运行用户代码的时间与CPU总消耗时间的比值，即：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
</blockquote>
<p>虚拟机总共运行<code>100分钟</code>，其中垃圾收集消耗掉<code>1分钟</code>，那吞吐量就是<code>99%</code>。</p>
<hr>
<p><strong>Serial Old收集器</strong></p>
<p><code>Serial Old</code>是<code>Serial收集器</code>的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给<code>Client模式下的虚拟机</code>使用。如果在Server模式下，它主要还有两大用途：</p>
<ul>
<li>在JDK1.5以及之前版本中与<code>Parallel Scavenge收集器</code>搭配使用</li>
<li>作为CMS收集器的后备预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用</li>
</ul>
<p>运行示意图和<code>Serial收集器类似</code></p>
<hr>
<p><strong>Parallel Old收集器</strong></p>
<p><code>Parallel Old收集器</code>是<code>Parallel Scavenge收集器</code>的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK1.6中才开始提供。</p>
<p>Parallel Old收集器运行示意图如下：</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/ParallelOld.png" alt="img"></p>
<hr>
<p><strong>CMS收集器</strong></p>
<p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目的的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统服务器上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户最好的体验。<code>CMS收集器</code>就非常符合这类应用的需求。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出，<code>CMS收集器</code>是基于“标记-清除”算法实现的，它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>其中，初始标记、重新标记着两个步骤仍然需要<code>“Stop The World”</code>。初始标记仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快。并发标记阶段就是进行<code>GC Roots Tracing</code>的过程。而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记稍长一些，但远比并发标记时间短。</p>
<p>由于整个过程中耗时最长的<strong>并发标记和并发清除过程</strong>收集器线程都可以与用户线程一起工作，所有总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。CMS运作步骤如下：</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/CMS.png" alt="img"></p>
<p>CMS是一款优秀的收集器，它的主要优点从名字上体现出来：并发收集、低停顿。但是CMS还远达不到完美程度，它有以下3个明显的缺点：</p>
<ul>
<li><code>CMS收集器</code>对<code>CPU</code>资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</li>
<li><code>CMS收集器</code>无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致另一次<code>Full GC</code>产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。因此，CMS不能像其他收集器那样等到老年代几乎完全被填满再进行收集，CMS需要预留一部分空间。</li>
<li>由于CMS基于<code>“标记-清除”</code>算法，意味着收集结束时会有大量空间碎片产生。</li>
</ul>
<hr>
<p><strong>G1收集器</strong></p>
<p><code>G1（Garbage First）收集器</code>是当今收集器技术发展的最前沿成果之一。G1是面向服务端应用的垃圾收集器，与其他GC收集器相比，G1具备如下特点：</p>
<ul>
<li>并行与并发：充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器需要停顿Java线程执行的GC动作，G1仍然能通过并发方式让Java程序继续执行。</li>
<li>分代收集：与其他收集器一样，分代概念在G1中依然得以保存。</li>
<li>空间整合：与CMS的“标记-清理”算法不同，G1从整体上看是基于“标记-整理”算法实现的收集器，从局部上看是基于“复制”算法实现的，这两种算法意味着G1运作期间不会产生内存空间碎片。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得从超出N毫秒，这几乎已经是实时Java的垃圾收集器的特征了。</li>
</ul>
<p>G1运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>运行示意图如下：</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/GC_G1.png" alt="img"></p>
<h3 id="内存模型和分区"><a href="#内存模型和分区" class="headerlink" title="内存模型和分区"></a>内存模型和分区</h3><p><strong>逻辑内存模型</strong></p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/memorymodel.png" alt="img"></p>
<hr>
<p><strong>内存分区</strong></p>
<ul>
<li><code>程序计数器</code>: 较小的内存空间。线程私有。可以看成是<strong>当前线程所执行的字节码的行号指示器</strong>。通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。此内存区域<strong>是唯一一个在JVM规范中没有规定任何OutofMemoryError情况的区域</strong>。</li>
<li><code>Java虚拟机栈</code>: 线程私有，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成，就对应一个栈帧在虚拟机栈中的<strong>入栈</strong>和到<strong>出栈</strong>的过程。会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>.</li>
<li><code>本地方法栈</code>: 功能与虚拟机栈类似。区别在于本地方法栈为<code>native</code>方法服务。</li>
<li><code>Java堆</code>: <code>JVM</code>所管理的内存中最大的一块。所有线程所共享。可分为：<code>新生代</code>和<code>老年代</code>。新生代可再细分为：<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>。有<code>OutOfMemoryError</code>异常。</li>
<li><code>方法区</code>: 跟<code>Java</code>堆一样，是各个线程共享区域。存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池是方法区一部分。</li>
<li><code>直接内存</code>: 不属于虚拟机运行时数据区的一部分。<code>NIO</code>引入了一种<strong>基于通道与缓冲区的IO方式</strong>。他可以使用<code>Native</code>函数库直接分配堆外内存，然后通过一个存储在<code>Java</code>堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。避免<code>Java</code>堆和<code>Native</code>堆之间来回复制数据，在某种场景中显著提高性能。由于不在堆中分配，因此不受到堆大小限制。但既然是内存总有会被用完时候，因此会抛出<code>OutOfMemoryError</code>。</li>
</ul>
<h3 id="新生代老年代"><a href="#新生代老年代" class="headerlink" title="新生代老年代"></a>新生代老年代</h3><p><strong>新生代于老年代占空间比例</strong></p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/newold.png" alt="img"></p>
<p>堆被划分为<strong>新生代</strong>和<strong>老年代</strong>。默认比例为<code>1:2</code>（可以通过<code>–XX:NewRatio</code> 设定）。新生代又分为<code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code>。这样划分的目的是为了使 ˚能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<p>新生代分为的三个部分, 默认比例为<code>Eden:from:to=8:1:1</code>（可以通过参数<code>–XX:SurvivorRatio</code> 来设定，–<code>XX:SurvivorRatio =8</code>表示<code>Eden</code>与一个<code>Survivor</code>空间比例为8:1）</p>
<hr>
<p><strong>存活对象的拷贝</strong></p>
<p>一般新建的对象会分配到<code>Eden</code>区。这些对象经过第一次<code>Minor GC</code>后，如果仍然存活，将会被移到<code>Survivor</code>区。在<code>Survivor</code>每熬过一轮<code>Minor GC</code>年龄就增加1。</p>
<p>当年龄达到一定程度时(年龄阈值，默认为<code>15</code>，可以通过<code>-XX:MaxTenuringThreshold</code>来设置)，就会被移动到老年代。</p>
<p><code>from</code>和<code>to</code>之间会经常互换角色，<code>from</code>变成<code>to</code>，<code>to</code>变成<code>from</code>。每次<code>GC</code>时，把<code>Eden</code>存活的对象和<code>From Survivor</code>中存活且没超过年龄阈值的对象复制到<code>To Survivor</code>中，<code>From Survivor</code>清空，变成<code>To Survivor</code>。</p>
<p><strong>Minor GC与Full GC</strong></p>
<p><code>Java</code>中的堆也是<code>GC</code>收集垃圾的主要区域。GC分为两种：</p>
<ul>
<li>Minor GC</li>
<li>Full GC</li>
</ul>
<p><code>Minor GC</code>是发生在<strong>新生代中</strong>的垃圾收集动作，所采用的是<strong>复制算法</strong>，因为<code>Minor GC</code>比较频繁，因此一般回收速度较快。<code>Full GC</code> 是发生在<strong>老年代</strong>的垃圾收集动作，所采用的是<strong>标记-清除算法</strong>，速度比Minor GC慢10倍以上。</p>
<p>大对象直接进入<strong>老年代</strong>。比如很长的字符串以及数组。通过设置<code>-XX：PretenureSizeThreshold</code>，令大于这个值得对象直接在老年代分配。这样做是为了避免在<code>Eden</code>和两个<code>Survivor</code>之间发生大量的内存复制。</p>
<blockquote>
<p>什么时候发生 Minor GC？什么时候发生Full GC？<br>当新生代Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。<br>老年代空间不足时Full GC</p>
</blockquote>
<h3 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h3><p>判断哪些对象是存活的，哪些对象消亡的，典型的有两种方法：</p>
<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<hr>
<p><strong>引用计数</strong></p>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器+1，引用失效计数器-1；<strong>任何时候计数器为0</strong>的对象就是不可能再被使用。这有个问题是，两个对象相互引用导致两个对象都无法被回收。</p>
<hr>
<p><strong>可达性分析</strong></p>
<p>通过一系列的<code>GC Roots</code>对象作为起点，从这些节点开始向下搜索。搜索所走过的路称为引用链。当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象不可用。</p>
<p>可作为<code>GC Root</code>的对象有：</p>
<ul>
<li>虚拟机栈（栈帧的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用对象</li>
</ul>
<p>即使在可达性分析中不可达的对象，也并非是“非死不可”，这时候他们暂时处于“缓刑”阶段。要真正宣告一个对象死亡，需要经历两个阶段：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li>
<li>如果这个对象被判断为有必要执行<code>finalize()</code>方法。那么这个对象会被放到一个<code>F-Queue</code>队列中，并在稍后由一个虚拟机自动建立的、优先级低的<code>Finalizer线程</code>去执行它，这里的“执行”是指虚拟机会触发这个方法，但并不承诺等待它运行结束。这是为了防止<code>finalize()</code>方法执行缓慢使得<code>F-Queue</code>队列其他对象永久等待。</li>
</ol>
<p>因此，对象可以在<code>finalize()</code>方法里把自己赋值给一个变量，以达到“自救”的目的，但是这样的“自救”只能用一次（虚拟机只会调用一次<code>finalize()</code>方法）。</p>
<h3 id="GC的三种收集方法"><a href="#GC的三种收集方法" class="headerlink" title="GC的三种收集方法"></a>GC的三种收集方法</h3><p><strong>1.标记-清除</strong></p>
<p>分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，他的标记过程在上面几行中已经提到过。</p>
<p>不足：</p>
<ul>
<li>标记和清除两个过程效率不高</li>
<li>标记清除后产生大量不连续的内存碎片。</li>
<li>该算法主要用在老年代区域。</li>
</ul>
<hr>
<p><strong>2.复制算法</strong></p>
<p>将内存分为两部分，每次使用其中一块，当这块内存用完，就将还存活的对象复制到另一块上面。</p>
<p>不足：</p>
<ul>
<li>浪费一半内存</li>
</ul>
<p>通常用在新生代区域中，有个改进的方法是将新生代分为Eden、From Survivor、To Survivor。</p>
<hr>
<p><strong>3.标记-整理</strong></p>
<p>标记过程和标记清除一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动。</p>
<p>主要用在老年代区域。</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类加载的5个过程分为:</p>
<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
</ul>
<hr>
<p><strong>1.加载</strong></p>
<ol>
<li>通过类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p><strong>2.验证</strong></p>
<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证。</li>
</ol>
<p><strong>3.准备</strong></p>
<p>为类变量（<code>static</code>）分配内存并设置类变量的初始值。</p>
<blockquote>
<p>注意，实例变量并不在这个阶段分配内存。为类变量设置初始值并不是定义的值。<br>比如static int value = 123;那么变量value在准备阶段过后初始值为0，而不是123。值123是在<code>&lt;clinit&gt;()</code>方法中赋予。</p>
</blockquote>
<p><strong>4.解析</strong></p>
<p>将常量池内的符号引用转为直接的引用.</p>
<p><strong>5.初始化</strong></p>
<p>按照<code>static块</code>和<code>static变量</code>在文件中的出现顺序，合并到<code>&lt;clinit&gt;()</code>方法中。实例变量由<code>&lt;init&gt;()</code>函数赋值。</p>
<h3 id="静态分派-动态分派"><a href="#静态分派-动态分派" class="headerlink" title="静态分派 动态分派"></a>静态分派 动态分派</h3><p><strong>静态分派</strong></p>
<p><strong>概念:</strong>静态分派与重载有关，虚拟机在重载时是通过参数的静态类型，而不是运行时的实际类型作为判定依据的；静态类型在编译期是可知的；</p>
<p>看如下例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line">    static abstract class Human &#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Man extends Human &#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Woman extends Human &#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public void sayHello(Human guy) &#123; </div><div class="line">        System.out.println(&quot;hello,guy!&quot;); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public void sayHello(Man guy) &#123; </div><div class="line">        System.out.println(&quot;hello gentleman!&quot;); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public void sayHello(Woman guy) &#123; </div><div class="line">        System.out.println(&quot;hello lady!&quot;); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123; </div><div class="line">        Human man = new Man(); </div><div class="line">        Human woman = new Woman(); </div><div class="line"> </div><div class="line">        Test test = new Test(); </div><div class="line">        test.sayHello(man); </div><div class="line">        test.sayHello(woman); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello,guy! </div><div class="line">hello,guy!</div></pre></td></tr></table></figure>
<p>稍微有Java开发经验的人都能得到正确的答案。但是为什么会选择执行参数类型为<code>Human</code>的重载呢？在解决这个问题之前，我们先按如下代码定义两个重要概念：</p>
<p><code>Human man = new Man();</code></p>
<p>上面代码中，<code>Human</code>称为<strong>变量的静态类型</strong>；后面的<code>Man</code>则称为<strong>变量的实际类型</strong>。<br>静态类型和实际类型在程序中都可以发生一些变化，区别是：</p>
<ul>
<li>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译期可知的</li>
<li>实际类型变化的结果在运行期才能确定，编译器在编译程序时并不知道一个对象的实际类型是什么。例如下面代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//实际类型变化 </div><div class="line">Human man=new Man(); </div><div class="line">man=new Woman(); </div><div class="line"> </div><div class="line">//静态类型变化 </div><div class="line">test.sayHello((Man)man); </div><div class="line">test.sayHello((Woman) man)</div></pre></td></tr></table></figure>
<p>使用哪个重载版本，完全取决于<strong>传入参数的数量</strong>和<strong>数据类型</strong>。代码中刻意定义两个静态类型相同，但实际类型不同的变量，但虚拟机在重载时，是通过参数的<strong>静态类型</strong>而不是<strong>实际类型</strong>作为判断依据。并且静态类型在编译期是可知的，因此，在编译阶段，<code>javac</code>编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了<code>sayHello(Human)</code>作为调用目标，并把这个方法的符号引用写到<code>man()</code>方法里面两条<code>invokevirtual</code>指令参数中。</p>
<blockquote>
<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用就是方法重载。</p>
</blockquote>
<p><strong>重载方法的匹配优先级</strong></p>
<p><strong>基本类型中</strong>，以<code>char</code>为例，按照如下优先级：</p>
<p><code>char&gt;int&gt;long&gt;float&gt;double&gt;Character&gt;Serializable&gt;Object&gt;...</code>其中…为变长参数，</p>
<p>注意：<code>char</code>到<code>byte</code>或<code>short</code>之间的转换是不安全的</p>
<p><strong>引用类型中</strong>，需要根据继承关系进行匹配，注意只跟其编译时类型即静态类型相关。</p>
<hr>
<p><strong>动态分派</strong></p>
<p>动态分派与<code>重写(Override)</code>相关。同样，看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line">    static abstract class Human &#123; </div><div class="line">        protected abstract void sayHello(); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Man extends Human &#123; </div><div class="line">        @Override </div><div class="line">        protected void sayHello() &#123; </div><div class="line">            System.out.println(&quot;man say hello&quot;); </div><div class="line"> </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    static class Woman extends Human &#123; </div><div class="line">        @Override </div><div class="line">        protected void sayHello() &#123; </div><div class="line">            System.out.println(&quot;woman say hello&quot;); </div><div class="line"> </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123; </div><div class="line">        Human man = new Man(); </div><div class="line">        Human woman = new Woman(); </div><div class="line"> </div><div class="line">        man.sayHello(); </div><div class="line">        woman.sayHello(); </div><div class="line"> </div><div class="line">        man = new Woman(); </div><div class="line">        man.sayHello(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">man say hello </div><div class="line">woman say hello </div><div class="line">woman say hello</div></pre></td></tr></table></figure>
<p>代码很简单，基本都能回答正确。但是现在问题是，虚拟机是如何知道调用哪个方法？</p>
<p>显然这里不能再根据静态类型决定，因为静态类型同样都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时执行了不同的行为，并且变量<code>man</code>在两次调用中执行了不同的方法。</p>
<p>导致这个现象的原因很明显，是这两个变量的<strong>实际类型</strong>不同，java虚拟机是如何根据实际类型来分派方法执行版本呢？</p>
<p>看一下这两句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Human man=new Man(); </div><div class="line">Human woman=new Woman();</div></pre></td></tr></table></figure>
<p>这两个对象是即将要执行sayHello()方法的所有者，称为接受者。</p>
<p>由于<code>invokevirtual</code>指令执行第一步就是在运行期间确定接受者的实际类型，所以两次调用中的<code>invokevirtual</code>指令<strong>把常量池中类方法符号引用解析到不同的直接引用上</strong>，这个过程就是Java语言中方法重写的本质。这种运行期<strong>根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名空间。简单说：</p>
<ul>
<li>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</li>
<li>否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要他们的类加载器不同，那这两个类就必定不等。</li>
</ul>
<p>这里指的“相等”，包括代表<code>Class</code>对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果，而包括使用<code>instanceof</code>关键字做对象所属关系判定等情况。</p>
<p>如果没有注意到类加载器的影响，在某些情况下，可能会产生具有迷惑性的结果，看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line">    static ClassLoader myLoader = new ClassLoader() &#123; </div><div class="line">        @Override </div><div class="line">        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; </div><div class="line"> </div><div class="line">            if (!name.equals(&quot;com.szysky.Test&quot;)) </div><div class="line">                return super.loadClass(name); </div><div class="line"> </div><div class="line">            try &#123; </div><div class="line">                String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) </div><div class="line">                        + &quot;.class&quot;; </div><div class="line"> </div><div class="line">                InputStream is = getClass().getResourceAsStream(fileName); </div><div class="line">                if (is == null) &#123; </div><div class="line">                    return super.loadClass(fileName); </div><div class="line">                &#125; </div><div class="line">                byte[] b = new byte[is.available()]; </div><div class="line">                is.read(b); </div><div class="line">                return defineClass(name, b, 0, b.length); </div><div class="line"> </div><div class="line">            &#125; catch (IOException e) &#123; </div><div class="line">                throw new ClassNotFoundException(name); </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125;; </div><div class="line"> </div><div class="line">    public static void main(String[] args) throws Exception &#123; </div><div class="line"> </div><div class="line">        Object obj = myLoader.loadClass(&quot;com.szysky.Test&quot;); </div><div class="line">        System.out.println(obj); </div><div class="line">        System.out.println(obj instanceof com.szysky.Test); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class com.szysky.Test </div><div class="line">false</div></pre></td></tr></table></figure>
<p>从第二句发现，这个对象与类<code>com.szysky.Test</code>做所属类型检查时返回了false，这是因为虚拟机中存在了两个Test类，一个是由系统应用程序类加载器加载的，另一个是由我们自定义的类加载器加载，虽然都是来自同一个class文件，但依然是两个独立的类，对象所属类型检查结果自然为false。</p>
<hr>
<p><strong>自定义类加载器</strong></p>
<p>首先，定义一个类加载器MyClassLoader.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class MyClassLoader extends ClassLoader &#123; </div><div class="line">    // 类加载器的名称 </div><div class="line">    private String name; </div><div class="line">    // 类存放的路径 </div><div class="line">    private String classpath = &quot;E:/&quot;; </div><div class="line"> </div><div class="line">    MyClassLoader(String name) &#123; </div><div class="line">        this.name = name; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    MyClassLoader(ClassLoader parent, String name) &#123; </div><div class="line">        super(parent); </div><div class="line">        this.name = name; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">    @Override </div><div class="line">    public Class&lt;?&gt; findClass(String name) &#123;  </div><div class="line">        byte[] data = loadClassData(name); </div><div class="line">        return this.defineClass(name, data, 0, data.length); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    public byte[] loadClassData(String name) &#123; </div><div class="line">        try &#123; </div><div class="line">            name = name.replace(&quot;.&quot;, &quot;//&quot;); </div><div class="line">            System.out.println(name); </div><div class="line">            FileInputStream is = new FileInputStream(new File(classpath + name </div><div class="line">                    + &quot;.class&quot;)); </div><div class="line">            byte[] data = new byte[is.available()]; </div><div class="line">            is.read(data); </div><div class="line">            is.close(); </div><div class="line">            return data; </div><div class="line"> </div><div class="line">        &#125; catch (Exception e) &#123; </div><div class="line">            e.printStackTrace(); </div><div class="line">        &#125; </div><div class="line">        return null; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义待加载的类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class TestObject &#123; </div><div class="line">    public void print() &#123; </div><div class="line">        System.out.println(&quot;hello ClassLoader&quot;); </div><div class="line"> </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Test &#123; </div><div class="line"> </div><div class="line">    public static void main(String[] args) throws InstantiationException, </div><div class="line">            IllegalAccessException, ClassNotFoundException &#123; </div><div class="line">        // 新建一个类加载器 </div><div class="line">        MyClassLoader cl = new MyClassLoader(&quot;myClassLoader&quot;); </div><div class="line">        // 加载类，得到Class对象 </div><div class="line">        Class&lt;?&gt; clazz = cl.loadClass(&quot;com.szysky.TestObject&quot;); </div><div class="line">        // 得到类的实例 </div><div class="line">        TestObject test= (TestObject) clazz.newInstance(); </div><div class="line">        test.print(); </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以正常输出语句.</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从虚拟机的角度来讲，只存在<strong>两种不同的类加载器</strong></p>
<ul>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）。使用C++语言实现（针对HotSpot虚拟机而言），是虚拟机自身的一部分。</li>
<li>所有其他的类加载器。使用Java语言实现，独立于虚拟机外部，并且全部继承自抽象类<code>java.lang.ClassLoader</code></li>
</ul>
<p>从Java程序员角度来看，类加载器还可以划分的更细致一点，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p>
<ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器</li>
</ul>
<hr>
<p><strong>启动类加载器</strong></p>
<p>这个类加载器将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定路径中的，并且是虚拟机识别的（仅按文件名识别，如：<code>rt.jar</code>，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如<code>java.lang.ClassLoader.getClassLoader()</code>方法所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@CallerSensitive </div><div class="line">public ClassLoader getClassLoader() &#123; </div><div class="line">    ClassLoader cl = getClassLoader0(); </div><div class="line">    if (cl == null) </div><div class="line">        return null; </div><div class="line">    SecurityManager sm = System.getSecurityManager(); </div><div class="line">    if (sm != null) &#123; </div><div class="line">        ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass()); </div><div class="line">    &#125; </div><div class="line">    return cl; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>扩展类加载器(Extension ClassLoader)</strong></p>
<p>这个类加载器由<code>sum.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<p><strong>应用程序类加载器（Application ClassLoader</strong></p>
<p>这个类加载器由<code>sum.misc.Launcher$AppClassLoader</code>实现。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值。所以，一般也称它为系统类加载器。它负责加载用户类路径<code>（ClassPath）</code>上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<hr>
<p><strong>双亲委派模型</strong></p>
<p>如下图所示，这种类加载器之间的层次关系，称为类加载器的双亲委派模型。</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/classLoad.png" alt="img"></p>
<p>双亲委派模型要求：</p>
<blockquote>
<p>除了顶层启动类加载器以外，其余的类加载器都应当有自己的父类加载器。</p>
</blockquote>
<p>这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用<strong>组合关系来复用父加载器的代码</strong>。它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p><strong>双亲委派模型工作过程</strong></p>
<p>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是：</p>
<blockquote>
<p>Java类随着它的类加载器一起具备了一种带优先级的层次关系</p>
</blockquote>
<p>例如：类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器进行加载，因此<code>Object</code>类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为<code>java.lang.Object</code>的类，并放在<code>ClassPath</code>中，那系统中将出现多个不同的<code>Object</code>类，Java类型体系中最基础的行为也就无法保证，应用程序也将变得一片混乱。</p>
<p>实现双亲委派模型的代码都集中在<code>java.lang.ClassLoader的loadClass()</code>方法中，逻辑清晰易懂：</p>
<ul>
<li>先检查是否已经被加载过，若没有加载，则调用父加载器的loadClass()方法</li>
<li>若如加载器为空，则默认使用启动类加载器作为父加载器</li>
<li>如果父加载失败，抛出ClassNotFoundException异常之后，再调用自己的findClass()方法进行加载</li>
</ul>
<p>以下是<code>ClassLoader</code>的<code>loadClass()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) </div><div class="line">        throws ClassNotFoundException &#123; </div><div class="line">    Class&lt;?&gt; c = findLoadedClass(name); </div><div class="line">    if (c == null) &#123; </div><div class="line">        try &#123; </div><div class="line"> </div><div class="line">            if (parent != null) &#123; </div><div class="line">                c = parent.loadClass(name, false); </div><div class="line">            &#125;else&#123; </div><div class="line">                c=findBootstrapClassOrNull(name); </div><div class="line">            &#125; </div><div class="line">        &#125; catch (ClassNotFoundException e) &#123; </div><div class="line">            //如果父类加载器抛出ClassNotFoundException， </div><div class="line">            //说明父类加载器无法完成加载请求 </div><div class="line">        &#125; </div><div class="line">        if(c==null)&#123; </div><div class="line">            //在父类加载器无法加载的时候 </div><div class="line">            //再调用本身的findClass方法进行类加载 </div><div class="line">            c=findClass(name); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    if(resolve)&#123; </div><div class="line">        resolveClass(c); </div><div class="line">    &#125; </div><div class="line">    return c; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象创建-内存分布-访问定位"><a href="#对象创建-内存分布-访问定位" class="headerlink" title="对象创建 内存分布 访问定位"></a>对象创建 内存分布 访问定位</h3><p>对象在JVM中是如何创建、如何布局以及如何访问的。讨论这个问题需要限定在具体的虚拟机和集中在某一个内存区域上才有意义。我们这个所说的是<strong>Sun的HotSpot虚拟机的Java堆内存区域</strong>，深入探讨HotSpot虚拟机在Java堆中对象的分配、布局和访问全过程。</p>
<hr>
<p><strong>对象的创建</strong></p>
<p>在语言层面上，创建对象（例如克隆、反序列化）通常仅仅是一个<code>new</code>关键字而已，而在虚拟机中，对象（文中探讨的对象限于普通对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</p>
<ol>
<li><p><code>new指令开始:</code> 虚拟机遇到一个new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，需要先执行相应的类加载过程。参考类加载的五个过程。</p>
</li>
<li><p><code>为对象分配内存:</code> 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（下一节介绍如何完全确定）。<strong>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来</strong></p>
<ul>
<li><p><code>划分空间:</code>假设<code>Java</code>堆中内存是绝对规整的，所有用到的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为<code>“指针碰撞”</code>。如果Java堆中的内存<strong>并不是规整的</strong>，已使用的内存和空闲的内存相互交错，那就<strong>没有办法简单地进行指针碰撞了</strong>，此时：虚拟机就必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<code>“空闲列表”</code>。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用<code>Serial</code>、<code>ParNew</code>等带<code>Compact</code>过程的收集器时，系统采用的分配算法是指针碰撞，而使用<code>CMS</code>这种基于<code>Mark_sweep</code>算法的收集器时，通常采用空闲列表。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">划分的线程安全:</div></pre></td></tr></table></figure>
<p>除如何划分可用空间外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的操作，即使是仅仅修改一个指针所指向的位置，在并发情况下是线程不安全的，可能出现正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理——实际上虚拟机采用<code>CAS</code>配上失败重试的方式保证更新操作的原子性；</li>
<li>把内存分配动作按照线程划分在不同的内存空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer ，TLAB）。哪个线程要分配内存，就在哪个线程的<code>TLAB</code>上分配，只有<code>TLAB</code>用完并分配新的<code>TLAB</code>时才需要同步锁。虚拟机是否使用<code>TLAB</code>，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>内存空间初始化为零值:</code>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用<code>TLAB</code>，这一工作过程也可以提前至<code>TLAB</code>分配时进行。</p>
<ul>
<li>这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型对应的零值。</li>
<li>接下来，虚拟机要对对象进行必要的设置，例如：这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。上面工作都完成后，从虚拟机的角度来看，一个新的对象已经诞生了，但从Java程序来说，对象创建才刚刚开始，所有的字段都还为零，需要进行一些初始化操作。</li>
</ul>
</li>
</ol>
<p>小结: 对象的创建过程如下:</p>
<ul>
<li>虚拟机首先需要进行类加载检查</li>
<li>检查通过之后，根据类加载完成后确定的内存大小，为对象分配内存</li>
<li>接着，需要对分配到的内存空间都初始化为零值</li>
<li>然后，虚拟机要对对象设置一些基本信息，如对象是那个类的实例、对象的哈希码、对象的GC分代年龄信息、如何才能找到类的元数据信息等，到这里虚拟机创建对象的工作已经完成</li>
<li>最后，从程序的角度，我们还需要对对象进行初始化操作。</li>
</ul>
<hr>
<p><strong>对象的内存布局</strong></p>
<p>在<code>HotSpot</code>虚拟机中，对象在内存中存储的局部可以分为3块区域：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<blockquote>
<p><code>HotSpot</code>虚拟机的对象头包括两部分信息</p>
</blockquote>
<ul>
<li>用于存储对象自身的运行时数据<ul>
<li>哈希码（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳<ul>
<li>这部分数据长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为<code>“Mark Word”</code>。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构能够记录的限度。但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计成为一个固定的数据结构以便在极小的空间存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</li>
</ul>
</li>
</ul>
</li>
<li>类型指针，即对象指向它的类元数据的指针<ul>
<li>对象头的另外一个部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针（还有通过句柄的方式）。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例数据部分</p>
</blockquote>
<p>接下来的实例数据部分是对象真正存储的有限信息，也是程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配参数（<code>FieldAllocationStyle</code>）和字段在Java源码中定义顺序的影响。</p>
<p>HotSpot虚拟机默认的分配策略为:</p>
<p><code>longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers)</code></p>
<p>从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提的条件下，在父类中定义的变量会出现在子类之前。如果<code>CompactFields</code>参数值为<code>true</code>，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<blockquote>
<p>第三部分对齐填充并不是必然存在的，</p>
</blockquote>
<p>也没有特别的含义，它仅仅起着占位符的作用。由于<code>HotSpot VM</code>的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<hr>
<p><strong>对象的访问定位</strong></p>
<p>建立对象是为了使用对象，我们的Java程序需要通过<code>栈上的reference</code>数据来<code>操作堆上的具体对象</code>。由于<code>reference</code>类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/handlepoll.png" alt="img"></p>
<p>如果是直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p>
<p><img src="http://szysky.com/2016/11/16/%E9%9D%A2%E7%BB%8F%E4%B9%8BJava%E7%AF%87/pointpoll.png" alt="img"></p>
<p>这两种对象访问方式各有优势：</p>
<ul>
<li>使用句柄来访问的最大好处就是<code>reference</code>中存储的是<strong>稳定的句柄地址</strong>，在对象被移动（垃圾收集时移动对象是非常普遍的行为）是只会改变句柄中的实例数据指针，而reference本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁。<code>Sun HotSpot</code>虚拟机采用的是第二种方式。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/java/面试之Java篇/" data-id="cj7hnifd6000q6opjsgyqttac" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/java/面试之Java篇/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-git/git操作再识 拥抱开始" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/git/git操作再识 拥抱开始/">Git操作再识 拥抱开始</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/git/git操作再识 拥抱开始/">
            <time datetime="2017-09-12T00:02:04.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/git/">git</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/git/">git</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p><strong>Linux</strong></p>
<p><code>$ sudo yum install git</code></p>
<p>或者</p>
<p><code>$ sudo apt-get install git</code></p>
<p><strong>Mac</strong></p>
<p>直接在<code>Terminal</code>执行<code>git</code>命令, 如果没有会提示安装方法.</p>
<p>如果喜欢安装程序的话, <a href="http://git-scm.com/download/mac" target="_blank" rel="external">点这里</a></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>第一次安装, 千万别要忘了配置你的git的使用者名字和邮箱. 这个道理很简单, 每一次的提交时需要记录提交者的, 如果没有提交者, 那么bug出现找谁来背锅??</p>
<h3 id="查看config"><a href="#查看config" class="headerlink" title="查看config"></a>查看config</h3><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。</p>
<p><strong>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。</strong></p>
<p><code>$ git config --system --list</code></p>
<hr>
<p><strong>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。</strong></p>
<p><code>$ git config --global --list</code></p>
<hr>
<p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：针对该仓库。</p>
<p>每一个级别覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p>
<hr>
<p><strong>当然, 也可以查看某一项配置信息.</strong></p>
<ul>
<li>形式:<code>git config [--global|--system] &lt;key&gt;</code></li>
</ul>
<p><em>查看最终的配置属性值</em><br><code>$ git config user.name</code></p>
<p><em>查看当前系统的属性值</em><br><code>$ git config --global user.name</code></p>
<hr>
<h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><p><code>$ git config --global user.name &quot;name&quot;</code></p>
<p><code>$ git config --global user.email xxx@163.com</code></p>
<p>使用<code>--global</code>选项, 当以后在该系统上做的任何操作都会使用此属性. 如果你需要在某一个特定的项目使用其他名字和邮箱, 那么可以通过设置<strong>项目中的config文件</strong>, 这样config中的属性会覆盖掉<strong>global的全局属性</strong>, 并且当在其他项目中并不会造成影响. 使用方式只需要去掉<code>--global</code>参数即可修改项目中的<code>.git/config</code>文件</p>
<p><code>$ git config user.name &quot;name&quot;</code></p>
<hr>
<p><strong>获取帮助手册</strong></p>
<p>形式: <code>git help &lt;verb&gt;</code> 或者 <code>git &lt;verb&gt; --help</code></p>
<p>比如查看config手册</p>
<p><code>$ git help config</code></p>
<h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>例如: 生成别名之后可以在日后用简短的表示来使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.br branch</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure>
<h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><p>对于自动生成的文件, 日志, 编译的临时文件等. 可以对其进行配置, 让git不追踪这些文件</p>
<p>规范如下:</p>
<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反</li>
</ul>
<p><code>glob模式</code>是指shell所使用的简化了的正则表达式.</p>
<ul>
<li><code>*</code> :匹配零个或多个任意字符</li>
<li><code>[abc]</code> :只匹配括号内的任意一个字符</li>
<li><code>[0-9]</code> :使用短划线表示范围, 可以匹配0到9之间的任何字符.</li>
<li><code>?</code> :匹配任意一个字符</li>
<li><code>**</code>:匹配任意的中间目录,例如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>,<code>a/b/c/z</code>等</li>
</ul>
<p>如下给出一个样板:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 忽略所有以 .c结尾的文件</div><div class="line">*.c</div><div class="line"></div><div class="line"># 但是 stream.c 会被git追踪</div><div class="line">!stream.c</div><div class="line"></div><div class="line"># 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO</div><div class="line">/TODO</div><div class="line"></div><div class="line"># 忽略所有在build文件夹下的文件</div><div class="line">build/</div><div class="line"></div><div class="line"># 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt</div><div class="line">doc/*.txt</div><div class="line"></div><div class="line"># 忽略所有在doc目录下的.pdf文件</div><div class="line">doc/**/*.pdf</div></pre></td></tr></table></figure>
<h2 id="仓库的基础操作"><a href="#仓库的基础操作" class="headerlink" title="仓库的基础操作"></a>仓库的基础操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure>
<h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 添加全部暂存区和历史区不存在的或者有更改的 `.c`结尾的文件</div><div class="line">$ git add *.c </div><div class="line">  </div><div class="line"># 添加全部暂存区和历史区不存在的或者有更改的文件</div><div class="line">$ git add .  </div><div class="line"></div><div class="line"># 指定文件添加</div><div class="line">$ git add test.c</div></pre></td></tr></table></figure>
<hr>
<h3 id="status仓库"><a href="#status仓库" class="headerlink" title="status仓库"></a>status仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"></div><div class="line"># 如果需要显示一种紧凑式格式</div><div class="line">$ git status --short      # 等价于 $ git status -s</div></pre></td></tr></table></figure>
<p>紧凑式中字母的表示含义如下:</p>
<ul>
<li><code>??</code> :表示新添加的未追踪的文件</li>
<li><code>M</code> :M出现在右边,表示该文件被修改但是还没有放入暂存区</li>
<li><code>M</code> :M出现在左边,表示文件被修改已经放入了暂存区</li>
<li><code>MM</code> :出现两个,代表此文件在工作区修改已经放入了暂存区, 但之后有进行了修改,没有添加到暂存区</li>
</ul>
<hr>
<h3 id="diff仓库"><a href="#diff仓库" class="headerlink" title="diff仓库"></a>diff仓库</h3><p>如果你想知道文件具体修改的内容, 那么<code>diff</code>会很有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 查看以追踪但尚未暂存的文件更新了哪些部分, 不添加额外参数</div><div class="line">$ git diff</div><div class="line"></div><div class="line"># 对使用了add添加到了暂存区的内容, 使用--staged参数或者--cached</div><div class="line">$ git diff --staged</div></pre></td></tr></table></figure>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 常规做法</div><div class="line">$ git commit -m &quot;commit message&quot;</div><div class="line"></div><div class="line"># 如果不使用-m参数添加提交信息, git会使用默认的编译器如vi进行提交描述编写.</div><div class="line"># 可通过$ git config --global core.edit 设定喜欢的编译器</div><div class="line"></div><div class="line"># 跳过暂存区操作, 直接从工作区提交到历史区</div><div class="line">$ git commit -a -m &quot;&quot;          #等价于: $ git commit -am &quot;&quot;</div></pre></td></tr></table></figure>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>如果在工作区间对一个文件进行删除, 需要先进行<code>add</code>,然后才可以提交. 使用<code>git rm</code>可以直接在工作区间删除文件, 并提交到暂存区.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git rm fileName</div><div class="line"></div><div class="line"># 如果文件修改,并添加了暂存区, 需要使用-f参数来强制删除(force)</div><div class="line">$ git rm -f fileName</div><div class="line"></div><div class="line"># 可以使用glob模式,如下</div><div class="line">$ git rm log/\*.log         # 删除log目录下所有名称是.log结尾文件</div><div class="line">$ git rm \*~                # 删除以~结尾的所有文件</div></pre></td></tr></table></figure>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>同样使用<code>git rm</code>会方便很多, 并且如果相对文件重命名也可以如此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git mv file_from file_to</div></pre></td></tr></table></figure>
<p>当执行了这条语句之后, 只需要在下一次<code>commit</code>即可, 不需要考虑额外操作. 等价于如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv file_from file_to</div><div class="line">$ git rm file_from</div><div class="line">$ git rm file_to</div></pre></td></tr></table></figure>
<h3 id="查看历史提交"><a href="#查看历史提交" class="headerlink" title="查看历史提交"></a>查看历史提交</h3><p>如果是最基本的<code>git log</code>, 那么会按提交时间列出所有更新, 包括提交的SHA-1校验和, 作者名称,邮箱,提交时间,提交说明. 下面说说常用选项.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -p:仅显示最近x次的提交  格式 $ git log -p -x</div><div class="line">$ git log -p -2             # 查看最近的两次提交内容</div><div class="line"></div><div class="line"></div><div class="line"># --stat:简略的显示每次提交的内容更改, 如哪些文件变更,多少删除,多少添加等</div><div class="line">$ git log --stat</div><div class="line"></div><div class="line"># --pretty: 指定默认不同格式展示信息</div><div class="line">$ git log --pretty=oneline              #每次提交用一行显示</div><div class="line"></div><div class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;  </div><div class="line"># 效果:1a99c42 - 苏, 19 hours ago : 无意义提交</div></pre></td></tr></table></figure>
<p><strong>关于format对应的常用占位符的写法和意义</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%H</td>
<td>提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td>%h</td>
<td>提交对象的简短哈希字串</td>
</tr>
<tr>
<td>%T</td>
<td>树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td>%t</td>
<td>树对象的简短哈希字串</td>
</tr>
<tr>
<td>%P</td>
<td>父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td>%p</td>
<td>父对象的简短哈希字串</td>
</tr>
<tr>
<td>%an</td>
<td>作者（author）的名字</td>
</tr>
<tr>
<td>%ae</td>
<td>作者的电子邮件地址</td>
</tr>
<tr>
<td>%ad</td>
<td>作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td>%ar</td>
<td>作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%cn</td>
<td>提交者(committer)的名字</td>
</tr>
<tr>
<td>%ce</td>
<td>提交者的电子邮件地址</td>
</tr>
<tr>
<td>%cd</td>
<td>提交日期</td>
</tr>
<tr>
<td>%cr</td>
<td>提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%s</td>
<td>提交说明</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>图形展示分支的合并历史</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log --graph --oneline   #oneline只是让输出看起来比较舒服</div></pre></td></tr></table></figure>
<hr>
<p><strong>git log的一些其他操作</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td>–stat</td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td>–shortstat</td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td>–name-only</td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td>–name-status</td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td>–abbrev-commit</td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td>–relative-date</td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td>–graph</td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td>–pretty</td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<p><strong>查找一个字符串的出现和删除的提交</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 使用限制符-S后面紧跟要查询的字符串</div><div class="line">$ git log -Smethod_name</div><div class="line"></div><div class="line"># 或者针对一个文件进行更改的提交查询, 只需要在后面追加文件名称即可</div><div class="line">$ git log fileName</div></pre></td></tr></table></figure>
<p>哈哈,即使如果你不小心写个隐藏bug不管几个月之后,如果老大要想找出问题是写引发的其实很简单.例如这样<br><code>$ git log -p fileName</code> 想甩锅?算了吧,还是认错以后多注意吧.</p>
<p><strong>还有一些限制log输出的选项</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-(n)</td>
<td>仅显示最近的 n 条提交</td>
</tr>
<tr>
<td>–since, –after</td>
<td>仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td>–until, –before</td>
<td>仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td>–author</td>
<td>仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td>–committer</td>
<td>仅显示指定提交者相关的提交。</td>
</tr>
<tr>
<td>–grep</td>
<td>仅显示含指定关键字的提交</td>
</tr>
<tr>
<td>-S</td>
<td>仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<p>一个实际的例子，如果要查看 Git 仓库中，2016 年 11 月1号到7号，作者叫苏的提交文件，可以用下面的查询命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log --pretty=&quot;%h - %s&quot; --author=苏 --since=&quot;2016-11-01&quot; \</div><div class="line">   --before=&quot;2016-11-07&quot;</div></pre></td></tr></table></figure>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p><strong>amend重新提交</strong></p>
<p>当我们<code>commit</code>之后突然发现漏掉了一个文件, 这个时候不可能对一个文件再进行<code>commit</code>一次, 这样做就显得很多余, 而如果版本回退之前再添加也比较麻烦. 这个时候就可以使用这个<code>amend</code>命令.如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git commit -m &quot;版本1.5开发代码&quot;</div><div class="line"></div><div class="line"># 正当你松了一口气的时候发现配置文件忘记修改了, 你赶紧修改,并适合用add到暂存区</div><div class="line">$ git add project.property</div><div class="line">$ git commit --amend         </div><div class="line"># 你会神奇的发现你没有增加任何多余的操作就把漏掉的文件补齐到最后一次提交中</div></pre></td></tr></table></figure>
<hr>
<p><strong>取消暂存的文件</strong></p>
<p>就是对文件进行了<code>git add</code>操作. 这个时候可以<code>reset</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 让暂存区的文件变成文件修改但是没有添加暂存区的状态</div><div class="line">$ git reset HEAD fileName</div></pre></td></tr></table></figure>
<p><strong>撤销对文件的修改</strong></p>
<p>场景: 当文件修改了, 但是还没有进行<code>git add</code>的时候还只是在工作区间, 还原成最后一次提交的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- filename</div></pre></td></tr></table></figure>
<p>要注意使用, 使用之前确定是否要抛弃已经添加的内容. 因为这个动作可能让你最新添加的内容彻底丢失. 因为没有进行<code>commit</code>, 一般来说进行了<code>commit</code>的内容都是可以恢复的.</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote>
<p>Git可以给历史中的某一个提交打上标签, 以示重要. 比如每次正式版本的上线等.</p>
</blockquote>
<p><strong>列出标签</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line"></div><div class="line"># 如果你只关心某一部分的标签, 例如只对v2.x的标签感兴趣,你可以这样做</div><div class="line">$ git tag -l &apos;v2.*&apos;</div></pre></td></tr></table></figure>
<hr>
<p><strong>创建标签</strong></p>
<p>标签分为两种一种是<code>附加标签</code>另一种是<code>轻量标签</code>.</p>
<ul>
<li>附加标签: 会保存打标签者的信息, 时间和附加信息. 最后更随打标签的提交</li>
<li>轻量标签: 只是在一个提交上做一个标记. 存储在一个专门保存标签的文件,指向提交的hash值</li>
</ul>
<p>先来看附加标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.0 -m &apos;附加信息&apos;</div></pre></td></tr></table></figure>
<p>轻量标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag v1.0</div></pre></td></tr></table></figure>
<p>后期打标签, 就是对已经提交某次提交进行追加标签设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 可以先使用git log --oneline获取提交历史的hash值</div><div class="line">$ git log --oneline</div><div class="line"></div><div class="line"># 然后把hash值赋值到标签语句之后</div><div class="line">$ git tag -a v1.1 a6b4c97</div></pre></td></tr></table></figure>
<p><strong>共享标签</strong></p>
<p>默认情况下, <code>git push</code>不会把标签传递到远程服务器. 需要显示的推送标签共享到服务器<br>例如: <code>git push origin [tagname]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin v1.4</div><div class="line"></div><div class="line"># 如果想把本地上所有在远程服务器上的不存在标签删除掉,可以这样</div><div class="line">$ git push origin --tags</div></pre></td></tr></table></figure>
<hr>
<p><strong>检出标签</strong></p>
<p>git中不能真正的检出一个标签, 但是可以在标签处创建一个新的分支.如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b checkbranch2 v2.0</div></pre></td></tr></table></figure>
<hr>
<p><strong>查看标签对应的信息</strong></p>
<p>使用<code>git show &lt;标签名&gt;</code>可以查看对应标签的详细信息, 如果<code>git show</code>这样的命令只是显示上次提交的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show v1.4</div></pre></td></tr></table></figure>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="分支的创建"><a href="#分支的创建" class="headerlink" title="分支的创建"></a>分支的创建</h3><p>分支的创建, 其实本质就是创建一个可以移动的指针,这个指针名就是新的分支名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git branch dev</div><div class="line"></div><div class="line"># 上面的只是创建了一个分支. 并没有切换, 可以使用一条命令创建并且换到新分支</div><div class="line">$ git checkout -b dev</div><div class="line"></div><div class="line"># 可以通过`git log`命令查看各个分支所指向的对象</div><div class="line">$ git log --oneline --decorate</div><div class="line"></div><div class="line"># 如果你想查看图形式的分叉历史,可以这样:</div><div class="line">$ git log --oneline --decorate --graph --all</div></pre></td></tr></table></figure>
<h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>所谓的分支切换就是<code>HEAD</code>指针的指向的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout dev</div></pre></td></tr></table></figure>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>利用<code>git merge &lt;要合并到的目标分支&gt;</code>, 这条命令会把当前所在分支与目标分支的内容合并, 可以这样理解, 如果当你试图向目标分支合并时, 如果当前分支可以顺着一个分支走下去, 那么本质上其实只是当前指针的向前移动, 由于这种情况下的合并并没有需要解决的分期, 所以git会称这个是<code>fast-forward</code>快速前进.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge dev</div></pre></td></tr></table></figure>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当一个功能分支开发完毕之后, 并进行了合并, 通常这个分支也就被删除,以保证仓库中的干净.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 删除dev分支</div><div class="line">$ git branch -d dev</div><div class="line"></div><div class="line"># 如果dev分支还有未提交的内容,为了保证你的数据安全git默认是不允许删除,可以使用`-D`强制删除</div><div class="line">$ git branch -D dev</div></pre></td></tr></table></figure>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>git branch</code>命令不只是可以创建于删除分支. 如果不添加任何参数, 那么会得到所有分支的一个列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git branch        # 其中一个分支前面的*代表,目前检出的分支就是HEAD指针所指向的分支</div><div class="line"></div><div class="line"># 追加-v参数 可以展示每一个分支最后一次提交</div><div class="line">$ git branch -v</div><div class="line"></div><div class="line"># --merged:查看那些分支已经合并到当前分支</div><div class="line">$ git branch --merged        # 一般这个列表展示的除了*号的其他分支, 都可以删除</div><div class="line"></div><div class="line"># --no-merged:查看所有包含未合并工作的分支</div><div class="line">$ git branch --no-merged</div></pre></td></tr></table></figure>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><blockquote>
<p>和合并<code>merge</code>相似的效果都是合并分支, 但是使用变基<code>rebase</code>可以让提交历史变得更简洁. 如下</p>
</blockquote>
<p><img src="http://szysky.com/2016/11/01/Git%E5%86%8D%E8%AF%86-%E4%B8%80-%E6%8B%A5%E6%8A%B1%E5%BC%80%E5%A7%8B/rebase_1.png" alt="img"></p>
<p><img src="http://szysky.com/2016/11/01/Git%E5%86%8D%E8%AF%86-%E4%B8%80-%E6%8B%A5%E6%8A%B1%E5%BC%80%E5%A7%8B/rebase_2.png" alt="img"></p>
<p>图片1是<code>merge</code>合并效果, 图片2是<code>rebase</code>合并效果. 明显变基会让提交历史看起来更加干净. 使用如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># rebase &lt;目标分支名&gt; [需要移动变基底的分支]</div><div class="line">$ git rebase master experiment </div><div class="line"> </div><div class="line"># 此时目标分支后面会追加另一个分支的提交. 此时只需要切换到master分支,合并分支即可.</div><div class="line">$ git checkout master</div><div class="line">$ git merge experiment</div></pre></td></tr></table></figure>
<p><code>rebase</code>原理就是, 从目标分支和要变基的分支向上查找出共同祖先节点就是<code>c2</code>, 然后把要变基的分支到<code>c2</code>节点的所有提交,提取出相应的修改生成一个副本, 并追加到目标分创建相对应的提交. 此时变基的分支指向<code>目标分支master</code>的后面某一次提交. 此时只要使用修改<code>master</code>指向指针使用<code>merge</code>即可.</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 获得远程的仓库列表</div><div class="line">$ git ls-remote origin</div><div class="line"></div><div class="line"># 如果想获得更多的信息</div><div class="line">$ git remote show origin</div><div class="line"></div><div class="line"># 查看远程分支和本地分支</div><div class="line">$ git branch -a</div></pre></td></tr></table></figure>
<hr>
<p><strong>拉取远程分支</strong></p>
<p>假设远程如果有一个<code>dev</code>分支, 你使用<code>fetch</code>进行抓取. 这个时候, 本地不会自动生成一个可编辑的副本, 换句话说就是这种情况下, 不会有一个新的<code>dev</code>本地分支, 只有一个不可以修改的<code>origin/dev</code>指针. 这个时候可以运行<code>git merge origin/dev</code>命令, 将这些远程dev分支的工作合并到当前分支. 如果想要在自己本地的dev分支上工作, 可以将其建立在远程分支之上.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b dev origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>创建远程分支</strong></p>
<p>如果你的本地有一个新建的<code>dev</code>分支, 并且你进行了提交, 此时你想把这个分支也提交到远程的<code>dev</code>分支, 但是远程还没有创建<code>dev</code>, 这个时候可以使用如下命令: <code>git push &lt;远程仓库名&gt; &lt;要推送的本地分支&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>删除远程分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 删除远程dev分支</div><div class="line">$ git push origin --delete dev</div></pre></td></tr></table></figure>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 <code>跟踪分支</code>（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入<code>git pull</code>，<code>Git</code> 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 <code>master</code> 分支。 最简单的就是之前看到的例子，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/dev</div><div class="line"></div><div class="line"># 如果想要自定义本地分支名字</div><div class="line">$ git checkout -b 任意分支名字 origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支</strong>，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 设置HEAD指向的分支的上游为远程dev分支</div><div class="line">$ git branch -u origin/dev</div></pre></td></tr></table></figure>
<hr>
<p><strong>查看设置的所有跟踪分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -vv</div></pre></td></tr></table></figure>
<h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git clone &lt;url&gt;</div><div class="line"></div><div class="line"># 如果你想创建自己的仓库名, 就是本地根文件夹的名称, 那么可以如下追加名称</div><div class="line">$ git clone &lt;url&gt; [dirName]</div></pre></td></tr></table></figure>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 默认查看远程仓库的方式</div><div class="line">$ git remote </div><div class="line"></div><div class="line"># 查看远程仓库的读写权限. 如果可以看到(push)说明提交的推送</div><div class="line">$ git remote -v</div></pre></td></tr></table></figure>
<p>如果需要查看某一个仓库更多的信息时, 使用<code>git remote show ...</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote show origin</div></pre></td></tr></table></figure>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 格式: git remote add [shortName] &lt;url&gt;  同时可以指定一个仓库的引用名称,例如</div><div class="line">$ git remote add rp git@github.com:suzeyu1992/GitOperateDemo.git</div><div class="line"></div><div class="line"># 此时你想对新加的远程进行拉取动作, 只需要使用之前的引用名称就可以</div><div class="line">$ git fetch rp</div></pre></td></tr></table></figure>
<h3 id="远程仓库的拉取推送"><a href="#远程仓库的拉取推送" class="headerlink" title="远程仓库的拉取推送"></a>远程仓库的拉取推送</h3><p><strong>拉取</strong></p>
<p>大家常用的可能是<code>git pull</code>这个指令. 这个指令的通常会从服务器上抓取数据自动尝试合并到当前所在分支.</p>
<p>而我们可以也可以利用<code>git fetch</code>进行本地分支所追踪的远程分支没有提交. 然后我们可以手动的进行合并.</p>
<p><strong>推送</strong></p>
<p><code>git push [remote-name] [branch-name]</code> 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>只有当对服务器有写入权限, 并且之前没有人提交, 这条命令才会生效.</p>
<p>上面的这两个推送也好拉取也好. 如果所在分支设置了远程服务器分支的追踪, 那么可以省略掉后面的仓库名和分支名. 如果没有设置那么必须显示的指定.</p>
<h3 id="远程仓库移除重命名"><a href="#远程仓库移除重命名" class="headerlink" title="远程仓库移除重命名"></a>远程仓库移除重命名</h3><p>对远程仓库的名称进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rename oldName newName</div></pre></td></tr></table></figure>
<p>想要移除一个远程仓库,例如服务器搬走了,不再使用一个特定镜像,或者一个贡献者不再贡献</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rm 仓库名</div></pre></td></tr></table></figure>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/git/git操作再识 拥抱开始/" data-id="cj7sum2vn0000wapjx5pq2h2v" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/git/git操作再识 拥抱开始/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap12_远程设备其余通信方式" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/">《Android 编程实战》Chap12_远程设备其余通信方式</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/">
            <time datetime="2017-09-12T00:00:31.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android中的连接技术"><a href="#Android中的连接技术" class="headerlink" title="Android中的连接技术"></a>Android中的连接技术</h2><p>大多数<code>Android</code>设备都支持多种连接技术. 通常, 例如<code>USB</code>, <code>蓝牙</code>, <code>Wi-Fi</code>.</p>
<ul>
<li><code>USB</code> 使用API通过USB进行原始串行通信, 或者使用谷歌专门为访问Android设备硬件配件定义的Android开放配件协议(Android Open Accessory Protocol, AOAP). AOAP是通过配件开发套件(Accessory Development Kit, ADK)支持的.</li>
<li><code>Bluetooth</code> Android设备都支持经典蓝牙配置文件(Classic Bluetooth Protocol), 它适合更耗电的操作, 比如视频流. <code>Android 4.3</code>开始支持蓝牙低功耗以及蓝牙智能(Bluetooth Smart)技术, 它能够和支持GATT配置的设备进行通信(如心脏检测器,计步器以及其他低功率配件)</li>
<li><code>Wi-Fi</code> 比如需要更多数据密集型通信的场景, <code>Android</code>支持三种Wi-Fi操作模式: <code>infrastructure(连接到一个接入点的的标准wifi)</code>, <code>网络共享(android设备充当其他设备wifi的接入点)</code>, <code>WiFi-Direct</code>这个模式比较有趣, 在一些新的设备可以和<code>infrastructure</code>模式进行并行工作. 允许应用程序建立对等的wifi网络, 而不需要专门的访问点.</li>
</ul>
<h2 id="Android-USB"><a href="#Android-USB" class="headerlink" title="Android USB"></a>Android USB</h2><p>Android中<code>USB</code>相关的API位于<code>android.hardware.usb</code>包. 如果需要usb外设的了解可以查看官网文档的usb/accessory相关介绍.</p>
<p>在<code>USB</code>的设计中, 会有一个设备充当<strong>主机</strong>. 除了其他功能, 主机还可以给所连接的设备供电, 这就是不需要给USB鼠标添加额外的电池, 以及可以使用笔记本上的USB端口给智能手机充电的原因.</p>
<p><code>Android设备</code>也可以作为USB主机为外部设备充电, 这意味着可以把例如读卡器,指纹扫描,以及其他usb外设连接到手机设备上.</p>
<p>了解一下就好了如果需要更多, <a href="https://developer.android.com/guide/topics/connectivity/usb/index.html" target="_blank" rel="external">参考资料</a></p>
<h2 id="蓝牙低功耗"><a href="#蓝牙低功耗" class="headerlink" title="蓝牙低功耗"></a>蓝牙低功耗</h2><p>在<code>Android 4.3</code>开始支持蓝牙智能, 包括心率监视器, 活动跟踪器等蓝牙低功耗<code>BLE</code>设备的支持.</p>
<p>如果需要<code>蓝牙低功耗</code>比较感兴趣, 可以查看<a href="http://szysky.com/2016/10/08/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B12-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">博客的android蓝牙系列</a></p>
<h2 id="Android-Wi-Fi"><a href="#Android-Wi-Fi" class="headerlink" title="Android Wi-Fi"></a>Android Wi-Fi</h2><p><code>Wi-Fi</code>是Wi-Fi联盟管理的各种技术的统称. <code>Wi-Fi Direct</code>是运行在802.11n标准之上的额外技术. 使用该技术的设备不需要专门的连接点, 这点和蓝牙很相似, 不过<code>Wi-Fi Direct</code>使用高速的<code>Wi-Fi</code>进行通信.</p>
<p>但是, 即使设备都不再同一个<code>Wi-Fi</code>, 为了建立连接仍然需要发现它们. 发现意味着找到运行服务的设备的ip地址. Android已经内置了网络发现API, 支持标准的<code>Wi-Fi(infrastructure)和Wi-Fi Direct</code>, 可以让设备发现使用<code>DNS-SD</code>协议声明的服务.</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>Android提供了标准的发现机制, 允许开发者宣布自己的服务以及发现本地网络上的服务. 该实现包括两个标准: <code>mDNS和DNS-SD</code>. <code>mDNS</code>是一个多播协议, 使用UDP组播协议宣布和发现主机. <code>DNS-SD</code>是一个服务发现协议, 用于宣布和发现运行在远程主机(通常限于本地网络)的服务. 可以通过<code>android.net.nsd</code>包以及<code>NsdManager</code>使用这些功能.</p>
<p>以下代码可以来声明一个设备中的服务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  声明设备中标准Wi-Fi的服务</div><div class="line">*/</div><div class="line">private void announceService()&#123;</div><div class="line">   NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">   NsdServiceInfo nsdServiceInfo = new NsdServiceInfo();</div><div class="line">   nsdServiceInfo.setPort(8081);</div><div class="line">   nsdServiceInfo.setServiceName(&quot;wifi服务哦&quot;);</div><div class="line">   nsdServiceInfo.setServiceType(&quot;_http._tcp.&quot;);</div><div class="line"></div><div class="line">   nsdManager.registerService(nsdServiceInfo, NsdManager.PROTOCOL_DNS_SD, new NsdManager.RegistrationListener() &#123;</div><div class="line">       @Override</div><div class="line">       public void onRegistrationFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line">           Log.e(TAG, &quot;onRegistrationFailed: &quot; );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onUnregistrationFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line">           Log.e(TAG, &quot;onUnregistrationFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceRegistered(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.e(TAG, &quot;onServiceRegistered: &quot; );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceUnregistered(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.e(TAG, &quot;onServiceUnregistered: &quot; );</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Note: 如果不给设置服务名, 那么会使用wifi网络中的设备IP地址. mDNS的服务类型必须是一个有效的类型. 再调用了注册方法后, <code>NsdManager</code>开始宣布在本地<code>Wi-Fi</code>上的服务, 当注册状态发生变化后会触发监听回调.</p>
<p>如果要发现一个服务, 使用同样的API实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*  发现一个服务</div><div class="line">*/</div><div class="line">private void discoverService()&#123;</div><div class="line">   NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">   nsdManager.discoverServices(&quot;_http._tcp.&quot;, NsdManager.PROTOCOL_DNS_SD, new NsdManager.DiscoveryListener() &#123;</div><div class="line">       @Override</div><div class="line">       public void onStartDiscoveryFailed(String serviceType, int errorCode) &#123;</div><div class="line">           Log.d(TAG, &quot;onStartDiscoveryFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onStopDiscoveryFailed(String serviceType, int errorCode) &#123;</div><div class="line">           Log.d(TAG, &quot;onStopDiscoveryFailed: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onDiscoveryStarted(String serviceType) &#123;</div><div class="line">           Log.d(TAG, &quot;onDiscoveryStarted: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onDiscoveryStopped(String serviceType) &#123;</div><div class="line">           Log.d(TAG, &quot;onDiscoveryStopped: &quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceFound(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.d(TAG, &quot;onServiceFound&quot;);</div><div class="line">           NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE);</div><div class="line">           nsdManager.resolveService(serviceInfo, new NsdManager.ResolveListener() &#123;</div><div class="line">               @Override</div><div class="line">               public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) &#123;</div><div class="line"></div><div class="line">               &#125;</div><div class="line"></div><div class="line">               @Override</div><div class="line">               public void onServiceResolved(NsdServiceInfo serviceInfo) &#123;</div><div class="line">                   Log.w(TAG, &quot;主机: &quot;+serviceInfo.getHost() +&quot;      端口:&quot;+serviceInfo.getPort() );</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void onServiceLost(NsdServiceInfo serviceInfo) &#123;</div><div class="line">           Log.d(TAG, &quot;onServiceLost: &quot;);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意, 需要使用服务类型来搜索服务, 一旦服务的状态发生变化(发现和丢失某些东西, 启动和停止发现服务)都会收到回调. 如果需要解析更详细的信息, 通过<code>NsdManager#resolverService()</code>方法来解析. 解析成功会回调函数.</p>
<p>通过<code>NsdManager</code>使用网络发现服务可以在不强制用户手动输入IP地址的情况下和本地设备进行通信. 当要创建共享数据的应用或者建立一个本地多人游戏时, 这是一个选择项.</p>
<h3 id="Wi-Fi-Direct"><a href="#Wi-Fi-Direct" class="headerlink" title="Wi-Fi Direct"></a>Wi-Fi Direct</h3><p><code>Wi-Fi Direct</code>是Wi-Fi联盟802.11标准的一部分, 允许在设备间进行高速的Wi-Fi通信, 而不需要专门的接入点. 它基本上是一个采用Wi-Fi技术的对等协议. 所有运行2.3及后续版本的设备都支持<code>Wi-Fi Direct</code>, 但是知道<code>Android 4.1</code>以及网络服务发现API的引入, 开发人员才真正对<code>Wi-Fi Direct</code>变得感兴趣.</p>
<p>在运行<code>Android 4.0</code>或更高的版本的设备上, 通常可以并行地运行<code>Wi-Fi Direct</code>, 这意味着设备可以同时支持<code>Wi-Fi Direct</code>以及普通的<code>Wi-Fi</code>.</p>
<p>主要API<code>WifiP2pManager</code> 来在一端设备创建并发布服务并监听变化, 另一端通过监听对等的设备并使用<code>WifiP2pServiceRequest</code>来搜索, 当搜索到可用符合的设备进行连接. 当两个设备建立连接, 服务端的注册的广播就会接收到通知. 并进行后续操作处理.</p>
<p>使用<code>WiFi Direct</code>最主要的原因是不需要现有的WIFI基础设施. 同时, 由于建立过程不需要额外的PIN码或者密码, 使用这种方式连接设备会很容易.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/" data-id="cj7hnifdv00146opje8f2zhjj" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap12_远程设备其余通信方式/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap11_网络 Web服务" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/">《Android 编程实战》Chap11_网络 Web服务</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/">
            <time datetime="2017-09-11T23:59:43.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android上的网络调用"><a href="#Android上的网络调用" class="headerlink" title="Android上的网络调用"></a>Android上的网络调用</h2><p>虽然<code>Android</code>同时支持<code>TCP</code>和<code>UDP</code>通信, 但应用程序的大部分网络调用都是建立在<code>TCP</code>之上的<code>HTTP</code>请求完成的.</p>
<p>网络操作的两个比较重要的规则:</p>
<ol>
<li>永远不要在主线程做耗时操作</li>
<li>在<code>Service</code>而不是<code>Activity</code>中执行网络操作. 因为有很多情况下, 在<code>Activity</code>中执行网络操作, 很多时候需要考虑<code>Activity</code>快速切换的状态. 比如用户按了主屏幕键, 然后1秒后又回到了应用程序.</li>
</ol>
<h3 id="HttpUrlConnection"><a href="#HttpUrlConnection" class="headerlink" title="HttpUrlConnection"></a>HttpUrlConnection</h3><p><code>Android</code>提供了两个用于<code>HTTP</code>通信的API. <code>Apache</code>的<code>HttpClient</code>和<code>HttpUrlConnection</code>. 两者都能提供相同的功能. 但是推荐<code>HttpUrlConnection</code>, 因为谷歌一直在对其维护. 比如透明的响应压缩, 响应缓存.</p>
<p><code>Android 4.0(ICS)</code>提供响应缓存功能, 所以如果要支持早期的版本, 开发者需要使用手动实现通过反射来初始化缓存. 如果应用最低支持4.0, 那么使用以下代码开启.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpResponseCache httpResponseCache = HttpResponseCache.install(new File(getCacheDir, &quot;http&quot;), CACHE_SIZE);</div></pre></td></tr></table></figure>
<p>为应用选择一个合适的缓存大小. 如果只获取少量的数据, 可以选择几兆大小的缓存. 缓存对应用程序是私有的, 所以相对来说是比较安全的.</p>
<p>比如说<code>HTTP GET</code>请求, <a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/blob/0d16eb99528aa7ed7bfc238e881222879ab7d95f/Network/app/src/main/java/com/szysky/note/network/HTTPGet.java" target="_blank" rel="external">可以看事例代码</a></p>
<p><strong>或者说上传文件</strong></p>
<p>比如说传送图片或者其他文件到服务器, 由于Java API并没有提供一个可以直接上传文件的的方法. 使用HTTP发送数据涉及使用<code>HTTP POST</code>发送<code>body</code>中的数据. 而body需要设置一些特殊的格式, 并且还要正确地设置<code>header</code>字段. 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">private static final long MAX_FIXED_SIZE = 5 * 1024 * 1024;</div><div class="line">private static final String CRLF = &quot;\r\n&quot;;</div><div class="line">/**</div><div class="line">*  使用HTTP POST往服务器发送文件</div><div class="line">*/</div><div class="line">public int postFileToURL(File file, String mimeType, URL url) throws IOException &#123;</div><div class="line"></div><div class="line">   DataOutputStream requestData = null;</div><div class="line">   try &#123;</div><div class="line">       long fileSize = file.length();</div><div class="line">       String fileName = file.getName();</div><div class="line"></div><div class="line">       // 创建一个随机边界符字符串</div><div class="line">       Random random = new Random();</div><div class="line">       byte[] randomBytes = new byte[16];</div><div class="line">       random.nextBytes(randomBytes);</div><div class="line">       String boundary = Base64.encodeToString(randomBytes, Base64.NO_WRAP);</div><div class="line"></div><div class="line">       // 配置请求设置</div><div class="line">       HttpURLConnection uc = (HttpURLConnection) url.openConnection();</div><div class="line">       uc.setUseCaches(false);</div><div class="line">       uc.setDoOutput(true);           // 设置可以发送数据</div><div class="line">       uc.setRequestMethod(&quot;POST&quot;);</div><div class="line"></div><div class="line">       // 设置HTTP header</div><div class="line">       uc.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</div><div class="line">       uc.setRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</div><div class="line">       uc.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data;boundary=&quot;+boundary);</div><div class="line"></div><div class="line">       // 如果文件大于max_fixed_size, 使用分块流模式</div><div class="line">       if (fileSize &gt; MAX_FIXED_SIZE)&#123;</div><div class="line">           uc.setChunkedStreamingMode(0);</div><div class="line">       &#125;else&#123;</div><div class="line">           uc.setFixedLengthStreamingMode((int)fileSize);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // 打开文件方便读取</div><div class="line">       FileInputStream fileIn = new FileInputStream(file);</div><div class="line">       // 打开服务器连接</div><div class="line">       OutputStream out = uc.getOutputStream();</div><div class="line">       requestData = new DataOutputStream(out);</div><div class="line"></div><div class="line">       // 开始写数据</div><div class="line">       // 首先写入第一个边界符</div><div class="line">       requestData.writeBytes(&quot;--&quot; +boundary + CRLF);</div><div class="line">       // 让服务器知道文件名</div><div class="line">       requestData.writeBytes(&quot;Content-Disposition: form-data; name=\&quot;&quot;+ fileName + &quot;\&quot;; filename=\&quot;&quot;+fileName + CRLF);</div><div class="line">       // 文件的MIME类型</div><div class="line">       requestData.writeBytes(&quot;Content-Type: &quot;+mimeType + CRLF);</div><div class="line"></div><div class="line">       // 循环读取本地文件, 并写入服务器</div><div class="line">       int bytesRead;</div><div class="line">       byte[] buffer = new byte[8 * 1024];</div><div class="line">       while((bytesRead = fileIn.read(buffer)) != -1)&#123;</div><div class="line">           requestData.write(buffer, 0, bytesRead);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // 写入边界字符串, 表明已到文件结尾</div><div class="line">       requestData.writeBytes(CRLF);</div><div class="line">       requestData.writeBytes(&quot;--&quot; +boundary +&quot;--&quot;+ CRLF);</div><div class="line">       requestData.flush();</div><div class="line"></div><div class="line">       return uc.getResponseCode();</div><div class="line"></div><div class="line">   &#125; catch (IOException e) &#123;</div><div class="line">       e.printStackTrace();</div><div class="line">   &#125;finally &#123;</div><div class="line">       if (requestData != null)&#123;</div><div class="line">           requestData.close();</div><div class="line">       &#125;</div><div class="line">       return -1;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码, 需要要知道如何使用边界字符串告诉服务器文件的开始和结束位置. 另外上面还通过检查文件的大小而决定是<code>使用分块流模式(chunked streaming mode)</code>,还是<code>使用固定长度流模式</code> . 对于<code>分块流模式</code>参数0表示系统的默认大小, 这是大多数程序在该模式下的大小. 分块基本上意味着数据分部分发送数据, 每一部分都附有该块大小. 分块能更有效地使用内存, 并较少oom异常的分享, 然而, 使用固定长度的数据流模式通常更快, 但它需要更多的内存.</p>
<h3 id="OkHttp和SPDY"><a href="#OkHttp和SPDY" class="headerlink" title="OkHttp和SPDY"></a>OkHttp和SPDY</h3><p><code>HTTP</code>的一个大问题就是每个连接只允许一个请求和响应, 这迫使浏览器和其他客户端为了并行请求必须生成多个<code>套接字socket</code>连接. 虽然对于客户端连接问题就不那么大了, 但是如果是服务器端那么面临的状态就不同而语了. 在2009年, 谷歌开始着手更新<code>HTTP协议</code>来解决这些问题. 其结果就是<code>SPDY协议</code>, 它允许在一个套接字连接上发送多个<code>HTTP请求</code>. 该协议已成为下一代<code>HTTP</code>事实上的开放标准, 但它不会取代<code>HTTP</code>, 而是改良了如何通过网络请求和响应. 而<code>HTTP IETF</code>工作组日前已宣布即将开始<code>HTTP 2.0</code>的工作, 并使用<code>SPDY协议</code>作为起点.</p>
<p>如果同时开始客户端和服务端代码, 研究一下使用<code>SPDY</code>来代替常规的<code>HTTP/1.1</code>还是不错的, 因为<code>SPDY</code>能显著降低网络负载, 并能提高性能. 主流浏览器目前已经很好地支持<code>SPDY</code>, 并且已经有很多平台的实现版本, 启动就包括<code>Android</code>.</p>
<p>如果选择<code>SPDY</code>作为通信协议, 建议使用<code>OkHttp</code>, 它是<code>Square</code>公司开发的, 该库只是一个支持<code>SPDY</code>的新改进的<code>HTTP</code>客户端. 内部使用<code>HttpUrlConnection</code>接口.</p>
<p>当初始化<code>OkHttpClient</code>实例时, 它会初始化所有的东西, 比如连接池和响应缓存. 即使是普通的HTTP请求, 该实现也非常快, 使用OkHttp进行SPDY通信能显著提升网络调用的性能.</p>
<h3 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h3><p>运行标准的HTTP之上, 是HTTP的扩展. <code>Web Socket</code>允许在客户端和服务器端之前进行基于消息的异步通信. 首先客户端发送一个常规的<code>HTTP GET</code>请求, 该请求包含特殊的<code>HTTP请求头</code>, 表明客户端希望把连接升级为<code>Web Socket</code>连接.</p>
<p>如下当使用<code>Web Socket</code>时,客户端发送的请求示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /websocket HTTP/1.1</div><div class="line">Host: myserver.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: xxxxxxxxxxxxxxxxxx==</div><div class="line">Sec-WebSocket-Protocol: chat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://myserver.com</div></pre></td></tr></table></figure>
<p>如果接收客户端的请求, 下面是服务器对请求的响应:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: xxxxxxxxxxxxxxxxxxx=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<blockquote>
<p>客户端的请求头中的值并不是对每一种情况都有效, 而应根据Web Socket协议规范来计算. 通常情况下, 如果使用现成的<code>Web Socket</code>通信库, 开发者就不需要考虑这些情况.</p>
</blockquote>
<p>当<code>Web socket</code>连接建立后, 双方可以给对方发送异步消息. 通信的消息可以是文本, 或者二进制, 通常数据量是很小的. 如果需要传输大的文件, 最好还是使用标准的<code>Http</code>. <code>Web socket</code>用于发送符合相对较小的通知.</p>
<p>关于使用, 可以使用<code>Android</code>中标准的<code>Socket</code>类来实现自己的<code>Web Socket</code>客户端, 但也可以使用现有的第三方库. 比如由<code>Nathan Rajlich</code>为Java实现的WebSocket. 可以看<a href="http://java-websocket.org/" target="_blank" rel="external">介绍</a>. 另外, 这个库还包含了一个服务器的实现.</p>
<h2 id="网络和功耗"><a href="#网络和功耗" class="headerlink" title="网络和功耗"></a>网络和功耗</h2><p>手机功耗, 一般手机中消耗第一应该是屏幕, 然后第二往往和网络流量有关.</p>
<p>智能手机的无线硬件如WiFi和蜂窝网络芯片都有内置省电功能, 他们能在网络流量不活跃时自动关闭连接, 并能把功耗降到一个非常低的水平. 当应用程序要发送数据或者等待接收输入数据和包时, 网络硬件将禁用省电模式, 以便能尽可能快速和有效地发送数据.</p>
<h3 id="一般准则"><a href="#一般准则" class="headerlink" title="一般准则"></a>一般准则</h3><p>在请求网络前, 首先考虑用户目前是否确实需要这些数据. 其次考虑是否需要全部数据, 或者只是数据的前十条而已, 如果服务器也可以进行gzip压缩, 要记得打开透明压缩, 并选择数据的数据格式, 例如json.</p>
<h3 id="高效的网络轮询"><a href="#高效的网络轮询" class="headerlink" title="高效的网络轮询"></a>高效的网络轮询</h3><p>网络轮询有几个缺点, 但是有时只能使用轮询来完成在线服务器的新数据的检查. 这时就别忘了<code>AlarmManager</code>这个API可以方便的进行轮询.</p>
<h3 id="服务器端推送"><a href="#服务器端推送" class="headerlink" title="服务器端推送"></a>服务器端推送</h3><p>减少网络调用次数最好的解决办法就是使用服务器端推送. 这样可以让服务器主动通知客户端有新的数据需要检索. 服务器端推送可以有很多种方式, 它可以不直接连接互联网(比如监听短信), 也可以是长期保持获取的常规TCP套接字连接.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/" data-id="cj7hnifdt00126opj74bshbyk" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap11_网络 Web服务/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap10_隐藏的Android API" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/">《Android 编程实战》Chap10_隐藏的Android API</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/">
            <time datetime="2017-09-11T23:59:03.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="官方API和隐藏API"><a href="#官方API和隐藏API" class="headerlink" title="官方API和隐藏API"></a>官方API和隐藏API</h2><p>SDK文档中的所有类, 接口, 方法以及常量都属于官方API. 虽然这些API通常能满足大多数应用的需求, 但开发者有时候需要访问更多的东西, 但却不知道如何在官方API中找到它们.</p>
<p><code>Android SDK</code>中包含了一个<code>JAR</code>文件(android.jar), 在编译代码的时候会引用它, 该文件位于<code>&lt;sdk root&gt;/platforms/android-&lt;API Level&gt;/目录</code>. 不过这里面全是空类, 方法中所有的代码都被移除了, 只声明了<code>public</code>和<code>protected</code>的类. 构建Android平台时, SDK会包含该JAR文件.</p>
<p>通过检查每一个源文件, 并移除所有被<code>@hide</code>注解的域(常量), 方法和类, 在构建SDK时会生成方法体为空的<code>android.jar</code>文件. 这意味着仍然可以在运行的设备上方法这些符号, 但是在编译时却找不到.</p>
<p>Android会自动隐藏某些API, 而不需要使用<code>@hide</code>注解. 这些API位于<code>com.android.internal</code>包中, 不属于<code>android.jar</code>文件, 但却包含大量供android平台使用的内部代码. android系统应用还包含一些其他隐藏API, 这些API通常提供没有包含在官方SDK中的系统<code>ContentProvider</code>信息.</p>
<h2 id="发现隐藏API"><a href="#发现隐藏API" class="headerlink" title="发现隐藏API"></a>发现隐藏API</h2><p>寻找API最简单的方法是在<code>Android</code>源码中搜索他们. 但是<code>Android</code>源码非常多, 还好有几个在线网站已经对这些代码进行了索引, 并提供了搜索功能. <a href="http://androidxref.com/" target="_blank" rel="external">AndroidXRef</a>就是其中的一个.</p>
<p>大部分隐藏的API都位于<code>frameworks</code>项目, 所有<code>android</code>包中的API都可以在frameworks项目中找到, 该项目还包含大部分<code>com.android.internal</code>包中的API.</p>
<h2 id="安全地调用隐藏API"><a href="#安全地调用隐藏API" class="headerlink" title="安全地调用隐藏API"></a>安全地调用隐藏API</h2><p>对于需要编译时链接的API, 也就是接口, 类, 或者方法, 开发者有两个选择. 第一种修改SDK的JAR文件, 使之包含所有需要的类和接口, 并使用该SDK来编译应用程序. 另一种解决方案是使用<code>Java</code>反射API来动态查找要调用的类和方法. 两种方法都可以利弊.</p>
<h3 id="从设备中提取隐藏API"><a href="#从设备中提取隐藏API" class="headerlink" title="从设备中提取隐藏API"></a>从设备中提取隐藏API</h3><p>要做到编译时链接隐藏API, 开发者首先要提取和处理设备中的库文件. 即可以从模拟器提取库文件, 也可以从设备中提取这些文件, 因为它们只是用来编译代码. 由于这个过程需要提取出大量文件, 建议单独创建一个空的工作目录. 另外可能要提取多个版本的库文件, 所以开发者还应为每个API级别创建一个工作目录.</p>
<p><img src="http://szysky.com/2016/10/04/%E3%80%8AAndroid-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B10-%E9%9A%90%E8%97%8F%E7%9A%84Android-API/devicespull.png" alt="img"></p>
<p>这里会把设备的<code>/system/framework</code>目录全部拉取出来, 这些文件都是Android设备上基于Java的系统库, 他们是由<code>Dalvik</code>虚拟机加载的Dex优化文件. 下一步决定哪些文件包含隐藏API, 以便把它们转成可以在编译时使用的Java类文件. 大部分隐藏API都位于<code>framework.odex</code>文件, <code>bouncycastle.odex</code>文件包含了加密的库.</p>
<blockquote>
<p>从Android 4.2开始, 原来位于<code>framework.odex</code>的几个隐藏API都放在了其他文件中. 例如<code>Telephony</code>类现在是可选的了(因为并不是所有的Android设备都支持电话), 可以在<code>telephony-common.odex</code>文件中找到它.</p>
</blockquote>
<p>一旦知道需要转换的文件, 就可以下载<code>Smali</code>工具, 它能把优化后的Dex文件(.odex)转换为中间格式(.smali). 接下来使用<code>dex2Jar</code>工具再把这种中间格式转换回Java类文件.</p>
<hr>
<p><strong>修改SDK的错误处理</strong></p>
<p>当使用前面介绍的隐藏API方法时, 很难确定抽取类的方法签名是否和用户设备中相应的方法签名匹配. 虽然修改后的SDK可能在开发用的设备上正常工作, 但是用户的设备制造商可能修改了这些隐藏API. 当这种情况发生时, 应用程序会抛出<code>NoSuchMethodException</code>或者<code>ClassNotFoundException</code>异常.</p>
<p>有几种方法可以处理种种情况. 可以结合使用反射来检测是否存在隐藏API. 推荐使用这种方式, 因为它结合了两种方法的优点. 另一种方法是简单地捕获异常, 防止应用程序崩溃.</p>
<p>不管使用哪一种方法, 都是要确保调用隐藏API的时候发生错误的处理. 最起码可以确保应用程序在测试过的设备上能正常工作.</p>
<h3 id="使用反射调用隐藏API"><a href="#使用反射调用隐藏API" class="headerlink" title="使用反射调用隐藏API"></a>使用反射调用隐藏API</h3><p>使用Java中的反射API比修改<code>Android SDK</code>更安全, 因为它可以在调用<code>隐藏API</code>前检测它们是否存在. 但是, 由于所有隐藏API的绑定和调用都发生在运行时, 反射会比前面介绍的方法更慢.</p>
<p>使用反射调用隐藏API需要两步. 首先, 需要查找要调用的类和方法, 并把他们的引用存到<code>Method</code>对象中. 当持有了引用后, 接下来就可以调用对象的方法.</p>
<p>后面会演示了查找Wi-Fi网络共享的例子.</p>
<h2 id="隐藏API的使用"><a href="#隐藏API的使用" class="headerlink" title="隐藏API的使用"></a>隐藏API的使用</h2><h3 id="接收和阅读SMS"><a href="#接收和阅读SMS" class="headerlink" title="接收和阅读SMS"></a>接收和阅读SMS</h3><p><code>Android</code>中使用隐藏API最常见的例子是接收和阅读<code>SMS</code>, 虽然官方API包含了<code>RECEIVE_SMS</code>和<code>READ_SMS</code>这两个权限, 但实际执行的API却是隐藏的.</p>
<p>应用程序要想接收<code>SMS</code>必须声明使用<code>RECEIVE_SMS</code>权限, 并且实现<code>BroadcastReceiver</code>, 已处理收到的短信.</p>
<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 清单文件</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;</div><div class="line"></div><div class="line">&lt;receiver android:name=&quot;.hideapi.SmsReceiver&quot;&gt;</div><div class="line">  &lt;intent-filter&gt;</div><div class="line">      &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;</div><div class="line">  &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class SmsReceiver extends BroadcastReceiver &#123;</div><div class="line">    // Telephony.java 中隐藏的常量</div><div class="line">    public static final String SMS_RECEIVED_ACTION</div><div class="line">            = &quot;android.provider.Telephony.SMS_RECEIVED&quot;;</div><div class="line"></div><div class="line">    public static final String MESSAGE_SERVICE_NUMBER = &quot;+461234567890&quot;;</div><div class="line">    private static final String MESSAGE_SERVICE_PREFIX = &quot;MYSERVICE&quot;;</div><div class="line"></div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        String action = intent.getAction();</div><div class="line">        if (SMS_RECEIVED_ACTION.equals(action)) &#123;</div><div class="line">            // 通过 pdus 获取SMS数据的隐藏键</div><div class="line">            Object[] messages =</div><div class="line">                    (Object[]) intent.getSerializableExtra(&quot;pdus&quot;);</div><div class="line">            for (Object message : messages) &#123;</div><div class="line">                byte[] messageData = (byte[]) message;</div><div class="line">                SmsMessage smsMessage =</div><div class="line">                        SmsMessage.createFromPdu(messageData);</div><div class="line">                Log.e(&quot;haha&quot;, &quot;收到消息来自: &quot;+smsMessage.getOriginatingAddress()+ &quot;   内容:&quot;+smsMessage.getMessageBody());</div><div class="line"></div><div class="line">                processSms(smsMessage);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只关心指定的电话号码</div><div class="line">    private void processSms(SmsMessage smsMessage) &#123;</div><div class="line">        String from = smsMessage.getOriginatingAddress();</div><div class="line">        if (MESSAGE_SERVICE_NUMBER.equals(from)) &#123;</div><div class="line">            String messageBody = smsMessage.getMessageBody();</div><div class="line">            if (messageBody.startsWith(MESSAGE_SERVICE_PREFIX)) &#123;</div><div class="line">                // TODO: 数据验证通过开始处理</div><div class="line">                Log.e(&quot;haha&quot;, &quot;processSms: &quot;+messageBody);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面利用广播监听<code>Intent</code>操作<code>android.provider.Telephony.SMS_RECEIVED</code>. 这个例子中唯一隐藏的部分就是<code>Intent</code>的action. 以及用来从<code>Intent(&quot;pdus&quot;)</code>检索SMS数据的字符串.</p>
<p>要读取已经收到的<code>SMS</code>, 需要查询一个隐藏的<code>ContentProvider</code>, 并声明使用<code>READ_SMS</code>权限. <code>android.provider</code>包中的<code>Telephony</code>类提供了所有需要的信息. 使用该类最佳的方式是把它复制到自己的项目中, 并修改类的包结构. 由于<code>Telephony</code>类还包含其他隐藏类和方法的调用, 所以还必须删除或者重构这些调用, 以便能够编译代码. 取决于使用<code>隐藏API</code>的数量, 有时候简单复制一些常量声明而不是整个类就足够了.</p>
<p>阅读的部分就省略了, 除了某些特定方向的应用, 基本上应用是不会去读入用户的短信.</p>
<h3 id="隐藏设置"><a href="#隐藏设置" class="headerlink" title="隐藏设置"></a>隐藏设置</h3><p><code>Android</code>设备有数百种不同的设置, 都可以通过<code>Settings</code>类访问, 除了为每个设置提供访问的值, <code>Android</code>还提供给了一些类<code>Intent</code>操作, 使他们可以打开特定的设置UI. 例如, 要启动飞行模式设置, 在创建Intent时可以使用<code>Settings.ACTION_AIRPLANE_MODE_SETTINGS</code></p>
<p><code>Settings</code>类包含了一些隐藏的设置键和Intent操作, 当应用程序需要弄清楚设备的细节或者呈现一个特定系统设置的快捷方式时, 启动的一些常量值是非常方便的.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/" data-id="cj7hnifdn000z6opjbxygt8n1" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap10_隐藏的Android API/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap9_Android应用安全问题" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/">《Android 编程实战》Chap9_Android应用安全问题</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/">
            <time datetime="2017-09-11T23:57:47.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="Android安全的概念"><a href="#Android安全的概念" class="headerlink" title="Android安全的概念"></a>Android安全的概念</h2><p><code>Android</code>具备一个先进的安全模型来保护应用数据和服务不被其他应用访问. 每个应用都有自己的唯一<code>ID</code>来提供最基本的保护. 每个应用都经过它唯一的密钥签名, 这种机制是<code>Android</code>框架中的安全模型基础. 此外只有当其他应用在清单文件中显式声明了正确权限后, <code>Android</code>的权限系统才会和他们共享特定的组件. 应用也可以定义权限, 比如只有使用同一个密钥签名的应用才能使用它们. 最后<code>Android</code>的API提供了各种方法来验证签名, 验证调用进程的用户ID和使用强加密方案.</p>
<h3 id="签名和密钥"><a href="#签名和密钥" class="headerlink" title="签名和密钥"></a>签名和密钥</h3><p><code>Android</code>系统中运行的所有应用都要用密钥来签名, 包括<code>Android</code>系统本身.</p>
<p>可以用同一个密钥来对发布的所有应用进行签名, 但建议为各个应用单独创建一个密钥. 多个应用共享一个密钥通常是因为这些应用要直接访问彼此的数据, 或者设定权限时将保护等级改为<code>signature</code></p>
<p>下面是一种为应用生成密钥的一个方式, 有一种比较好的方式是使用应用的包名作为别名传给<code>-alias</code>.</p>
<p><code>$ keytool -genkey -v -keystore &lt;keystore filename&gt; -alias &lt;alias for key&gt; keyalg RSA -keysize 2048 -validity 10000</code></p>
<p>在生成新密钥时, <code>keytool</code>会让你输入一个密码.</p>
<h3 id="Android权限"><a href="#Android权限" class="headerlink" title="Android权限"></a>Android权限</h3><p>要在<code>Android</code>中使用特殊权限功能, 只要在清单文件中加入一个<code>uses-permission</code>标记即可. 它会告诉系统你的应用需要该项权限, 并在安装时通知用户这项需求.</p>
<p><code>Android</code>中定义了五个保护等级: <code>常规normal</code>, <code>危险dangerous</code>, <code>同一签名signature</code>, <code>同一签名或系统signatureOrSystem</code>, <code>系统system</code>. 除非特殊指定, 默认等级一般为常规. 用来告知系统有应用要用到这个权限的函数. 只有将权限设为危险时, 它才会在用户安装(通常是通过Google Play Store)前提醒用户.</p>
<ul>
<li><code>同一签名</code>保护等级要求应用使用跟定义该权限的应用相同的同一证书来签名. 这对设备制造商来说非常有用, 因为他们可以定义只有跟系统使用同一证书签名的应用才能使用的权限. 这样, 设备制造商就可以像他们使用受保护的系统服务的设备发布新应用.</li>
<li><code>同一签名或系统 以及 系统</code>这两个等级会告诉<code>Android</code>系统, 应用必须驻存在设备的系统分区上, 这样才能使用该权限. 这个功能最常见的例子是预装在系统分区上的Google应用. 这些应用可以使用许多常规应用无法企及的权限, 即使他们用的是Google的签名而不是设备制造商的.</li>
</ul>
<blockquote>
<p>也可以添加属性<code>android:permissionFlags=&quot;costsMoney&quot;</code>它会告诉用户使用此权限的应用会产生费用, 例如要用到发短信的功能的应用. 只要应用提供了可能会给用户带来费用的API, 那就应该用带有此标记的权限来保护该API.</p>
</blockquote>
<h3 id="保护用户数据"><a href="#保护用户数据" class="headerlink" title="保护用户数据"></a>保护用户数据</h3><p>如果要创建安全的数据文件, 不被其他应用访问, 可以在应用数据目录中存储文件. 而不是外部存储中.</p>
<p>如下:演示在应用的数据目录中对一个文件进行数据追加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void appendStringToPrivateFile(Context context, String data, String fileName)&#123;</div><div class="line">    FileOutputStream out = context.openFileOutput(fileName, Context.MODE_APPEND | Context.MODE_PRIVATE);</div><div class="line">    out.write(data.getBytes(&quot;UTF-8&quot;));</div><div class="line">    out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了两个标志位:</p>
<ul>
<li><code>MODE_APPEND</code> 要写入的数据都被追加到文件的末尾,</li>
<li><code>MODE_PRIVATE</code> 该文件只允许你的应用访问, 这个标识位也是默认标志位.</li>
</ul>
<p>当然这只是一种比较安全的方式, 但是如果存储非常敏感的信息, 最好再对文件进行一些加密处理.</p>
<h2 id="客户端数据加密"><a href="#客户端数据加密" class="headerlink" title="客户端数据加密"></a>客户端数据加密</h2><h3 id="Android的加密API"><a href="#Android的加密API" class="headerlink" title="Android的加密API"></a>Android的加密API</h3><p><code>Android</code>中的数据加密和解密API是基于Java SE的<code>javax.crypto</code>包中的API开始的. 实际的实现基于开源的<code>Bouncy Castle</code>加密API. 因此, 在开发<code>Android</code>应用时, 大多是使用Java SE的<code>javax.crypto</code>API就可以.</p>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>使用加密和解密函数时, 需要生成一个可根据用户输入(密码或其他安全方法)重新生成的安全且唯一的密钥.</p>
<p>下面的代码演示了如何为<code>AES算法</code>生成一个<code>SecretKey</code> <code>salt</code>是用于生成密钥的输入部分, 你需要记录下来. 在密码学中, <code>盐salt</code>是用做加密算法中单向函数输入的一段随机数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static SecretKey generateKey(char[] password , byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;</div><div class="line">   int iterations = 1000;</div><div class="line">   int outputKeyLength = 128;</div><div class="line"></div><div class="line">   SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);</div><div class="line"></div><div class="line">   PBEKeySpec pbeKeySpec = new PBEKeySpec(password, salt, iterations, outputKeyLength);</div><div class="line"></div><div class="line">   byte[] keyBytes = secretKeyFactory.generateSecret(pbeKeySpec).getEncoded();</div><div class="line">   return new SecretKeySpec(keyBytes, &quot;AES&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个密钥在后面会使用</p>
<h3 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h3><p>要加密数据, 必须先生成用于加密的作为<code>Cipher</code>输入的盐和初始化向量. 下面的代码会通过<code>SecureRandom</code>类生成一个长度为8字节的盐. 注意: 不需要人工给<code>SecureRandom</code>喂种子, 系统会自动帮你处理. 创建一个初始化向量, 初始化<code>Cipher</code>, 然后将明文加密成字节队列. 有了密文数据之后, 可以使用<code>Base64</code>工具类从这些字节生成一个普通的String对象. 并把初始化向量和盐用同样的方式追加上去, 并通过一个<code>非Base64</code>字符来分开.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static String encryptClearText(char[] password, String plainText)</div><div class="line">       throws Exception &#123;</div><div class="line">   SecureRandom secureRandom = new SecureRandom();</div><div class="line">   int saltLength = 8;</div><div class="line">   byte[] salt = new byte[saltLength];</div><div class="line">   secureRandom.nextBytes(salt);</div><div class="line">   SecretKey secretKey = generateKey(password, salt);</div><div class="line"></div><div class="line">   Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</div><div class="line">   byte[] initVector = new byte[cipher.getBlockSize()];</div><div class="line">   secureRandom.nextBytes(initVector);</div><div class="line">   IvParameterSpec ivParameterSpec = new IvParameterSpec(initVector);</div><div class="line">   cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);</div><div class="line">   byte[] cipherData = cipher.doFinal(plainText.getBytes(&quot;UTF-8&quot;));</div><div class="line">   return Base64.encodeToString(cipherData,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING)</div><div class="line">           + &quot;]&quot; + Base64.encodeToString(initVector,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING)</div><div class="line">           + &quot;]&quot; + Base64.encodeToString(salt,</div><div class="line">           Base64.NO_WRAP | Base64.NO_PADDING);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法返回的结果就是加密后的密文字符串. 解密的时候使用同样的规则解密即可</p>
<h3 id="解密数据"><a href="#解密数据" class="headerlink" title="解密数据"></a>解密数据</h3><p>和加密基本相似, 取出加密的的数据部分. 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static String decryptData(char[] password, String encodedData)</div><div class="line">       throws Exception &#123;</div><div class="line">   String[] parts = encodedData.split(&quot;]&quot;);</div><div class="line">   byte[] cipherData = Base64.decode(parts[0], Base64.DEFAULT);</div><div class="line">   byte[] initVector = Base64.decode(parts[1], Base64.DEFAULT);</div><div class="line">   byte[] salt = Base64.decode(parts[2], Base64.DEFAULT);</div><div class="line"></div><div class="line">   Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</div><div class="line">   IvParameterSpec ivParams = new IvParameterSpec(initVector);</div><div class="line">   SecretKey secretKey = generateKey(password, salt);</div><div class="line">   cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParams);</div><div class="line">   return new String(cipher.doFinal(cipherData), &quot;UTF-8&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面方法可以了解到<code>Cipher</code>,<code>初始化向量</code>,<code>SecretKey</code>是如何通过输入的字符串重新生成的. 只要密码匹配, 就能够对数据进行解码和编码.</p>
<h2 id="设备管理API"><a href="#设备管理API" class="headerlink" title="设备管理API"></a>设备管理API</h2><p>关于这部分, 更多偏向于系统级别的开发. 例如对远程安全加固功能, 当丢失设备通过短信,锁定设备等. 所以此处不做记录. 如果有兴趣可以查看API文档<a href="https://developer.android.com/guide/topics/admin/device-admin.html" target="_blank" rel="external">Device Administration API</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/" data-id="cj7hnife3001g6opjy9mtaxk6" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap9_Android应用安全问题/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/">《Android 编程实战》Chap8_高级音频,视频及相机应用</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/">
            <time datetime="2017-09-11T23:57:02.000Z" itemprop="datePublished">2017-09-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/android/">android</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>阅读《Android 编程实战》一书的随记笔记<br>注：本文主要参考<a href="http://szysky.com" target="_blank" rel="external">http://szysky.com</a></p>
</blockquote>
<h2 id="高级音频应用"><a href="#高级音频应用" class="headerlink" title="高级音频应用"></a>高级音频应用</h2><p><code>Android</code>音频API提供了一些高级功能, 开发者可以把他们集成到自己的应用中. 有了这些API, 就可以很容易的实现<strong>VoIP网络电话</strong>, 构建定制的流媒体音乐客户端, 实现低延迟的游戏音效. 此外, 还有提供文本到语音转换以及语音识别API, 用户可以直接使用音频和用户交互, 而不需要使用用户界面或者触控技术.</p>
<h3 id="低延迟音频"><a href="#低延迟音频" class="headerlink" title="低延迟音频"></a>低延迟音频</h3><p><code>Android</code>有四个用来播放音频的API(算上MIDI那么就是5个)和三个用来录音的API. 接下里会简要介绍这些API.</p>
<hr>
<p><strong>音频播放API</strong></p>
<ul>
<li>音频播放默认使用<code>MediaPlayer</code>. 该类适合播放音乐或者视频, 既能播放流式资源(比如在线网络收音机), 也可以播放本地文件. 每个<code>MediaPlayer</code>都有一个关联的状态机, 需要在应用程序中跟踪这些状态. 开发者可以使用<code>MediaPlayer</code>类的API在自己的应用中嵌入音乐或者视频播放功能, 而无需额外处理或者考虑延迟问题.</li>
<li>第二种是<code>SoundPool</code>类, 它提供了低延迟的支持, 适合播放音效和其他比较短的音频, 比如可以使用<code>SoundPool</code>播放游戏声音. 但是, 它不支持音频流, 所以不适合那些需要实时音频流处理的应用如<code>VoIP</code>.</li>
<li>第三种是<code>AudioTrack</code>类, 它允许把音频流缓冲到硬件中, 支持低延迟播放, 甚至适合流媒体场景. <code>AudioTrack</code>通常能提供足够低的延迟, 可在<code>VoIP</code>或类似应用中使用.</li>
</ul>
<p>下面代码展示如何在<code>VoIP</code>应用中使用<code>AudioTrack</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class AudioTrackDemo &#123;</div><div class="line"></div><div class="line">    private final AudioTrack mAudioTrack;</div><div class="line">    private final int mMinBufferSize;</div><div class="line"></div><div class="line">    public AudioTrackDemo() &#123;</div><div class="line"></div><div class="line">        // 确定音频流的最小缓冲区和大小</div><div class="line">        mMinBufferSize = AudioTrack.getMinBufferSize(16000, AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT);</div><div class="line"></div><div class="line">        mAudioTrack = new AudioTrack(AudioManager.STREAM_VOICE_CALL,</div><div class="line">                16000,</div><div class="line">                AudioFormat.CHANNEL_OUT_MONO,</div><div class="line">                AudioFormat.ENCODING_PCM_16BIT,</div><div class="line">                mMinBufferSize * 2,</div><div class="line">                AudioTrack.MODE_STREAM);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void playPcmPacket(byte[] pcmData)&#123;</div><div class="line">        if (mAudioTrack != null &amp;&amp; mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED)&#123;</div><div class="line"></div><div class="line">            // 判断是否处在播放状态</div><div class="line">            if (mAudioTrack.getPlaybackRate() != AudioTrack.PLAYSTATE_PLAYING)&#123;</div><div class="line">                mAudioTrack.play();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mAudioTrack.write(pcmData, 0, pcmData.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //  设置停止</div><div class="line">    public void stopPlayback()&#123;</div><div class="line">        if (mAudioTrack != null)&#123;</div><div class="line">            mAudioTrack.stop();</div><div class="line">            mAudioTrack.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对这个类进行一下整理, 首先从构造函数开始. 最开始需要确定音频流的最小缓冲区大小. 要做到这一点, 需要知道采样率, 数据是单声道还是立体声, 以及是否使用8位或者16位<code>PCM</code>编码. 然后以采样率和采样大小作为参数调用<code>AudioTrack.getMinBufferSize()</code>, 该方法会以字节形式返回<code>AudioTrack</code>实例的最小缓冲区大小</p>
<p>接下来, 根据使用正确的参数创建<code>AudioTrack</code>实例, 第一个参数为音频的类型, 不同的应用使用不同的值. 对于<code>VoIP</code>这种应用来说使用<code>STREAM_VOICE_CALL</code>, 而对流媒体音乐应用则使用<code>STREAM_MUSIC</code>.</p>
<p>对于参数2,3,4会根据使用场景而有所不同. 这些参数跟别表示<code>采样率</code>, <code>立体声/单声道</code>, <code>采样大小</code>. 一般而言, 一个<code>VoIP</code>会使用<code>16kHz</code>的16位单声道, 而常规的音乐CD可能采用<code>44.1kHz</code>的16位立体声. 16位立体声采样率需要更大的缓冲区以及更多的数据传输, 但是音质会更好. 所有的<code>Android</code>设备都支持<code>PCM</code>以<code>8kHz</code>,<code>16kHz</code>,<code>44.1kHz</code>的采样率播放8位或者16位的立体声.</p>
<p>缓冲区大小参数应该是最小缓冲区大小的倍数, 实际取决于具体的需求, 有时网络延迟等因素也会影响缓冲区大小. <strong>注意: 任何时候都应该避免使用空的缓冲区, 因为可能导致播放出现故障</strong></p>
<p>最后一个参数决定只发送一次音频数据<code>MODE_STATIC</code>还是连续发送数据流<code>MODE_STREAM</code>. 第一种情况需要一次发送整个音频剪辑. 对于持续发送音频流的情况, 可以发送任意大小块的<code>PCM数据</code>, 处理流媒体音乐或者VoIP通话时可能会使用这种方式.</p>
<hr>
<p><strong>2. 录音API</strong></p>
<p>说道录制音频(也可能是视频), 首先要考虑的API是<code>MediaRecorder</code>. 和<code>MediaPlayer</code>类似, 需要在应用代码中跟踪<code>MediaRecorder</code>类的内部状况. 由于<code>MediaRecorder</code>只能把录音保存在文件中, 所以他不适合录制流媒体.</p>
<p>如果需要录制流媒体, 可以使用<code>AudioRecorder</code>, 它和之前描述的<code>AudioTrack</code>非常相似.</p>
<p><a href="https://github.com/suzeyu1992/AndroidProgrammingPushingTheLimits/commit/0109285e016f34c5403195344987cee5a7b791e0" target="_blank" rel="external">链接代码演示了如何创建<code>AudioRecorder</code>实例录制16位单声道16kHz的音频采样</a></p>
<p>其实和<code>AudioTrack</code>的创建过程非常给你相似, 在使用<code>VoIP</code>或者类似应用时可以很方便地把他们结合起来.</p>
<h3 id="OpenSL-ES"><a href="#OpenSL-ES" class="headerlink" title="OpenSL ES"></a>OpenSL ES</h3><p>前面说了3播放API和2个录制API. 还有最后一个API <code>OpenSL ES</code>, 它同时支持播放和录制. 该API是科纳斯组织(Khronos Group)的一个标准, 这个组织还负责<code>OpenGL API</code></p>
<p><code>OpenSL ES</code>提供了低级别的音频硬件访问和低延迟特性来处理音频播放和录制. 虽然<code>Android</code>中其他音频API都有方便的Java API, 但是<code>OpenSL ES</code>目前仅支持在<code>Android NDK</code>中使用本地C代码访问.</p>
<blockquote>
<p><code>= =!!! 到这里能力受限, 无法实现出效果...所以此章抄书就此太监. 后续包括OpenGL 串联Surface用于视频MediaPlayer的渲染层或者相机处理把预览画面的流连接到纹理流, 并实施处理画面实现现实AR应用等.</code></p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/" data-id="cj7hnifdy001a6opjtajn6b8f" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://yoursite.com/2017/09/12/android/books/《Android 编程实战》Chap8_高级音频,视频及相机应用/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/25/react/第9篇React Native 与 App 集成方案/" class="title">第9篇React Native与App集成方案</a></p>
                            <p class="item-date"><time datetime="2017-09-25T03:51:02.000Z" itemprop="datePublished">2017-09-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/25/react/第8篇动手写组件/" class="title">第8篇动手写组件</a></p>
                            <p class="item-date"><time datetime="2017-09-25T03:48:59.000Z" itemprop="datePublished">2017-09-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/25/react/第7篇JSX在React-Native中的应用/" class="title">第7篇JSX在React-Native中的应用</a></p>
                            <p class="item-date"><time datetime="2017-09-25T03:48:38.000Z" itemprop="datePublished">2017-09-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/25/react/第6篇UI组件/" class="title">第6篇UI组件</a></p>
                            <p class="item-date"><time datetime="2017-09-25T03:48:08.000Z" itemprop="datePublished">2017-09-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/react/">react</a></p>
                            <p class="item-title"><a href="/2017/09/24/react/第5篇React-Native布局实战2/" class="title">第5篇React-Native布局实战2</a></p>
                            <p class="item-date"><time datetime="2017-09-24T14:12:33.000Z" itemprop="datePublished">2017-09-24</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">44</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/android/code/">code</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/github/">github</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android-编程实战》/">《Android 编程实战》</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android开发艺术探索》/">《Android开发艺术探索》</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/《Android编程权威指南》/">《Android编程权威指南》</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/设计模式/">设计模式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/面试/">面试</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/learn/">learn</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/learn/《如何高效学习》/">《如何高效学习》</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/node/7days/">7days</a><span class="category-list-count">7</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a><span class="category-list-count">9</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">63</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">7</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/analysis/">analysis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">37</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anslysis/">anslysis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/autoLink/">autoLink</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/">code</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gitlab/">gitlab</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/glide/">glide</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/indicator/">indicator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learn/">learn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/share/">share</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/">ssh</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/textview/">textview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/analysis/" style="font-size: 10px;">analysis</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/anslysis/" style="font-size: 10px;">anslysis</a> <a href="/tags/autoLink/" style="font-size: 10px;">autoLink</a> <a href="/tags/code/" style="font-size: 14.29px;">code</a> <a href="/tags/git/" style="font-size: 11.43px;">git</a> <a href="/tags/github/" style="font-size: 17.14px;">github</a> <a href="/tags/gitlab/" style="font-size: 10px;">gitlab</a> <a href="/tags/glide/" style="font-size: 14.29px;">glide</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/indicator/" style="font-size: 10px;">indicator</a> <a href="/tags/java/" style="font-size: 12.86px;">java</a> <a href="/tags/learn/" style="font-size: 10px;">learn</a> <a href="/tags/markdown/" style="font-size: 11.43px;">markdown</a> <a href="/tags/mysql/" style="font-size: 14.29px;">mysql</a> <a href="/tags/node/" style="font-size: 15.71px;">node</a> <a href="/tags/react/" style="font-size: 18.57px;">react</a> <a href="/tags/share/" style="font-size: 10px;">share</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/textview/" style="font-size: 10px;">textview</a> <a href="/tags/vim/" style="font-size: 11.43px;">vim</a> <a href="/tags/设计模式/" style="font-size: 11.43px;">设计模式</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2017 Ernest Chang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2142274"></script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>