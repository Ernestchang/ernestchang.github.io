title: mysql_2 基本查询语句
date: 

categories: 
- mysql
tags:  
- mysql
---

> 注：本文主要参考[http://szysky.com](http://szysky.com)

### 数据库表设计3范式

**第一范式(1NF)**

要求数据达到原子性，是数据不可再分

**第二范式(2NF)**

使每一行数据具有唯一性，并消除数据之间的部分依赖

1. 每一行数据具有唯一性: 只要给表设计主键，就可以保证唯一性
2. 消除数据之间的”部分依赖”

依赖的概念

就是在一个表中，其中某个字段的值B可以由另一个字段的值A来决定，则此时我们就称为：字段B依赖于字段A,或者字段A决定字段B。

就是根据字段A的某个值，一定可以找出一个确定的字段B的值，就是A决定B.

部分依赖？

如果某个字段，值依赖于部分主键字段，此时就称为部分依赖。–发生此情况的前提一定是: 主键字段有多个。

完全依赖？
某个字段，是依赖于主键的所有字段。– 如果一个表的主键只有一个字段，则此时必然是完全依赖。

**第三范式(3NF)**

独立性，消除传递依赖。

使每个字段都独立地依赖于主键字段(独立性),而要消除其中部分非主键字段的内部依赖–这种内部依赖会构成传递依赖

### 数据操作语言 DML

**插入数据(增)**

- 形式1: `insert [into] 表名 [(字段名1，字段名2...)] values(值表达式1，值表达式2,...),(),()...;`
- - 这是最常用的插入语句，可以一次性插入多行数据，用逗号隔开；
- - 插入语句，要理解为每次插入数据都是以行为单位进行插入；
- - 字段名通常不推荐省略，其后续的值列表应该字段列表一一对应
- - 其中的值表达式，可以是一个直接或函数调用结果，或变量值; 其中，如果对应字段是字符或时间类型，则直接值应该使用单引号
- 形式2: `replace [into] 表名 [(字段名1，字段名2...)] values(值表达式1，值表达式2,...),(),()...;`
- - 其跟`insert into`几乎一样: 唯一区别 如果插入的数据的主键或唯一键有重复，则此时就会变成修改改行数据
- 形式3: `insert [into] 表名 [(字段名1，字段名2，...)] select 字段名1，字段名2,... from 其他表名;`
- 形式4: `insert [into] 表名 set 字段名1=值表达式1，字段名2=值表达式2,...;`

**load data (载入数据) 语法**

使用于载入 结构整齐的纯文本数据。 前提也要有一个对应结构的已存在的表。

简单格式: `LOAD DATA INFILE '文件名' INTO TABLE 表名;`

**删除数据**

形式: `delete from 表名 [where 条件] [order by 排序] [limit 限定];`

说明:

1. 删除数据仍然是以行为单位进行
2. 通常删除数据都需要带`where`条件，否则就会删除所有数据。
3. `where`条件的语法跟`select`中的语法一样
4. `order by` 排序设定，用于指定这些数据的删除顺序，他通常跟`limit`配合使用才有意义
5. `limit`限定用于设定删除多少行(按`orderby` 设定顺序)

### 修改数据

形式: `update 表名 set 字段1=值1, 字段2=值2,...[where 条件] [order by 排序字段][limit 限制行数];`

说明:

1. 通常，`update`语句，也都需要`where`条件，否则: 就会修改所有(这很少见);
2. `where`条件的语法跟select中语法一样;
3. `order by` 用于设定修改的顺序，`limit`用于设定修改的行数，他们通常也是结合使用(虽然很少用)
4. 实际应用中，通常很少用到`order by`和`limit`，修改的常规操作就成为: `update 表名 set 字段1=值1，字段2=值2,... where条件`

### 数据查询语言 DQL

**基本语法形式**

`select [all | distinct] 字段或表达式列表 [from 子句] [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句];`

**字段或表达式列表**

1. 字段，肯定来源于表，所以必然依赖于`from`语句
2. 表达式是类似这样一个内容: 8 ， 8+3， now(); //concat()函数是mysql中的系统函数，用于连接多个字符串。
3. 每个输出项(字段或表达式结果)，都可以给其设定一个别名，形式为: 字段或表达式 `as` 别名。
4. `all` 和 `distinct` 设定`select`出来的数据，是否消除重复行，可以不写，那就是默认值`all`。 `all`表示不消除，既所有都出来，默认值；`distinct`表示会消除。
5. `form`，表示`select`部分从中取得数据的数据源—就是表。
6. `where`，对数据源中的数据进行帅选的条件设定，所以`where`依赖于`form`子句。

**is 运算符: 空值和布尔值的判断**

有四种情况:

- `xx is null`: 判断某个字段是null值，就是没有值
- `xx is not null`: 判断某个字段不是null值
- `xx is true`: 判断某个字段为真
- `xx is false`: 判断某个字段为假，false，0，0.0，’’, null

**其他扩展**

- 位类型`bit`: 使用形式: `bit[(M)]` ，其中M是1~64的数字，表示使用多少位二进制数字来存储数据。插入形式为: b’value’ 比如: b’101’
- 序列类型`serial`: 只是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名(同义词)
- 布尔类型`bool`: 其实只是`tinyint(1)`的同义词，其值为`0`就表示`false`，否则为`true`

**between运算符: 范围判断**

用于判断某个字段的数据值是否在某个给定的范围之间–适用于数字类型

形式: `xx between 值1 and 值2;`

含义: xx字段的值在给定值1和值2之间，其实相当于: xx>=值1 and xx<=值2

**in运算符**

给出确定数据的范围判断

语法: `xx in (值1, 值2, 值3, ...);`

含义: 表示字段xx的值为所给出的这些值中的一个，就算是满足了条件；这些值，通常是零散无规律的。

**like运算符**

对字符串进行模糊查找

语法: `xx like '要查找的内容'`

含义: 实现对字符串的某种特征信息的模糊查找，它依赖于一下两个特殊的符号。

- `%` :它代表任何个数的任何字符
- `_` :它代表一个任何字符

**group by 分组**

形式: `group by 字段1 [desc|asc] ,字段2 [desc | asc], ....`

说明:

1. 分组是对前述已经找出的数据(既`where`已经筛选结束的)进行某种指定标准依据的分组。
2. 同时，该分组结果，可以同时指定其 排序方式 ：`desc`倒序 ，`asc`顺序
3. 通常，分组就是一个字段，2个以上很少

什么叫做分组？

分组: 就是讲多行数据，以某种标准(就是指定的字段)来进行分类存放。

特别注意: 分组之后的结果，一定要理解为：只有一个个的组。 在部分语言此语法可能会出现不同的问题。

应用中，分组之后，通常只有如下几种可用的组信息。

- 分组依据本身的信息，其实就是该分组依据的字段名
- 每一组的数量信息: 就是`count(*)`获得
- 原来数据中的 数值类型字段的聚合信息 包括如下几个:
- 最大值: `max(字段名)`; 最小值: `min(字段名)`; 平均值 `avg(字段名)`; 总和值: `sum(字段名)`; 上述其实是4个系统内部函数。

**having 子句**

`having`的作用和`where`完全一样，但其只是对 分组的结果数据 进行筛选。 既`where`对原始数据进行筛选； `having`对分组之后的数据进行筛选。

这里既是在`select` 后面没有写查询`count(*)` 时，在`having`设定筛选条件的时候，也可以使用，因为`count(\*)`是独立计算的结果，既对每一组进行原始数据行的统计，并用该条件进行筛选。

**恢复(导入)数据**

mysql登录后: `source "备份数据文件的完整路径"`

**order by 子句**

用于 将前面取得的数据以设定的标准(字段)来进行排序以输出结果。

形式: `order by 字段1 [asc | desc], 字段2 [asc | desc], ...`

**limit子句**

用于将 前述取得的数据 ，按指定的行取出来: 从第几行开始取出多少行。

形式: `limit` 起始行号 , 要取出的行号

说明: 行号默认从`0`开始， 行号和`id`没有关系。

### 对select语句进行简要总结

1. 虽然在形式上，`select`的很多子句都是可以省略的，但是他们的顺序(如果出现)，就不能打乱:必须仍然按照给出的顺序写出
2. `where`子句依赖于`from`子句: 既没有`from`，就不能有`where`
3. `having`子句依赖于`group by`子句: 既没有`group by`就不能有`having`
4. `select` 中的字段也是依赖于`from`子句
5. 上述子句的执行过程，基本上也是按照该顺序进行: – 从from的数据源中获取所有的数据，然后使用`where`对这些数据进行筛选，之后再使用`group by`子句对筛选出来的数据进行分组，接下来才可以使用`having`对这些分组的数据进行筛选，然后才可以`order by` 和`limit`。