title: Shell常用手册
date: 

categories: 
- shell
tags:  
- shell
---
> 注：本文主要参考[http://szysky.com](http://szysky.com)
## 文件系统

### 遍历目录

> 格式: `cd destination`

```
# 绝对文件路径
$ cd /usr/bin

# 相对文件路径 进入当前目录下的doc文件夹
$ cd doc

# 进入当前文件夹的同级目录pics
$ cd ../pics
```

### 查看当前目录路径

```
$ pwd
```

### 文件基本操作操作

```
# 显示当前目录下的文件和目录, 按字母排序, 展示顺序为按列
$ ls

# 如果想让文件夹变得更容易区分, -F参数可让显示文件夹后面追加一个 /
$ ls -F

# 如果查看包括隐藏文件, .开头的文件. 可使用 -a 参数
$ ls -a

# 默认ls只会显示指定目录下一个层级所有文件. 如果要显示指定目录下的所有所有子层级
$ ls -R
```

### 文件的长列表

如果需要查看更多的信息, 比如**文件类型**,**文件权限**,**属组或属主**,**大小**等

```
$ ls -l

# 一个连贯的展示习惯, 就是将参数组合, 例如展示隐藏 长列表的显示结果
$ ls -la
```

### 过滤输出信息

例如如果你只想想查找目录下的`test.java`文件的相关信息. 不想显示出其他信息干扰到你. 你可以这样

```
# 只显示过滤要求的文件相关信息
$ ls -l test.java

# 可以使用通配符 ? , 代表一个任意字符
$ ls -l tes?.java

# 可以使用通配符 * , 代表0或者多个任意字符
$ ls -l tet*
```

上面的后两种使用`星号`或者`问号`被称为`文件扩展匹配`, 就是使用通配符进行模糊匹配的过程. 还有一些其他的通配符. 还是以`test.java`为例

```
# 指定某个位置的的区间, [a-z], abc...xyz都可以
$ ls -l tes[a-z].java
```

### 文件创建

> 创建一个空文件`touch`命令

```
# 创建一个名字为 Hello.java 的文件
$ touch Hello.java

# 当文件已经存在时, touch命令不会清空原有数据, 但是会更改文件的修改时间
$ test ll *.js
-rw-r--r--  1 suzeyu  staff   107B 10 26 16:36 test.js
$ test touch test.js
$ test ll *.js
-rw-r--r--  1 suzeyu  staff   107B 12 26 16:51 test.js


# 如果只想改变 访问时间 那么通过 -a 参数
$ touch -a Hello.java
```

### 复制文件

> `cp source destination`

```
# 文件 -> 文件的拷贝  
$ cp test.cpp test_1.cpp


# 如果目标文件文件已经存在可能会直接覆盖, 所以 -i 会让操作更加安全,警告提示
$ cp -i test.cpp test_1.cpp

# 文件 -> /users/suzeyu 目录下
$ cp test.cpp /users/suzeyu/    #注意最后的 / , 如果没有就代表users目录下suzeyu文件

# /users/suzeyu/orgin.txt文件  -> 当前目录下, 利用 . 可以代表当前目录
$ cp /users/suzeyu/orgin.txt .


# 当前目录下的olds文件夹 -> 目录下的命为news的新文件夹
$ cp -R olds/ news          # -R 可以递归遍历olds文件夹,  并创建新的news

# 也可以使用通配符. 把所有的java文件复制出去
$ cp *.java  javaDir/
```

### 链接文件

链接是目录中指向文件真实位置的占位符.

- `符号链接`: 一个真实的文件. 指向存放在虚拟目录结构中的一个文件.
- `硬链接`: 会创建独立的虚拟文件, 包含原始文件的信息及位置. 但他们根本而言是一个文件

```
# 符号链接
# 为一个文件创建符号链接 使用 ln 命令和 -s 选项
$ ln -s filename  linkname

# 通过 ls -l *name, 查看文件信息, 会发现linkname -> filename. 这两个文件是完全不同的文件, 
# 也可以通过文件唯一 inode 编码来证实

$ ls -i *name


# 硬链接
# ln 命令, 不过不需要-s 选项
$ ln filename hardname
```

### 重命名文件

> 重命名也被称为`移动(moving)` , 主要是`mv`命令

```
# 修改文件 test.java 名为 new_test.java
$ mv test.java new_test.java    # mv不会改变文件唯一inode编码和时间戳. 

# 也可以移动文件到某个文件夹
$ mv test.java /Users/suzeyu/Desktop/

# 同样可以在移动的时候, 添加 -i 参数, 同cp一样. 当覆盖已有文件时会警告提示


# 或者移动整个目录及其内容
$ mv oldDirs  newDirs
```

### 删除文件

> `rm` 删除也称为`移除removing`. 但要注意, 一旦删除了可以无法找回的. 所以删除前一定要确认好信息

```
# 删除文件 Hello.txt
$ rm Hello.txt

# 添加确认信息删除, 上面的会直接删除掉文件, 而如果加入了 -i 会有警告提示
$ rm -i Hello.txt

# 同样可以使用通配符进行批量删除, 例如当前目录的java文件
$ rm *.java

# 如果想删除整个文件夹, 那么需要配合使用 -R 进行递归遍历删除.
$ rm -R dirsName

# 如果有多个警告提示, 想强制关掉, 可以添加  -f 参数
# rm 中的 -r -R 效果是一样
```

### 创建目录

```
# 创建一个目录
$ mkdir name

# 如果需要批量的创建目录. 那么需要 -p 选项的配合
$ mkdir -p parentDir/subDir/sunDir
```

### 删除目录

```
# 删除一个目录
$ rmdir name

# 默认 rmdir 只能删除空目录. 可以使用 rm 来递归删除, 
$ rm -r name
```

### 查看文件类型

> `file`能够探测文件内部, 并决定文件时什么类型

```
# 查看文件的类型
$ file name

# 可以区分文本类型, 图片, 目录, 符号链接文件, 脚本, 可执行二进制等.
```

### 查看整个文件

> `cat`, `more`, `less`这是很便捷的工具

```
# 你想查看一个Hello.java的类的内容
$ cat Hello.java

# 也可以让显示的内容加上行号, 这也很简单
$ cat -n Hello.java

# 或许你的类里面充斥着各种空白行, 而你不需要空白行添加行号. 那么 -b 可以解决
$ cat -b Hello.java
```

这里有一个问题, 如果打开的文本很大, 那么直接使用`cat`会加载全部的内容. 或许我们需要进行控制, 那么`more`命令`分页工具`现在就可以登场了.

```
# 分页显示
$ more Hello.java
```

这回在显示一屏的内容之后停止下来. 你可以通过`上下方向键`控制. 也可以通过`空格`进行翻页. `q`键可推出预览模式.

`less`命令工具, 这是一个比`more`更高级一些的根据. 功能和使用很相似.

### 查看部分文件

> 如果只关心头部和尾部的内容. 那么`tail`和`head`命令. 可以很好的解决这种场景

------

`tail`尾部查看

```
# 查看文件的尾部
$ tail Hello.java 

# 默认 tail 显示文件的最后10行 , 通过 -n 参数来修改所显示的行数
$ tail -n 5 Hello.java
```

------

`head`头部查看

```
# 查看头部内容 , 默认显示前10行
$ head Hello.java

# 指定显示多少行的参数设置
$ head -20 Hello.java
```

## 检测程序

### 进程查看

> `ps` 默认显示运行在当前控制台下属于当前用户的进程

```
# -e 参数可以显示所有运行在系统上的进程
# -f 参数则扩展了输出
# -l 会产生一个长格式的输出
```

关于`-f`的扩展出的选项的字段含义

| UID   | 启动这些进程的用户      |
| ----- | -------------- |
| PID   | 进程的进程ID        |
| PPID  | 父进程的进程号        |
| C     | 进程生命周期中的系统时间   |
| STIME | 进程启动时的系统时间     |
| TTY   | 进程启动时的终端设备     |
| TIME  | 运行进程需要的累积CPU时间 |
| CMD   | 启动程序名称         |

------

关于`-l`参数字段的含义

| F     | 内核分配给进程的系统标记                             |
| ----- | ---------------------------------------- |
| S     | 进程的状态(O运行; S休眠; R可运行正在等待运行; Z僵化; 进程已结束但父进程不在; T停止) |
| PRI   | 进程的优先级, 数字越大优先级越低                        |
| NI    | 谦让度值用来参与决定优先级                            |
| ADDR  | 进程的内存地址                                  |
| SZ    | 加入进程被换出, 所需要交换空间的大致大小                    |
| WCHAN | 进程休眠的内核函数地址                              |

------

```
# 查看实时进程监测
$ top
```

## 磁盘空间

### mount

用来挂载媒体的命令叫做`mount`. 默认情况下, `mount`命令会输出当前系统上挂载的设备列表

```
# 显示当前系统上挂载的设备列表
$ mount
```

一般输入会是如下

```
/dev/disk1 on / (hfs, local, journaled)

提供了四部分信息, 从前到后
1. 媒体的设备文件名 
2. 媒体挂载到虚拟目录的挂载点
3. 文件的系统类型  hfs 
4. 已挂载媒体的访问状态
```

如果需要手动挂载, 需要root权限

```
$ mount -t type device directory
|   |   |   |   |   |   |   |   |
$ mount -t ntfs /dev/sdb1 /media/disk
```

------

**卸载设备umount**

形式: `umount [ directory | device ]`

### df命令

> `df`可以快速的知道某个设备上还有多少磁盘空间, 方便查看所有已经挂载的磁盘情况

```
# 配合 -h 可以把输出按照用户易读的形式表示. 如M, G
$ df -h
```

### du命令

> `df`可以很容易发现那个磁盘的存储空间快没了. `du`就是接下来要处理问题的工具, 它可以显示某个特定目录下的磁盘使用情况. 这一方法可用来快速判断系统上某个目录下是不是有超大文件.

```
# 常规使用, 显示当前目录下所有的文件, 目录, 和子目录的使用情况
# 会以磁盘块为单位显示占有空间
$ du

# 一般需要配合几个参数进行使用
-c 显示所有已列出文件的总大小
-h 以用户易读的方式显示占有大小, 如K, M, G
```

### 数据的排序

> `sort`命令按照会话指定的默认语言的排序规则对文本文件中的数据进行排序

例如:

![img](http://szysky.com/2016/12/26/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/sort_num.png)

如果你要排序的是数字, 那么需要通过`-n`让`sort`命令不要把数字当成字符处理. 这样对于100 > 2的情况就可以避免

```
# 让sort命令识别数字, 而不是把每一个数字当成字符处理
$ sort -n fileName

# 如果需要排序的按照月份, 并且排序的值是Jan, Feb, Mar等三字符的月份, 那么使用-M
$ sort -M fileName
```

不仅仅如此, 例如如果我们有这么一个键值表:

![img](http://szysky.com/2016/12/26/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/age_origin.png)

如果想进行年龄的排序, 那么使用`-k`和`-t`参数进行年龄字段的排序.

- `-t`: 可以指定字段分隔符
- `-k`: 指定排序的字段

例如上面这个图, 分割字段就是`:`, 根据排序的条件是第`二`个字段

![img](http://szysky.com/2016/12/26/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/age_sort.png)

------

那么如果想查看目录下所有文件的占用排序, 就可以

```
# 从大到小排序
$ du -s * | sort -nr
```

### 搜索数据

> 在大文件查找一条数据, 通过`grep`命令就可直接查找
> `grep`会在输入或者指定的文件中查找包含匹配指定模式的字符的行

```
# 查找文件中的张三的行
$  test grep 张三 age.txt
张三:40

# 查找文件中的 : 的行
$  test grep : age.txt
张三:40
李四:20
王五:18
赵六:79


# 反向搜索, 除张三之外的人的行
$  test grep -v 张三 age.txt
李四:20
王五:18
赵六:79


# 显示匹配的行号, -n
$  test grep -vn 张三 age.txt
2:李四:20
3:王五:18
4:赵六:79


# 如果只想知道含有多少行, 满足条件 -c
$  test grep -c 张三 age.txt
1


# 如果要指定多个模式, 通过 -e 参数
$  test grep -e 张三 -e 王五 age.txt
张三:40
王五:18


# 默认,grep用基本的Unix风格的正则表达式来匹配模式
# 搜索行中有8或者9的行
$  test grep [89] age.txt
王五:18
赵六:79
```

`grep`是一个基础的搜索工具, 衍生版本也是存在的

- `egrep`: 是`grep`的衍生, 支持`POSIX`扩展正则表达式. 含有更多可以用来指定匹配的模式的字符
- `fgrep`: 则是另外一个版本, 支持将匹配模式指定为用换行符分隔的一系列的固定长度的字符串. 这样就可以把这列字符串放到一个文件中.

## 压缩数据

> 压缩数据主要针对一个文件

| 工具       | 文件扩展名 | 描述                               |
| -------- | ----- | -------------------------------- |
| bzip2    | .bz2  | 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码 |
| compress | .Z    | 最早的Unix文件压缩工具, 基本没人用             |
| gzip     | .gz   | GNU压缩工具, 用Lempel-Ziv编码           |
| zip      | .zip  | Window上PKZIP工具的Unix实现            |

`gzip`软件包含以下工具:

- `gzip`: 用来压缩文件
- `gzcat`: 用来查看压缩过的文本文件的内容
- `gunzip`: 用来解压文件

用法和`bzip2`一样

## 归档数据

> 在`Unix`和`Linux`上最广泛使用的归档工具是`tar`命令

`tar`命令的基本格式

`tar function [options] object1 object2 ...`

**function参数可选**

| 功能   | 长名称          | 描述                                 |
| ---- | ------------ | ---------------------------------- |
| -A   | –concatenate | 将一个已有tar归档文件追加到另一个已有tar归档文件        |
| -c   | –create      | 创建一个新的tar归档文件                      |
| -d   | –diff        | 检查归档文件和文件系统的不同之处                   |
|      | –delete      | 从已有tar归档文件中删除                      |
| -r   | –append      | 追加文件到已有tar归档文件末尾                   |
| -t   | –list        | 列出已有tar归档文件的内容                     |
| -u   | –update      | 将比tar归档文件中已有的同名文件,新的文件追加到该tar归档文件中 |
| -x   | –extract     | 从已有tar归档文件中提取文件                    |

**option常用选项**

| 选项      | 描述                  |
| ------- | ------------------- |
| -C dir  | 切换到指定目录             |
| -f file | 输出结果到文件或设备file      |
| -j      | 将输出重定向给bzip2命令来压缩内容 |
| -p      | 保留所有文件权限            |
| -v      | 在处理文件时显示文件          |
| -z      | 将输出重定向给gzip命令来压缩内容  |

------

列举常用的方式

```
# 创建归档, 把test/ test2/两个文件夹的内容进行归档
$ tar -cvf test.tar  test/ test2/


# 列出tar文件的内容, 但不提取
$ tar -tf test.tar


# 解压提取归档的内容
$ tar -xvf test.tar
```